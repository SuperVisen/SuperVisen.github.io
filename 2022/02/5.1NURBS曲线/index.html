<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>NURBS曲线（待整理） | Visen</title><meta name="keywords" content="NURBS"><meta name="author" content="Visen Cao"><meta name="copyright" content="Visen Cao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引子     👋这里是Visen.平时需要和CAGD（计算机辅助几何设计）打交道，这里参考施法中《计算机辅助几何设计与非均匀有理B样条 修订版》和配套书籍光盘，整理出NURBS曲线编程所需基础知识点和C++编程实例，只为对知识快速上手，而且能理清书籍的脉络，剔除曲面部分。整理不是为了丢掉书，而是为了更好地利用书！  第一章 曲线和曲面的基本理论 1.直线的表示方法 动点p是随着某个参数u在规范参">
<meta property="og:type" content="article">
<meta property="og:title" content="NURBS曲线（待整理）">
<meta property="og:url" content="https://supervisen.github.io/2022/02/5.1NURBS%E6%9B%B2%E7%BA%BF/index.html">
<meta property="og:site_name" content="Visen">
<meta property="og:description" content="引子     👋这里是Visen.平时需要和CAGD（计算机辅助几何设计）打交道，这里参考施法中《计算机辅助几何设计与非均匀有理B样条 修订版》和配套书籍光盘，整理出NURBS曲线编程所需基础知识点和C++编程实例，只为对知识快速上手，而且能理清书籍的脉络，剔除曲面部分。整理不是为了丢掉书，而是为了更好地利用书！  第一章 曲线和曲面的基本理论 1.直线的表示方法 动点p是随着某个参数u在规范参">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044590.jpeg">
<meta property="article:published_time" content="2022-02-11T11:45:21.000Z">
<meta property="article:modified_time" content="2022-07-24T12:18:07.604Z">
<meta property="article:author" content="Visen Cao">
<meta property="article:tag" content="NURBS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044590.jpeg"><link rel="shortcut icon" href="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121051907.jpeg"><link rel="canonical" href="https://supervisen.github.io/2022/02/5.1NURBS%E6%9B%B2%E7%BA%BF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NURBS曲线（待整理）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-24 20:18:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/iconfont/iconfont.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121051907.jpeg" onerror="onerror=null;src='https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121055307.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://nwuzmed.ga/"><i class="fa-fw fa fa-flask"></i><span> DAC导航</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw iconfont icon-bijiben"></i><span> 笔记本</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Net%E5%BC%80%E5%8F%91/"><i class="fa-fw iconfont icon-csharp"></i><span> .Net</span></a></li><li><a class="site-page child" href="/categories/Python/"><i class="fa-fw iconfont icon-python"></i><span> Python</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa fa-link"></i><span> 博客工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.tidio.com/panel/conversations"><i class="fa-fw fa fa-comments"></i><span> 在线聊天</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="http://guozhivip.com/imgs.html"><i class="fa-fw iconfont icon-charutupian"></i><span> 高清图源</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.emojiall.com/zh-hans"><i class="fa-fw iconfont icon-biaoqingbao"></i><span> 表情包词典</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://console.leancloud.cn/login?from=%2Fapps"><i class="fa-fw iconfont icon-pinglun"></i><span> 评论管理</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.123pan.com/login"><i class="fa-fw iconfont icon-yunpan"></i><span> 123云盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw iconfont icon-zuozhe"></i><span> 关于作者</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blackBoard/"><i class="fa-fw iconfont icon-xiaoheiban"></i><span> 小黑板</span></a></li><li><a class="site-page child" href="/heartWay/"><i class="fa-fw iconfont icon-step_count"></i><span> 成长历程</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044590.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Visen</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://nwuzmed.ga/"><i class="fa-fw fa fa-flask"></i><span> DAC导航</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw iconfont icon-bijiben"></i><span> 笔记本</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Net%E5%BC%80%E5%8F%91/"><i class="fa-fw iconfont icon-csharp"></i><span> .Net</span></a></li><li><a class="site-page child" href="/categories/Python/"><i class="fa-fw iconfont icon-python"></i><span> Python</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa fa-link"></i><span> 博客工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.tidio.com/panel/conversations"><i class="fa-fw fa fa-comments"></i><span> 在线聊天</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="http://guozhivip.com/imgs.html"><i class="fa-fw iconfont icon-charutupian"></i><span> 高清图源</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.emojiall.com/zh-hans"><i class="fa-fw iconfont icon-biaoqingbao"></i><span> 表情包词典</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://console.leancloud.cn/login?from=%2Fapps"><i class="fa-fw iconfont icon-pinglun"></i><span> 评论管理</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.123pan.com/login"><i class="fa-fw iconfont icon-yunpan"></i><span> 123云盘</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw iconfont icon-zuozhe"></i><span> 关于作者</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blackBoard/"><i class="fa-fw iconfont icon-xiaoheiban"></i><span> 小黑板</span></a></li><li><a class="site-page child" href="/heartWay/"><i class="fa-fw iconfont icon-step_count"></i><span> 成长历程</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NURBS曲线（待整理）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-11T11:45:21.000Z" title="发表于 2022-02-11 19:45:21">2022-02-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-24T12:18:07.604Z" title="更新于 2022-07-24 20:18:07">2022-07-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%AD%A6/">计算机科学，计算机图学</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="NURBS曲线（待整理）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="center-引子-center-5"><center>引子</center></h2>
<p>    👋这里是Visen.平时需要和CAGD（计算机辅助几何设计）打交道，这里参考施法中<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.123pan.com/s/nmk9-vl88H">《计算机辅助几何设计与非均匀有理B样条 修订版》</a>和<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.123pan.com/s/nmk9-vl88H">配套书籍光盘</a>，整理出NURBS曲线编程所需基础知识点和C++编程实例，只为对知识快速上手，而且能理清书籍的脉络，剔除曲面部分。整理不是为了丢掉书，而是为了更好地利用书！</p>
<hr>
<h2 id="第一章-曲线和曲面的基本理论">第一章 曲线和曲面的基本理论</h2>
<h3 id="1-直线的表示方法">1.直线的表示方法</h3>
<p>动点p是随着某个参数u在规范参数域$u\in[0，1]$内按线性关系运动，则动点p把来直线分为长度比为u:1-u两段</p>
<p>有 $p=p(u) ,u\in [0,1]$</p>
<p>则有$p-p_{0}=\frac{u}{1-u}(p_{1}-p)$，$p-p_{0}=u(p_1-p_0)$</p>
<p>整理可得$p(u)=p_{0}+u(p_{1}-p_{0})$，分析时偏向使用$p(u)=(1-u)p_{0}+up_{1}$</p>
<h3 id="2-曲线的表示方法">2.曲线的表示方法</h3>
<p>空间解析几何（参数表示）：动点p的3个坐标$x=x(u),y=y(u),z=z(u)$</p>
<p>微分几何（一般矢函数表示）：$p(u)=[x(u),y(u),z(u)]$=&gt;$p(u)=x(u)i+y(u)j+z(u)k$(i,j,k为三个方向的3个单位矢量)</p>
<p>计算机辅助几何设计（基表示）：$p(u)=\sum_{i=0}^{n}\varphi <em>{i}(u) a</em>{i}$，直线表示方法$p(u)=(1-u)p_{0}+up_{1}$算是它的一个最简单的基表示形式</p>
<p>tips：如果把参数u设置为时间，则p(u)为一质点随时间变化的运动轨迹，一阶导矢和二阶导矢分别代表速度和加速度矢量</p>
<p>参数连续性：函数曲线具有直到k阶的连续导数，称为是k次可微的，或简称是C^k^的。类似地，参数曲线具有关于参数的直到k阶的连续导矢，也称为是k次可微的，或简称是C^k^的。由于参数曲线的这种可微性与参数有关，故又称之为参数连续性</p>
<h3 id="3-参数化与参数变换">3.参数化与参数变换</h3>
<p>参数化的意义在于将u=u(t)，代入到式子中，使得p(u)变成p(t)，但是不合适的参数变换，可能会出现$\frac{du}{dt} =0$或者某个原函数对应多个新参数</p>
<p>比如弧长参数化，取自身弧长为参数（但是n次参数多项式曲线不能使用），需要选择合适的参数变换</p>
<hr>
<h2 id="第二章-参数多项式插值与逼近">第二章 参数多项式插值与逼近</h2>
<p>构造曲线顺序过给定的数据点称为插值，构造曲线在某种意义上最为接近给定的数据点称为逼近，两者统称为拟合</p>
<h3 id="1-基函数">1.基函数</h3>
<p>前一章知道计算机辅助几何设计中采用的是基表示的参数矢函数形式，而需要选择哪一类函数作为基函数？</p>
<p>这里只介绍多项式基：无穷次可微，曲线曲面足够光滑，且容易计算函数值及各阶导数值[$p(u)=\sum_{i=0}^{n} a_{i}u^i$]</p>
<p>后续还有有理基函数…</p>
<h3 id="2-数据点的参数化">2.数据点的参数化</h3>
<p>节点决定了位于曲线上的这些数据点与其参数域$u\in[u_{0}，u_{n}]$内的相应点之间的一种对应关系，而对一组有序数据点决定一个参数分割，称之为对这组数据点实现参数化。同一组数据点，即使采用同样的插值法，若数据点的参数化不同，将可能获得不同的插值曲线，会呈现出不同的性质。</p>
<ul>
<li>均匀参数化（等距参数化）</li>
<li>积累弦长参数化(<strong>文献显示，该方法完全适合于工程应用</strong>)</li>
<li>向心参数化</li>
<li>福利参数化（修正弦长参数化）</li>
</ul>
<p>编程实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">功能：对数据点实现参数化</span><br><span class="line">输入参数：m_aVertex-数据点; m_pType-参数化类型，由数据点参数化对话框输入；两者均为受保护成员。</span><br><span class="line">输出参数：m_aU-数据点参数值数组，受保护成员。</span><br><span class="line">调用函数：<span class="built_in">Normalize</span>()-对参数化序列实行规范化；Distance-求两点间距离；InitK-确定福利参数化的修正系数m_k；InitSita-计算弦线夹角的外角。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitU</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_aU.<span class="built_in">GetSize</span>()&gt;<span class="number">0</span>) m_aU.<span class="built_in">RemoveAll</span>();</span><br><span class="line">	<span class="type">int</span> i,n;</span><br><span class="line">	n=m_aVertex.<span class="built_in">GetSize</span>();</span><br><span class="line">	m_aU.<span class="built_in">Add</span>(<span class="number">0.0</span>);</span><br><span class="line">	<span class="keyword">switch</span>(m_pType)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//规范均匀参数化</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++) 	m_aU.<span class="built_in">Add</span>(i);</span><br><span class="line">		<span class="built_in">Normalize</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//规范弦长参数化</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">double</span> temp;</span><br><span class="line">			temp=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]);</span><br><span class="line">			temp+=m_aU[i<span class="number">-1</span>];</span><br><span class="line">			m_aU.<span class="built_in">Add</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Normalize</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//规范向心参数化</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">double</span> temp;</span><br><span class="line">			temp=<span class="built_in">sqrt</span>(<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]));</span><br><span class="line">			temp+=m_aU[i<span class="number">-1</span>];</span><br><span class="line">			m_aU.<span class="built_in">Add</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Normalize</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//规范福利参数化</span></span><br><span class="line">		<span class="built_in">InitK</span>();</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">double</span> temp;</span><br><span class="line">			temp=m_k[i]*<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]);</span><br><span class="line">			temp+=m_aU[i<span class="number">-1</span>];</span><br><span class="line">			m_aU.<span class="built_in">Add</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Normalize</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Normalize</span><span class="params">()</span>  <span class="comment">//规范化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">GetVertexCount</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) m_aU[i]=m_aU[i]/m_aU[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitK</span><span class="params">()</span>  <span class="comment">//初始化修正系数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_k.<span class="built_in">GetSize</span>()&gt;<span class="number">0</span>) m_k.<span class="built_in">RemoveAll</span>();</span><br><span class="line">	<span class="type">double</span> tempk,temp1,temp2,temp3;</span><br><span class="line">	<span class="built_in">InitSita</span>();</span><br><span class="line">	m_k.<span class="built_in">Add</span>(<span class="number">0.0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">GetVertexCount</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>)  temp1=<span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">else</span> temp1=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-2</span>],m_aVertex[i<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="built_in">GetVertexCount</span>()<span class="number">-1</span>)  temp3=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> temp3=<span class="built_in">Distance</span>(m_aVertex[i],m_aVertex[i+<span class="number">1</span>]);</span><br><span class="line">		temp2=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]);</span><br><span class="line">		tempk=<span class="number">1</span>+<span class="number">1.5</span>*((temp1*m_sita[i<span class="number">-1</span>])/(temp1+temp2)+</span><br><span class="line">(temp3*m_sita[i])/(temp2+temp3));</span><br><span class="line">		m_k.<span class="built_in">Add</span>(tempk);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSita</span><span class="params">()</span>  <span class="comment">//计算弦线夹角的外角</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_sita.<span class="built_in">GetSize</span>()&gt;<span class="number">0</span>) m_sita.<span class="built_in">RemoveAll</span>();</span><br><span class="line">	<span class="type">double</span> temp,temp1,temp2,temp3;</span><br><span class="line">	m_sita.<span class="built_in">Add</span>(<span class="number">0.0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">GetVertexCount</span>()<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;		</span><br><span class="line">		temp1=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]);</span><br><span class="line">		temp2=<span class="built_in">Distance</span>(m_aVertex[i],m_aVertex[i+<span class="number">1</span>]);</span><br><span class="line">		temp3=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i+<span class="number">1</span>]);		</span><br><span class="line">		temp=<span class="built_in">acos</span>((temp1*temp1+temp2*temp2-temp3*temp3)/</span><br><span class="line">			(<span class="number">2.0</span>*temp1*temp2));</span><br><span class="line">		<span class="keyword">if</span>((PI-temp)&lt;(PI/<span class="number">2.0</span>))  m_sita.<span class="built_in">Add</span>(PI-temp);</span><br><span class="line">		<span class="keyword">else</span>  m_sita.<span class="built_in">Add</span>(PI/<span class="number">2.0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	m_sita.<span class="built_in">Add</span>(<span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述各种对数据点的参数化法都是非规范的，即$[u_{0}，u_{n}]$不等于[0,1]仅$u_{0}=0$。首先需要进行规范参数化使得$[u_{0}，u_{n}]=[0,1]$</p>
<p>只需要简单处理$ u_{i}=u_{i}/u_{n} $，这样构造的形状相同，取向相同，且点的分布与参数域内点的分布的对应关系都是相同的</p>
<p>当定义曲线的点不是曲线上的数据点，而是控制顶点时，将遇到另一类参数化问题，后续介绍…</p>
<h3 id="3-多项式插值曲线">3.多项式插值曲线</h3>
<p>这里讲解多项式基中，如何对插值曲线方程进行求解</p>
<p>插值曲线方程：$p(u)=\sum_{j=0}^{n} =<br>
\begin{bmatrix}<br>
1  &amp; u &amp; … &amp; u^n<br>
\end{bmatrix}<br>
\begin{bmatrix}<br>
a_0 \<br>
a_1\<br>
… \<br>
a_n\<br>
\end{bmatrix}$</p>
<p><strong>解法一：</strong></p>
<p>根据$p(u)=\sum_{j=0}^{n} a_{j}u_i^j=p_i=\begin{bmatrix}<br>
1  &amp; u_i &amp; … &amp; u_i^n<br>
\end{bmatrix}<br>
\begin{bmatrix}<br>
a_0 \<br>
a_1\<br>
… \<br>
a_n\<br>
\end{bmatrix}$，可以得到矩阵运算</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044176.png" alt="image-20220205102645380"></p>
<p>前面是范德蒙矩阵，非奇异，存在唯一解</p>
<p><strong>解法二：</strong></p>
<p>将$p(u)=\sum_{j=0}^{n} a_{j}u_i^j$改写为嵌套乘法的格式：$p(u)=a_0+u(a_1+…+u(a_{n-1}+u(a_n)))$</p>
<p>为了能同时计算曲线任一处的各阶导矢，可改用如下计算n阶曲线各阶导矢的通用公式</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044452.png" alt="image-20220205103228228"></p>
<h3 id="4-最小二乘逼近">4.最小二乘逼近</h3>
<p>如果使用$p(u_k)=\sum_{i=0}^{n}\varphi <em>{i}(u_k) a</em>{i}=p_k$</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044756.png" alt="image-20220205191556813"></p>
<p>方程组是超定的/矛盾方程组，解不存在，只能使用逼近，可以使得曲线点和数据点的距离平方和达到最小，称为最小二乘法逼近</p>
<hr>
<h2 id="第三章-参数样条曲线曲面">第三章 参数样条曲线曲面</h2>
<p>这里主要记录参数三次样条曲线</p>
<h3 id="1-参数连续性">1.参数连续性</h3>
<p>光滑程度可以对其变量的可微性来度量，一函数y=y(x)在某一点$x_0$处具有相等的直到k阶的左右导数，则称它在$x_0$处是k次连续可微的，或称它在$x_0$处是k阶连续，记作$C^k$。</p>
<h3 id="2-三切矢方程">2.三切矢方程</h3>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044548.png" alt="image-20220205193327878"></p>
<h3 id="3-边界条件">3.边界条件</h3>
<p>对于开曲线及首末端虽封闭但不要求整体$C^2$的情况，必须再给出两个附加方程，才有可能唯一定解，这两个附加方程通常由两端点处的约束条件提供，称为边界条件或端点条件</p>
<p>边界条件类型：</p>
<ul>
<li>切矢条件：首末端切矢</li>
<li>自由端点条件：在端点不受力矩作用</li>
<li>虚节点条件</li>
<li>抛物线条件：首末段为抛物线，即各具有常矢量的二阶导矢</li>
<li>“非节点”条件：使首末各两段分别为同一参数三次多项式</li>
</ul>
<h3 id="4-定义的参数三次样条曲线">4.定义的参数三次样条曲线</h3>
<p>联立三切矢方程与边界条件所确立的两个附加方程，就可以得到含n+1个未知切矢的由n+1个矢量方程组成的线性方程组，写出矩阵形式为</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044066.png" alt="image-20220205193542701"></p>
<p>其系数矩阵为标准的三对角方阵，因主对角元素占优，该系数矩阵是非奇异的，存在唯一解。这种标准的三对角度方程组可采用所谓“追赶法”的高斯消元法求解。</p>
<p>具体过程是先自上而下把下对角元素消为零，称为追，然后求出$\vec{p_n} $，再回代求出其余全部未知切矢，即所谓“赶”。</p>
<p>编程实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">功能：求解参数三次样条曲线在数据点（即分段连接点）处未知切矢的三对角线性方程组。</span><br><span class="line">输入参数：dia-存三对角系数矩阵的三对角元素，其中第二维<span class="number">0</span>、１ 、２依次为一行中下对角、主对角和上对角元素：n-矩阵有从第０行到第n行共n+<span class="number">1</span>行；k-维数；t-线性方程组右端列阵中n+<span class="number">1</span>个k维矢量；iflag-选择码，当多次调用本子程序时，若系数矩阵保持不变，则输入iflag一个非零整数，否则输入整数零。</span><br><span class="line">输出参数：t-n+<span class="number">1</span>个数据点处的切矢。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tridia</span><span class="params">(<span class="type">int</span> n,intk,</span></span></span><br><span class="line"><span class="params"><span class="function">	    CArray&lt;CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;,CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&amp;&gt;&amp;dia，</span></span></span><br><span class="line"><span class="params"><span class="function">	    CArray&lt;CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;,CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&amp;&gt;&amp;t,</span></span></span><br><span class="line"><span class="params"><span class="function">	    <span class="type">int</span> iflag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(iflag==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				dia[i][<span class="number">0</span>]=-(dia[i][<span class="number">0</span>]/dia[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">				dia[i][<span class="number">1</span>]=dia[i][<span class="number">1</span>]+dia[i<span class="number">-1</span>][<span class="number">2</span>]*dia[i][<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> lk=<span class="number">0</span>;lk&lt;k;lk++)</span><br><span class="line">					t[i][lk]=t[i][lk]+t[i<span class="number">-1</span>][lk]*dia[i][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> lk=<span class="number">0</span>;lk&lt;k;lk++)</span><br><span class="line">				t[n][lk]=t[n][lk]/dia[n][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">				<span class="keyword">for</span>(lk=<span class="number">0</span>;lk&lt;k;lk++)</span><br><span class="line">					t[i][lk]=(t[i][lk]-dia[i][<span class="number">2</span>]*t[i+<span class="number">1</span>][lk])/dia[i][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-计算插值">5.计算插值</h3>
<p>这里介绍曲线所要求解的曲线上各种信息的计算：给定已经定义的参数三次样条曲线，计算曲线上各点及其各阶段导矢</p>
<h4 id="判断参数所在的节点区间">判断参数所在的节点区间</h4>
<p>$u_i\le u\le u_i+1$，即确定区间指标i（曲线的段指标/第几段），取该节点区间左端节点的下标</p>
<h4 id="选用相应的曲线段表达式">选用相应的曲线段表达式</h4>
<p>先将曲线变成分段格式：</p>
<p>首先得确定参数三次样条曲线的类型</p>
<p>基表示形式有埃尔米特形式、幂基形式、基样条形式、B样条形式</p>
<p>参数化方法有均匀参数化、积累弦长参数化、向心参数化、修正弦长参数化</p>
<p>（这里介绍的是$C^1$分段三次埃尔米特插值）</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044972.png" alt="image-20220209105129174"></p>
<p>然而实际问题只给出数据点，比较少给出数据点处得切矢，这时候要求构造一条$C^1$分段三次多项式曲线插值于这些数据点</p>
<p>可以采用以下方法确定数据点处的切矢</p>
<img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044908.png" alt="image-20220209105701342" style="zoom:110%;" />
<p>为了实际编程节省计算量，需要将式（4.1）改写形式</p>
<img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045155.png" alt="image-20220209111034067"  />
<h4 id="程序实例">程序实例</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">功能：计算参数三次样条曲线段上一点处j 阶导矢，若j=<span class="number">0</span>，即为曲线上点。</span><br><span class="line">输入参数：m_aVertex-数据点，受保护成员；i-曲线段所在节点区间左端点下标；u-曲线参数；j-导矢的阶数（若求点，则输入j =<span class="number">0</span>）。</span><br><span class="line">输出参数：p-j阶导矢。若j=<span class="number">0</span>，则为曲线上的点。</span><br><span class="line">调用函数：GetCubicCuvValue -由（<span class="number">4.8</span>）式计算导矢值。</span><br><span class="line">注：该函数不能计算内节点处的左导矢。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">GetSplineDerivat</span>(<span class="type">int</span> i,<span class="type">double</span> u,<span class="type">int</span> j, CPoint &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=m_aVertex.<span class="built_in">GetSize</span>();</span><br><span class="line">	<span class="type">double</span> u1=u;</span><br><span class="line">	CDoubleArray tx;</span><br><span class="line">	CDoubleArray ty;</span><br><span class="line">	tx.<span class="built_in">SetSize</span>(<span class="number">4</span>);</span><br><span class="line">	ty.<span class="built_in">SetSize</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="comment">/*以下8行语句计算（4.7）式左端列阵四个系数矢量*/</span>	</span><br><span class="line">	tx[<span class="number">0</span>]=m_aVertex[i].x;</span><br><span class="line">	tx[<span class="number">1</span>]=m_Cx[i];</span><br><span class="line">	ty[<span class="number">0</span>]=m_aVertex[i].y;</span><br><span class="line">	ty[<span class="number">1</span>]=m_Cy[i];	</span><br><span class="line">	tx[<span class="number">2</span>]=<span class="number">2</span>/delta[i]*(<span class="number">3</span>/delta[i]*(m_aVertex[i+<span class="number">1</span>].x-tx[<span class="number">0</span>])<span class="number">-2</span>*tx[<span class="number">1</span>]-m_Cx[i+<span class="number">1</span>]);</span><br><span class="line">	ty[<span class="number">2</span>]=<span class="number">2</span>/delta[i]*(<span class="number">3</span>/delta[i]*(m_aVertex[i+<span class="number">1</span>].y-ty[<span class="number">0</span>])<span class="number">-2</span>*ty[<span class="number">1</span>]-m_Cy[i+<span class="number">1</span>]);</span><br><span class="line">	tx[<span class="number">3</span>]=<span class="number">6</span>/delta[i]/delta[i]*(<span class="number">-2</span>/delta[i]*(m_aVertex[i+<span class="number">1</span>].x-tx[<span class="number">0</span>])+tx[<span class="number">1</span>]+m_Cx[i+<span class="number">1</span>]);</span><br><span class="line">	ty[<span class="number">3</span>]=<span class="number">6</span>/delta[i]/delta[i]*(<span class="number">-2</span>/delta[i]*(m_aVertex[i+<span class="number">1</span>].y-ty[<span class="number">0</span>])+ty[<span class="number">1</span>]+m_Cy[i+<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">GetCubicCuvValue</span> (i,tx,ty,u1,j,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetCubicCuvValue</span><span class="params">(<span class="type">int</span> i,CDoubleArray &amp;tx, CDoubleArray &amp;ty, <span class="type">double</span> u,</span></span></span><br><span class="line"><span class="params"><span class="function"> 		      <span class="type">int</span> j, CPoint &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="type">double</span> pjx=<span class="number">0</span>,pjy=<span class="number">0</span>;	</span><br><span class="line">	<span class="type">double</span> du=u-m_aU[i];</span><br><span class="line">	nt fj=<span class="number">4</span>-j;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">3</span>;k&gt;=j;k--)</span><br><span class="line">	&#123;</span><br><span class="line">		pjx=(pjx/fj)*du+tx[k];</span><br><span class="line">		pjy=(pjy/fj)*du+ty[k];</span><br><span class="line">		fj=fj<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p.x=(<span class="type">int</span>)pjx;</span><br><span class="line">	p.y=(<span class="type">int</span>)pjy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-光顺性（光滑顺眼）">6.光顺性（光滑顺眼）</h3>
<p>判断准则：二阶几何连续（位置、切线方向与曲率矢连续，记$G^2$）、不存在奇点与多余拐点、曲率变化较小、应变能较小</p>
<p>如何处理光顺性：见书本</p>
<hr>
<h2 id="第四章-贝齐尔bezier曲线">第四章 贝齐尔bezier曲线</h2>
<p>贝齐尔曲线是参数多项式曲线，不同的是它采用了不同的一组独特的多项式基函数，使得它有了很多优良的性质。NURBS曲线就是从B样条曲线继承而来，而B样条是从贝齐尔曲线继承而来。</p>
<h3 id="1-贝齐尔曲线方程及其性质">1.贝齐尔曲线方程及其性质</h3>
<p>定义式：</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045848.png" alt="image-20220209133039537"></p>
<p>贝齐尔曲线的定义基础是抛物线的<strong>三切线定理</strong></p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045529.png" alt="image-20220209133338016"></p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045516.png" alt="image-20220210103322513"></p>
<p>于是，可以通过德卡斯特里奥递推算法来推算出控制顶点，这一算法重要特点就是几何直观，甚至可以通过简单的几何作图实现</p>
<p><img src="https://s2.loli.net/2022/02/09/Lt3wERqsVF4WJia.png" alt="image-20220209133824132"></p>
<h3 id="2-贝齐尔曲线导矢">2.贝齐尔曲线导矢</h3>
<p>一阶导矢可以按照</p>
<h4 id="公式计算">公式计算</h4>
<img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045003.png" alt="image-20220210103621221" style="zoom:150%;" />
<h4 id="编程实例">编程实例</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">功能：deCasteliau算法计算n次贝齐尔曲线<span class="built_in">p</span>(t)参数为t那点处的jd阶导矢pt，若jd=<span class="number">0</span>,pt=<span class="built_in">p</span>(t)。</span><br><span class="line">输入参数： n-顶点数减<span class="number">1</span>即次数；m_aVertex-控制顶点，为受保护成员；t-参数值；jd-导矢阶数(若求曲线上的点，输入jd＝０)。</span><br><span class="line">输出参数：pt-曲线上参数为t的点(当jd＝<span class="number">0</span>)或jd阶导矢(当jd≥１)。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">GetBezierCuvDerivat</span>(<span class="type">int</span> n,<span class="type">int</span> jd,<span class="type">double</span> t,CPoint &amp;pt)</span><br><span class="line">&#123;</span><br><span class="line">	CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; TemVertex_x;</span><br><span class="line">	CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; TemVertex_y;</span><br><span class="line">	TemVertex_x.<span class="built_in">SetSize</span>(n+<span class="number">1</span>);</span><br><span class="line">	TemVertex_y.<span class="built_in">SetSize</span>(n+<span class="number">1</span>);</span><br><span class="line">	pt.x=<span class="number">0</span>;</span><br><span class="line">	pt.y=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(jd&gt;n) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;=<span class="number">0</span>&amp;&amp;jd&lt;=n)</span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i0=<span class="number">0</span>;i0&lt;=n;i0++)</span><br><span class="line">		&#123;</span><br><span class="line">			TemVertex_x[i0]=m_aVertex[i0].x;</span><br><span class="line">			TemVertex_y[i0]=m_aVertex[i0].y;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">1</span>;i1&lt;=n-jd;i1++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i1;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				TemVertex_x[j]=TemVertex_x[j]+t*(TemVertex_x[j+<span class="number">1</span>]-TemVertex_x [j]; </span><br><span class="line">				TemVertex_y[j]=TemVertex_y[j]+t*(TemVertex_y[j+<span class="number">1</span>]-TemVertex_y[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> njd=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(jd!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> ll=<span class="number">1</span>;ll&lt;=jd;ll++)</span><br><span class="line">		&#123;</span><br><span class="line">			njd=njd*(n-ll+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=jd-ll;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				TemVertex_x[j]=TemVertex_x[j+<span class="number">1</span>]-TemVertex_x[j];</span><br><span class="line">				TemVertex_y[j]=TemVertex_y[j+<span class="number">1</span>]-TemVertex_y[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pt.x=<span class="built_in">int</span>(njd*TemVertex_x[<span class="number">0</span>]);</span><br><span class="line">	pt.y=<span class="built_in">int</span>(njd*TemVertex_y[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-贝齐尔曲线的升阶与降阶">3.贝齐尔曲线的升阶与降阶</h3>
<p>这里说n次贝齐尔曲线，其次数n是指曲线在伯恩斯坦基表示中的伯恩斯坦基函数的最高次数，它也等于最后那个控制顶点的下标值。人们称该次数为名义次数。</p>
<p>​	相对而言，贝齐尔曲线还有<strong>真实次数</strong>。将贝齐尔曲线的伯恩斯坦基表示转换成幂基表示，则按幂次升序排列，加权于最后那个非零系数矢量的那个具有最高次数的单项式函数的次数就是该贝齐尔曲线的真实次数。名义次数可能等于或高于真实次数。</p>
<p>​	保持贝齐尔曲线的形状与定向不变，增加定义它的控制顶点数，也即增加它的名义次数，那么，怎样从原控制顶点求出新控制顶点，就是贝齐尔曲线的升阶问题</p>
<h4 id="升阶">升阶</h4>
<p>升阶能降低刚性，增加柔性，增加控制顶点，就增加了对曲线进行形状控制的潜在灵活性。虽然增加了控制顶点个数，但是曲线形状及定向保持不变，所以曲线的真实次数不变</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045804.png" alt="image-20220211161922403"></p>
<h4 id="降阶（略）">降阶（略）</h4>
<h3 id="4-贝齐尔曲线的矩阵形式">4.贝齐尔曲线的矩阵形式</h3>
<p>从这里可以知道NURBS曲线的矩阵表示形式以及运算方法</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045739.png" alt="image-20220211162920640"></p>
<h2 id="第五章-B样条曲线曲面的基本理论">第五章 B样条曲线曲面的基本理论</h2>
<h3 id="1-B样条与B样条曲线的基本概念">1.B样条与B样条曲线的基本概念</h3>
<p>B样条方法是在保留贝齐尔方法的优点的同时，克服了其由于整体表示带来不具有局部性质的缺点，以及解决在描述复杂形状时带来的连接问题下提出来的。为了保留贝齐尔方法的优点，仍采用控制顶点定义曲线。为了能描述复杂形状和具有局部性质，改用另一套特殊的基函数即B样条基函数</p>
<p>于是，B样条曲线方程可写为</p>
<img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045688.png" alt="image-20220211170829844" style="zoom:120%;" />
<h3 id="2-B样条的递推定义及其性质">2.B样条的递推定义及其性质</h3>
<p>这里只介绍作为标准算法的德布尔-考克斯的递推定义公式</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046322.png" alt="image-20220212104917129"></p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046404.png" alt="image-20220212104949959"></p>
<p>如何使用可以看书</p>
<img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046372.png" alt="image-20220212112247397" style="zoom:150%;" />
<h4 id="编程实例-2">编程实例</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//功能: 根据参数u值和次数k与节点矢量，计算第i个k次B样条基函数。</span></span><br><span class="line"><span class="comment">//输入参数: u-参数值；k-次数；i-第i个k次B样条的支承区间左端节点下标；m_aNode-节点矢量双精度数组，受保护成员。</span></span><br><span class="line"><span class="comment">//输出参数: 返回函数值。</span></span><br><span class="line"><span class="comment">//调用函数: 递归调用自身。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">GetBaseFunVal</span><span class="params">(<span class="type">double</span> u,<span class="type">int</span> i,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> Val=<span class="number">0.0</span>;</span><br><span class="line">	<span class="type">double</span> val1=<span class="number">0.</span>;</span><br><span class="line">	<span class="type">double</span> val2=<span class="number">0.</span>;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(u&lt;m_aNode[i]||u&gt;m_aNode[i+<span class="number">1</span>]) <span class="keyword">return</span> Val;		</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Val=<span class="number">1.0</span>;</span><br><span class="line">			<span class="keyword">return</span> Val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(u&lt;m_aNode[i]||u&gt;m_aNode[i+k+<span class="number">1</span>]) <span class="keyword">return</span> Val;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">double</span> alpha=<span class="number">0.0</span>;</span><br><span class="line">			<span class="type">double</span> beta=<span class="number">0.0</span>; </span><br><span class="line">			<span class="type">double</span> dTemp=<span class="number">0.0</span>;</span><br><span class="line">			dTemp=m_aNode[i+k]-m_aNode[i];</span><br><span class="line">			<span class="keyword">if</span>(dTemp==<span class="number">0.</span>) alpha=<span class="number">0.</span>;</span><br><span class="line">			<span class="keyword">else</span> alpha=(u-m_aNode[i])/dTemp;</span><br><span class="line">			dTemp=m_aNode[i+k+<span class="number">1</span>]-m_aNode[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (dTemp==<span class="number">0.</span>) beta=<span class="number">0.</span>; </span><br><span class="line">			<span class="keyword">else</span> beta=(m_aNode[i+k+<span class="number">1</span>]-u)/dTemp;  </span><br><span class="line">			val1=alpha*<span class="built_in">GetBaseFunVal</span>(u,i,k<span class="number">-1</span>);</span><br><span class="line">			val2=beta*<span class="built_in">GetBaseFunVal</span>(u,i+<span class="number">1</span>,k<span class="number">-1</span>);</span><br><span class="line">			Val=val1+val2;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-B样条的局部性质">3.B样条的局部性质</h3>
<p>k次B样条曲线上一点p(u),u在[$u_i,u_{i+1}$]至多与k+1个控制顶点$d_j(j为i-k到i)$有关，与其他控制顶点无关；移动该曲线的第i个控制顶点$d_i$至多将影响到定义在第i个k次B样条的开支承区间($u_i，u_{i+k+1}$)上那部分曲线的形状，对曲线的其余部分不发生影响</p>
<p>根据这个性质，当定义一个曲线，节点矢量U=[$u_0,u_1,···,u_{n+k+1}$]，则曲线定义域为$u_3$到$u_9$，不含重节点的话，曲线段数为n-k-1</p>
<p>一些其他性质，可以看书</p>
<h3 id="4-非均匀B样条曲线">4.非均匀B样条曲线</h3>
<h4 id="节点矢量的确定">节点矢量的确定</h4>
<p>与其他类型的B样条曲线不同的是，给定控制顶点后，还需要确定它的节点矢量中具体的节点值</p>
<p>对于开曲线包括首末端点仅位置连续的闭曲线，都建议两端节点<strong>取重复度k+1</strong>,且通常地将曲线的定义域取成规范参数域u∈[$u_k,u_{n+1}$]=[0,1]，于是$u_0=u_1=···=u_k=0，u_{n+1}=u_{n+2}=···=u_{n+k+1}=1$，剩下的就是确定$u_{k+1},u_{k+2},···,u_n$那些内节点，共n-k个</p>
<h4 id="B样条基及其导数计算">B样条基及其导数计算</h4>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046872.png" alt="image-20220212131637515"></p>
<h4 id="计算B样条曲线上的点（德布尔算法）">计算B样条曲线上的点（德布尔算法）</h4>
<p>给点控制顶点$d_i$、次数k及确定节点矢量U后，就定义了一条k次B样条曲线。如果给出曲线定义域内的某个参数值u=$[u_i,u_{n+1}]$，想计算该B样条曲线上对应一点p(u)</p>
<p><img src="https://s2.loli.net/2022/02/12/M75kVX2AltxnS83.png" alt="image-20220212132209559"></p>
<h4 id="计算B样条曲线的导矢（德布尔算法）">计算B样条曲线的导矢（德布尔算法）</h4>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046041.png" alt="image-20220212132339534"></p>
<p>程序实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">功能：用德布尔算法求kk次平面B样条曲线上参数为u点处的r阶导矢(px,py)。</span><br><span class="line">输入参数：kk-次数；u-参数；r-导矢阶数：</span><br><span class="line">          (m_xAVertex,m_yAVertex)-控制顶点，m_aNode-节点矢量为受保护成员；m_KnotMark-节点值导矢选择码,公有成员。</span><br><span class="line">输出参数：曲线上参数为u点处的r阶导矢(px,py)，若r=<span class="number">0</span>，表示曲线上点<span class="built_in">p</span>(u)；</span><br><span class="line">          当u为内节点值,r&gt;<span class="number">0</span>时,m_KnotMark=<span class="number">0</span>与<span class="number">1</span>分别输出右导矢与左导矢。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">GetBPr</span>(<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">double</span> u,<span class="type">double</span> &amp;px,<span class="type">double</span> &amp;py)</span><br><span class="line">&#123;</span><br><span class="line">	CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; tempx,tempy;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;k) &#123;px=<span class="number">0</span>;  py=<span class="number">0</span>;  <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=m_aNode.<span class="built_in">GetSize</span>()-k<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(u&gt;=m_aNode[i]) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u&lt;m_aNode[k]) i=k;</span><br><span class="line">	<span class="keyword">if</span>((k==<span class="number">1</span>&amp;&amp;r==<span class="number">1</span>)&amp;&amp;(u!=m_aNode[i]||(u==m_aNode[i]&amp;&amp;m_KnotMark==<span class="number">0</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		px=(m_xAVertex[i]-m_xAVertex[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]);</span><br><span class="line">		py=(m_yAVertex[i]-m_yAVertex[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;r==<span class="number">1</span>&amp;&amp;m_KnotMark==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		px=(m_xAVertex[i<span class="number">-1</span>]-m_xAVertex[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]);</span><br><span class="line">		py=(m_yAVertex[i<span class="number">-1</span>]-m_yAVertex[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;k&amp;&amp;i&lt;=m_xAVertex.<span class="built_in">GetSize</span>()<span class="number">-1</span>)    <span class="comment">//限于计算内节点的重复度Multiple</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> Multiple=<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> ii=i;</span><br><span class="line">		<span class="keyword">while</span>(u==m_aNode[ii<span class="number">-1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Multiple++;</span><br><span class="line">			ii--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;<span class="number">1</span>&amp;&amp;m_KnotMark==<span class="number">1</span>&amp;&amp;u==m_aNode[i]&amp;&amp;i!=k) i=i-Multiple;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((k==<span class="number">1</span>&amp;&amp;r==<span class="number">0</span>)||k&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i-k;j&lt;=i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tempx.<span class="built_in">Add</span>(m_xAVertex[j]);</span><br><span class="line">			tempy.<span class="built_in">Add</span>(m_yAVertex[j]);</span><br><span class="line">			<span class="type">double</span> x=m_xAVertex[j],  y=m_yAVertex[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=r;l++)  <span class="comment">//教材(7.7)式第一式的r级递推</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=i-k;j&lt;=i-l;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">double</span> beta=(k-l+<span class="number">1</span>)/(m_aNode[j+k+<span class="number">1</span>]-m_aNode[j+l]);</span><br><span class="line">				<span class="type">int</span> jj=j-(i-k);</span><br><span class="line">				tempx[jj]=beta*(tempx[jj+<span class="number">1</span>]-tempx[jj]);</span><br><span class="line">				tempy[jj]=beta*(tempy[jj+<span class="number">1</span>]-tempy[jj]);</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//德布尔算法</span></span><br><span class="line">		<span class="keyword">for</span>(l=<span class="number">1</span>;l&lt;=k-r;l++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=i-k;j&lt;=i-l-r;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">double</span> alpha,du=m_aNode[j+k+<span class="number">1</span>]-m_aNode[j+r+l];</span><br><span class="line">				<span class="keyword">if</span>(du==<span class="number">0.0</span>) alpha=<span class="number">0.0</span>;</span><br><span class="line">				<span class="keyword">else</span> alpha=(u-m_aNode[j+r+l])/du;</span><br><span class="line">				tempx[j-i+k]=(<span class="number">1</span>-alpha)*tempx[j-i+k]+alpha*tempx[j-i+k+<span class="number">1</span>];</span><br><span class="line">				tempy[j-i+k]=(<span class="number">1</span>-alpha)*tempy[j-i+k]+alpha*tempy[j-i+k+<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		px=tempx[<span class="number">0</span>];</span><br><span class="line">		py=tempy[<span class="number">0</span>];</span><br><span class="line">		tempx.<span class="built_in">RemoveAll</span>();</span><br><span class="line">		tempy.<span class="built_in">RemoveAll</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第六章-B样条方法的基本几何算法（略）">第六章  B样条方法的基本几何算法（略）</h2>
<p>插入节点</p>
<p>节点细化</p>
<p>曲线分割</p>
<p>节点消去</p>
<p>升阶和降阶</p>
<h2 id="第七章-B样条曲线拟合（重点）">第七章 B样条曲线拟合（重点）</h2>
<p>计算已定义的B样条曲线上的点与各阶导矢称为正算过程，而日常主要遇到的是从给定数据点来确定节点矢量与控制顶点的反算问题，即反算三次B样条插值曲线的控制顶点</p>
<h3 id="曲线次数k">曲线次数k</h3>
<p>由于高次插值开曲线将带来更多的难以给出的边界条件等问题及实际工程问题需要，实践中广泛采用$C^2$连续的三次B样条曲线</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046160.png" alt="image-20220212134059833"></p>
<h3 id="节点矢量">节点矢量</h3>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046846.png" alt="image-20220212134212220"></p>
<h3 id="反算控制顶点">反算控制顶点</h3>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046057.png" alt="image-20220212134343699"></p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046002.png" alt="image-20220212134401238"></p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046675.png" alt="image-20220212134420435"></p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047525.png" alt="image-20220212134446385"></p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047354.png" alt="image-20220212134502087"></p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047998.png" alt="image-20220212134530968"></p>
<p><img src="https://s2.loli.net/2022/02/12/vEGklpnCIgTd25F.png" alt="image-20220212134600711"></p>
<h3 id="编程实例-3">编程实例</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">功能：反算三次B样条插值开曲线控制顶点。</span><br><span class="line">输入参数：(m_xDVertex,m_yDVertex[i])-为受保护成员,i=<span class="number">0</span>,<span class="number">1</span>,...,n<span class="number">-2</span>存数据点,i=n<span class="number">-1</span>存首端显示切矢矢端,i=n存末端显示切矢矢端。m_eType0,m_eType1-首末边界条件标识码。</span><br><span class="line">输出参数：(m_xAVertex,m_yAVertex)-控制顶点，为受保护成员。</span><br><span class="line">调用函数：InitEdge-置首末边界条件系数与右端矢量；delta-节点值向前差分。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">BTridia</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n= m_xDVertex.<span class="built_in">GetSize</span>()<span class="number">-1</span>; </span><br><span class="line">	<span class="type">int</span> k=<span class="number">2</span>;</span><br><span class="line">	m_xAVertex.<span class="built_in">SetSize</span>(n+<span class="number">1</span>), m_yAVertex.<span class="built_in">SetSize</span>(n+<span class="number">1</span>);     <span class="comment">//i=0,1,...,n存控制顶点</span></span><br><span class="line">	m_xAVertex[<span class="number">0</span>]=m_xDVertex[<span class="number">0</span>];</span><br><span class="line">	m_yAVertex[<span class="number">0</span>]=m_yDVertex[<span class="number">0</span>];</span><br><span class="line">	m_xAVertex[n]=m_xDVertex[n<span class="number">-2</span>];</span><br><span class="line">	m_yAVertex[n]=m_yDVertex[n<span class="number">-2</span>];</span><br><span class="line">	<span class="type">double</span> a1,b1,c1,e1x,e1y,an_1,bn_1,cn_1,en_1x,en_1y;</span><br><span class="line">	<span class="built_in">InitEdge</span>(b1,c1,a1,e1x,e1y,cn_1,an_1,bn_1,en_1x,en_1y); CArray&lt;CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;,CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&amp;&gt; dia;<span class="comment">//系数矩阵存三对角元素</span></span><br><span class="line">	dia.<span class="built_in">SetSize</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//系数矩阵含第1，2,...,n-1行，行数为n-1。第i 行dia[0][i],dia[1][i],dia[2][i]存ai,bi,ci </span></span><br><span class="line">	<span class="comment">//三个元素。因系数矩阵不含第0行，dia[0][0],dia[1][0],dia[2][0]三元素空置。</span></span><br><span class="line">	<span class="comment">//系数矩阵既有三对角元素，又首行多出a1与末行多出cn_1两个元素。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) dia[i].<span class="built_in">SetSize</span>(n); </span><br><span class="line">	CArray&lt;CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;,CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&amp;&gt; t;</span><br><span class="line">	t.<span class="built_in">SetSize</span>(k);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++) t[i].<span class="built_in">SetSize</span>(n);	</span><br><span class="line">	<span class="comment">//生成系数矩阵第2，3，...,n-2行元素与右端矢量(t[0][i], t[1][i]),i=2，3，...,n-2</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n<span class="number">-2</span>;i++)    <span class="comment">//函数double delta(int i);在头文件中声明为受保护(protected)</span></span><br><span class="line">	&#123;                      <span class="comment">//成员，用于计算节点矢量中节点值的一阶向前差分</span></span><br><span class="line">		dia[<span class="number">0</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">2</span>)*<span class="built_in">delta</span>(i+<span class="number">2</span>))/(<span class="built_in">delta</span>(i)+<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>));</span><br><span class="line">		dia[<span class="number">1</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">2</span>)*(<span class="built_in">delta</span>(i)+<span class="built_in">delta</span>(i+<span class="number">1</span>)))/(<span class="built_in">delta</span>(i)+<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>))			   +(<span class="built_in">delta</span>(i+<span class="number">1</span>)*(<span class="built_in">delta</span>(i+<span class="number">2</span>)+<span class="built_in">delta</span>(i+<span class="number">3</span>)))/(<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>)+<span class="built_in">delta</span>(i+<span class="number">3</span>));</span><br><span class="line">		dia[<span class="number">2</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">1</span>)*<span class="built_in">delta</span>(i+<span class="number">1</span>))/(<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>)+<span class="built_in">delta</span>(i+<span class="number">3</span>));</span><br><span class="line">		t[<span class="number">0</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>))*m_xDVertex[i<span class="number">-1</span>];</span><br><span class="line">		t[<span class="number">1</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>))*m_yDVertex[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	dia[<span class="number">0</span>][<span class="number">1</span>]=a1; dia[<span class="number">1</span>][<span class="number">1</span>]=b1;	dia[<span class="number">2</span>][<span class="number">1</span>]=c1;            <span class="comment">//首行边界条件系数矩阵三元素</span></span><br><span class="line">	dia[<span class="number">0</span>][n<span class="number">-1</span>]=an_1; dia[<span class="number">1</span>][n<span class="number">-1</span>]= bn_1;dia[<span class="number">2</span>][n<span class="number">-1</span>]=cn_1;  <span class="comment">//末行边界条件系数矩阵三元素</span></span><br><span class="line">	t[<span class="number">0</span>][<span class="number">1</span>]=e1x;  t[<span class="number">1</span>][<span class="number">1</span>]=e1y;                         <span class="comment">//首行边界条件右端首点矢量。</span></span><br><span class="line">	t[<span class="number">0</span>][n<span class="number">-1</span>]=en_1x; t[<span class="number">1</span>][n<span class="number">-1</span>]=en_1y;                   <span class="comment">//末行边界条件右端末点矢量。</span></span><br><span class="line">	<span class="keyword">if</span>(m_eType0!=<span class="number">5</span>&amp;&amp;m_eType1!=<span class="number">5</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dia[<span class="number">0</span>][<span class="number">1</span>]=-dia[<span class="number">0</span>][<span class="number">1</span>]/dia[<span class="number">2</span>][<span class="number">2</span>];             <span class="comment">//开始消元过程，将首行a1消为0</span></span><br><span class="line">			dia[<span class="number">1</span>][<span class="number">1</span>]=dia[<span class="number">1</span>][<span class="number">1</span>]+dia[<span class="number">0</span>][<span class="number">2</span>]*dia[<span class="number">0</span>][<span class="number">1</span>];          </span><br><span class="line">			dia[<span class="number">2</span>][<span class="number">1</span>]=dia[<span class="number">2</span>][<span class="number">1</span>]+dia[<span class="number">1</span>][<span class="number">2</span>]*dia[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">			t[<span class="number">0</span>][<span class="number">1</span>]=t[<span class="number">0</span>][<span class="number">1</span>]+t[<span class="number">0</span>][<span class="number">2</span>]*dia[<span class="number">0</span>][<span class="number">1</span>]; </span><br><span class="line">			t[<span class="number">1</span>][<span class="number">1</span>]=t[<span class="number">1</span>][<span class="number">1</span>]+t[<span class="number">1</span>][<span class="number">2</span>]*dia[<span class="number">0</span>][<span class="number">1</span>]; </span><br><span class="line">			dia[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0.</span>; </span><br><span class="line">			dia[<span class="number">2</span>][n<span class="number">-1</span>]=-dia[<span class="number">2</span>][n<span class="number">-1</span>]/dia[<span class="number">0</span>][n<span class="number">-2</span>];         <span class="comment">//将末行cn_1消为0</span></span><br><span class="line">			dia[<span class="number">0</span>][n<span class="number">-1</span>]=dia[<span class="number">0</span>][n<span class="number">-1</span>]+dia[<span class="number">1</span>][n<span class="number">-2</span>]*dia[<span class="number">2</span>][n<span class="number">-1</span>];  </span><br><span class="line">			dia[<span class="number">1</span>][n<span class="number">-1</span>]=dia[<span class="number">1</span>][n<span class="number">-1</span>]+dia[<span class="number">2</span>][n<span class="number">-2</span>]*dia[<span class="number">2</span>][n<span class="number">-1</span>];</span><br><span class="line">			t[<span class="number">0</span>][n<span class="number">-1</span>]=t[<span class="number">0</span>][n<span class="number">-1</span>]+t[<span class="number">0</span>][n<span class="number">-2</span>]*dia[<span class="number">2</span>][n<span class="number">-1</span>];</span><br><span class="line">			t[<span class="number">1</span>][n<span class="number">-1</span>]=t[<span class="number">1</span>][n<span class="number">-1</span>]+t[<span class="number">1</span>][n<span class="number">-2</span>]*dia[<span class="number">2</span>][n<span class="number">-1</span>]; </span><br><span class="line">			dia[<span class="number">2</span>][n<span class="number">-1</span>]=<span class="number">0.</span>; 						 <span class="comment">//至此，系数矩阵已成为标准三对角矩阵</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++)                           <span class="comment">//将下三角元素全部消为0</span></span><br><span class="line">		&#123;</span><br><span class="line">			dia[<span class="number">0</span>][i]=-dia[<span class="number">0</span>][i]/dia[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">			dia[<span class="number">1</span>][i]=dia[<span class="number">1</span>][i]+dia[<span class="number">2</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];		</span><br><span class="line">			t[<span class="number">0</span>][i]=t[<span class="number">0</span>][i]+t[<span class="number">0</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">			t[<span class="number">1</span>][i]=t[<span class="number">1</span>][i]+t[<span class="number">1</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;k;l++) t[l][n<span class="number">-1</span>]=t[l][n<span class="number">-1</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];   <span class="comment">//得第n-1个控制顶点</span></span><br><span class="line">		<span class="keyword">for</span>(i=n<span class="number">-2</span>;i&gt;=<span class="number">1</span>;i--)                            <span class="comment">//回代求得第n-2,n-3,...,1个控制顶点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;k;l++) t[l][i]=(t[l][i]-dia[<span class="number">2</span>][i]*t[l][i+<span class="number">1</span>])/dia[<span class="number">1</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//当用于非节点条件，消元时可能出现主对角元素为0，作相应处理。</span></span><br><span class="line">	<span class="keyword">if</span>(m_eType0==<span class="number">5</span>||m_eType1==<span class="number">5</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		dia[<span class="number">0</span>][n<span class="number">-2</span>]=dia[<span class="number">0</span>][n<span class="number">-2</span>]-dia[<span class="number">2</span>][n<span class="number">-1</span>]*dia[<span class="number">2</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];  <span class="comment">//将dia[2][n-2]消为0;</span></span><br><span class="line">		dia[<span class="number">1</span>][n<span class="number">-2</span>]=dia[<span class="number">1</span>][n<span class="number">-2</span>]-dia[<span class="number">0</span>][n<span class="number">-1</span>]*dia[<span class="number">2</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">		t[<span class="number">0</span>][n<span class="number">-2</span>]=t[<span class="number">0</span>][n<span class="number">-2</span>]-t[<span class="number">0</span>][n<span class="number">-1</span>]*dia[<span class="number">2</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">		t[<span class="number">1</span>][n<span class="number">-2</span>]=t[<span class="number">1</span>][n<span class="number">-2</span>]-t[<span class="number">1</span>][n<span class="number">-1</span>]*dia[<span class="number">2</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">		dia[<span class="number">2</span>][n<span class="number">-2</span>]=<span class="number">0.</span>;		                           </span><br><span class="line">		dia[<span class="number">1</span>][<span class="number">2</span>]=dia[<span class="number">1</span>][<span class="number">2</span>]-dia[<span class="number">2</span>][<span class="number">1</span>]*dia[<span class="number">0</span>][<span class="number">2</span>]/dia[<span class="number">1</span>][<span class="number">1</span>];           <span class="comment">//dia[0][2]消为0;</span></span><br><span class="line">		dia[<span class="number">2</span>][<span class="number">2</span>]=dia[<span class="number">2</span>][<span class="number">2</span>]-dia[<span class="number">0</span>][<span class="number">1</span>]*dia[<span class="number">0</span>][<span class="number">2</span>]/dia[<span class="number">1</span>][<span class="number">1</span>];	</span><br><span class="line">		t[<span class="number">0</span>][<span class="number">2</span>]=t[<span class="number">0</span>][<span class="number">2</span>]-t[<span class="number">0</span>][<span class="number">1</span>]*dia[<span class="number">0</span>][<span class="number">2</span>]/dia[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">		t[<span class="number">1</span>][<span class="number">2</span>]=t[<span class="number">1</span>][<span class="number">2</span>]-t[<span class="number">1</span>][<span class="number">1</span>]*dia[<span class="number">0</span>][<span class="number">2</span>]/dia[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">		dia[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0.</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n<span class="number">-2</span>;i++)                                    <span class="comment">//将下三角元素消为0	</span></span><br><span class="line">		&#123;</span><br><span class="line">			dia[<span class="number">0</span>][i]=-dia[<span class="number">0</span>][i]/dia[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">			dia[<span class="number">1</span>][i]=dia[<span class="number">1</span>][i]+dia[<span class="number">2</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];		</span><br><span class="line">			t[<span class="number">0</span>][i]=t[<span class="number">0</span>][i]+t[<span class="number">0</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">			t[<span class="number">1</span>][i]=t[<span class="number">1</span>][i]+t[<span class="number">1</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">			dia[<span class="number">0</span>][i]=<span class="number">0.</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		t[<span class="number">0</span>][n<span class="number">-2</span>]=t[<span class="number">0</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-2</span>];                <span class="comment">//得顶点(m_xAVertex[n-2], m_yAVertex[n-2])</span></span><br><span class="line">		t[<span class="number">1</span>][n<span class="number">-2</span>]=t[<span class="number">1</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-2</span>];</span><br><span class="line">		<span class="keyword">for</span>(i=n<span class="number">-3</span>;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">		&#123;   <span class="comment">//回代求顶点(m_xAVertex[n-3], m_yAVertex[n-3]),...,(m_xAVertex[2], m_yAVertex[2])</span></span><br><span class="line">			t[<span class="number">0</span>][i]=(t[<span class="number">0</span>][i]-dia[<span class="number">2</span>][i]*t[<span class="number">0</span>][i+<span class="number">1</span>])/dia[<span class="number">1</span>][i];</span><br><span class="line">			t[<span class="number">1</span>][i]=(t[<span class="number">1</span>][i]-dia[<span class="number">2</span>][i]*t[<span class="number">1</span>][i+<span class="number">1</span>])/dia[<span class="number">1</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//回代求顶点(m_xAVertex[1], m_yAVertex[1])</span></span><br><span class="line">		t[<span class="number">0</span>][<span class="number">1</span>]=(t[<span class="number">0</span>][<span class="number">1</span>]-dia[<span class="number">2</span>][<span class="number">1</span>]*t[<span class="number">0</span>][<span class="number">2</span>]-dia[<span class="number">0</span>][<span class="number">1</span>]*t[<span class="number">0</span>][<span class="number">3</span>])/dia[<span class="number">1</span>][<span class="number">1</span>];  t[<span class="number">1</span>][<span class="number">1</span>]=(t[<span class="number">1</span>][<span class="number">1</span>]-dia[<span class="number">2</span>][<span class="number">1</span>]*t[<span class="number">1</span>][<span class="number">2</span>]-dia[<span class="number">0</span>][<span class="number">1</span>]*t[<span class="number">1</span>][<span class="number">3</span>])/dia[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//求顶点(m_xAVertex[n-1], m_yAVertex[n-1]</span></span><br><span class="line">		t[<span class="number">0</span>][n<span class="number">-1</span>]=(t[<span class="number">0</span>][n<span class="number">-1</span>]-dia[<span class="number">2</span>][n<span class="number">-1</span>]*t[<span class="number">0</span>][n<span class="number">-3</span>]-dia[<span class="number">0</span>][n<span class="number">-1</span>]*t[<span class="number">0</span>][n<span class="number">-2</span>])/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">		t[<span class="number">1</span>][n<span class="number">-1</span>]=(t[<span class="number">1</span>][n<span class="number">-1</span>]-dia[<span class="number">2</span>][n<span class="number">-1</span>]*t[<span class="number">1</span>][n<span class="number">-3</span>]-dia[<span class="number">0</span>][n<span class="number">-1</span>]*t[<span class="number">1</span>][n<span class="number">-2</span>])/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//得第1，2，...,n-1个控制顶点</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_xAVertex[i]=t[<span class="number">0</span>][i]; </span><br><span class="line">		m_yAVertex[i]=t[<span class="number">1</span>][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m_eType0!=<span class="number">2</span>&amp;&amp;m_eType0!=<span class="number">3</span>)</span><br><span class="line">	&#123;   <span class="comment">//该段解决拖动显示首端切矢矢端(m_xDVertex[n-1],m_yDVertex[n-1])</span></span><br><span class="line">		<span class="type">double</span> px,py;</span><br><span class="line">		<span class="type">int</span> rank=<span class="number">1</span>,nTime=<span class="number">3</span>;</span><br><span class="line">		<span class="type">double</span> u=<span class="number">0.</span>;</span><br><span class="line">		<span class="built_in">GetDerivat</span>(rank,nTime,u,px,py);</span><br><span class="line">		m_ftx=px;</span><br><span class="line">		m_fty=py;</span><br><span class="line">		m_xDVertex[n<span class="number">-1</span>]=m_xDVertex[<span class="number">0</span>]+<span class="number">0.5</span>*<span class="built_in">delta</span>(<span class="number">3</span>)*m_ftx;</span><br><span class="line">		m_yDVertex[n<span class="number">-1</span>]=m_yDVertex[<span class="number">0</span>]+<span class="number">0.5</span>*<span class="built_in">delta</span>(<span class="number">3</span>)*m_fty;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m_eType1!=<span class="number">2</span>&amp;&amp;m_eType1!=<span class="number">3</span>)</span><br><span class="line">	&#123;   <span class="comment">//该段解决拖动显示末端切矢矢端(m_xDVertex[n],m_yDVertex[n])</span></span><br><span class="line">		<span class="type">double</span> px,py;</span><br><span class="line">		<span class="type">int</span> rank=<span class="number">1</span>,nTime=<span class="number">3</span>;</span><br><span class="line">		<span class="type">double</span> u=<span class="number">1.</span>;</span><br><span class="line">		<span class="built_in">GetDerivat</span>(rank,nTime,u,px,py);</span><br><span class="line">		m_ltx=px;</span><br><span class="line">		m_lty=py;</span><br><span class="line">		m_xDVertex[n]=m_xDVertex[n<span class="number">-2</span>]+<span class="number">0.5</span>*<span class="built_in">delta</span>(n)*m_ltx;</span><br><span class="line">		m_yDVertex[n]=m_yDVertex[n<span class="number">-2</span>]+<span class="number">0.5</span>*<span class="built_in">delta</span>(n)*m_lty;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第八章-有理贝齐尔曲线">第八章 有理贝齐尔曲线</h2>
<h3 id="为什么使用有理？">为什么使用有理？</h3>
<p>在飞机外形设计与绝大多数机械零件中经常遇到许多由二次曲线弧与二次曲面表示的形状，如机身框截面外形曲线一般由多段圆弧、椭圆弧、抛物线弧等二次曲线弧与直线段连接而成。机械零件、塑料制品中圆柱面、圆锥面、圆环面等二次曲面及平面构成的形状更是比比皆是。这些形状在设计上都由图纸明确无误地给出，在制造上往往又要求较高的精度。非有理贝齐尔方法和B样条方法都不能精确表示除抛物面外的二次曲面，而只能给出近似表示。近似表示将带来处理上的麻烦，使本来简单的问题复杂化，还带来原来不存在的设计误差问题。例如，为用贝齐尔方法较精确地表示某一半径的半圆，需要用到五次贝齐尔曲线，并必须专门计算其控制顶点。如果改变圆的半径或要求更高的精度，就必须重新确定次数及计算控制顶点。<br>
显然，专门用于自由型曲线曲面的B样条方法包括贝齐尔方法根本不能适应初等曲面的要求。为了精确表示二次曲线弧与二次曲面，就不得不采用另外一套数学描述方法，譬如用隐方程表示。这样不仅又重新带来隐方程表示所存在的问题，而且将导致一个几何设计系统采用并存的两种不同数学方法。这将使系统变得十分庞杂，是系统研制人员最为忌讳的。</p>
<p>第5章介绍的贝齐尔方法实际采用参数整多项式，而有理贝齐尔方法采用分子分母分别是参数多项式与多项式函数的分式表示，是有理的。相对而言，我们把以前介绍的贝齐尔方法称为非有理的，相应的贝齐尔曲线曲面加上非有理的修饰词。</p>
<p>$有理=\frac{参数多项式}{多项式函数} $</p>
<h2 id="第九章-有理B样条曲线（核心）">第九章 有理B样条曲线（核心）</h2>
<p>有理B样条曲线通常都采用非均匀节点矢量，因此就有非均匀有理B样条(Non Uniform Rational B-Spline)曲线，即NURBS曲线，基于贝齐尔和B样条方法发展过来，并改成有理基函数</p>
<p>$NURBS的有理=\frac{分段参数多项式}{分段多项式函数} $</p>
<h3 id="三种等价的NURBS曲线方程">三种等价的NURBS曲线方程</h3>
<ol>
<li>有理分式表示</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/13/z3PlMwIRpuYvfUT.png" alt="image-20220213112449075"></p>
<ol start="2">
<li>
<p>有理基函数表示</p>
<p><img src="https://s2.loli.net/2022/02/13/GLka82FPEpgMUfZ.png" alt="image-20220213113108466"></p>
</li>
<li>
<p>齐次坐标表示</p>
<p><img src="https://s2.loli.net/2022/02/13/lBELoRJD19Wqwur.png" alt="image-20220213113434789"></p>
<p><img src="https://s2.loli.net/2022/02/13/AmEvG9hVu8n27bQ.png" alt="image-20220213113452269"></p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047453.png" alt="image-20220213113505380"></p>
</li>
</ol>
<h3 id="权因子对NURBS曲线形状的影响">权因子对NURBS曲线形状的影响</h3>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047766.png" alt="image-20220213124640171"></p>
<h3 id="组合NURBS曲线实例">组合NURBS曲线实例</h3>
<p>采用NURBS方法可以将顺序相接的各种连续性的各种非有理与有理贝齐尔曲线、非有理与有理B样条曲线在更高层次上组合，用一个统一方程表示，成为最具有一般意义的NURBS曲线</p>
<img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047581.png" alt="image-20220213140649373" style="zoom:80%;" />
<p>解决步骤：（具体查看书）</p>
<ol>
<li>确定组合后曲线的次数k。各分段曲线的最高次数</li>
<li>把各非B样条表示的分段曲线都取B样条表示。只需给出它们的节点矢量，其他不用变</li>
<li>把次数低于k的曲线升阶，并给出NURBS表示</li>
<li>确定组合NURBS曲线的控制顶点与权因子</li>
<li>确定各别曲线段在整体参数域[0,1]中的定义区间</li>
</ol>
<h3 id="NURBS曲线上点的计算（-）">NURBS曲线上点的计算（*）</h3>
<p>除了NURBS曲线的分式表示给出曲线方程直接计算NURBS曲线上的点，还可以使用德布尔算法来计算</p>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121048866.png" alt="image-20220213141408283"></p>
<p>编程实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">功能：计算NURBS曲线上参数u所对应的点(px,py)及其权因子w0。</span><br><span class="line">输入参数：(m_xAVertex,m_yAVertex)-控制顶点；m_Weights-权因子；m_aNode-节点矢量，都是受保护成员。m_nTimes –曲线次数,属公有成员；u-参数值。</span><br><span class="line">输出参数：px，py，w0-分别是NURBS曲线上参数u所对应的点的两个坐标与权因子。</span><br><span class="line">调用函数：无</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetPoint</span><span class="params">(<span class="type">double</span> u,<span class="type">double</span> &amp;px,<span class="type">double</span> &amp;py,<span class="type">double</span> &amp;w0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; ax,ay;</span><br><span class="line">    	CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; aw;</span><br><span class="line">	<span class="type">int</span> k=m_nTimes;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> iN=m_aNode.<span class="built_in">GetSize</span>()-k<span class="number">-2</span>;iN&gt;=<span class="number">0</span>;iN--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(u&gt;=m_aNode[iN])</span><br><span class="line">		&#123;</span><br><span class="line">			i=iN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i-k;j&lt;=i;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		ax.<span class="built_in">Add</span>(m_xAVertex[j]*m_Weights[j]);</span><br><span class="line">		ay.<span class="built_in">Add</span>(m_yAVertex[j]*m_Weights[j]);</span><br><span class="line">		aw.<span class="built_in">Add</span>(m_Weights[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//德布尔算法</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=k;l++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i-k+l;j&lt;=i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">double</span> alpha,du=m_aNode[j+k+<span class="number">1</span>-l]-m_aNode[j];</span><br><span class="line">			<span class="keyword">if</span>(du==<span class="number">0.0</span>) alpha=<span class="number">0.0</span>;</span><br><span class="line">			<span class="keyword">else</span> alpha=(u-m_aNode[j])/du;</span><br><span class="line">			<span class="type">int</span> n=j-(i-k+l);</span><br><span class="line">			ax[n]=(<span class="number">1</span>-alpha)*ax[n]+alpha*ax[n+<span class="number">1</span>];</span><br><span class="line">			ay[n]=(<span class="number">1</span>-alpha)*ay[n]+alpha*ay[n+<span class="number">1</span>];</span><br><span class="line">			aw[n]=(<span class="number">1</span>-alpha)*aw[n]+alpha*aw[n+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	px=ax[<span class="number">0</span>]/aw[<span class="number">0</span>];</span><br><span class="line">	py=ay[<span class="number">0</span>]/aw[<span class="number">0</span>];</span><br><span class="line">	w0=aw[<span class="number">0</span>];</span><br><span class="line">	ax.<span class="built_in">RemoveAll</span>();</span><br><span class="line">	ay.<span class="built_in">RemoveAll</span>();</span><br><span class="line">	aw.<span class="built_in">RemoveAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NURBS曲线的基本几何算法">NURBS曲线的基本几何算法</h3>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047728.png" alt="image-20220213141705236"></p>
<p>插入节点（书上有例子）</p>
<p>节点细化</p>
<p>曲线分割</p>
<p>节点消去</p>
<p>升阶和降阶</p>
<h3 id="NURBS曲线导矢计算（-）">NURBS曲线导矢计算（*）</h3>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121048207.png" alt="image-20220213142017826"></p>
<h4 id="计算理论">计算理论</h4>
<p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121048186.png" alt="image-20220213142058704"></p>
<h4 id="两个编程实例">两个编程实例</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">功能：求二维NURBS曲线参数为u的点处的r阶导矢(px,py)</span><br><span class="line">输入参数：r-导矢阶数；m_nTimes-曲线次数；u-参数。</span><br><span class="line">输出参数：(px,py)- r阶导矢。</span><br><span class="line">调用函数：GetWBPr-计算分子 的r阶导矢与分母 的r阶导数。</span><br><span class="line">	  GetNURBSDerivat-递归调用自身。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNURBSDerivat</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> m_nTimes,<span class="type">double</span> u,<span class="type">double</span> &amp;px,<span class="type">double</span> &amp;py)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> pw,PX,PY,PW;</span><br><span class="line">	<span class="type">double</span> Xikmax,Xikmay;</span><br><span class="line">	<span class="keyword">if</span>(r==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">GetPoint</span>(u,px,py,pw);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(r&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">GetWBPr</span>(r,m_nTimes,u,PX,PY,PW);</span><br><span class="line">		Xikmax=<span class="number">0</span>;  Xikmay=<span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=r;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">GetWBPr</span>(j,m_nTimes,u,PX,PY,PW);</span><br><span class="line">			<span class="built_in">GetNURBSDerivat</span>(r-j,m_nTimes,u,px,py);</span><br><span class="line">			Xikmax=Xikmax+<span class="built_in">Fact</span>(r)/(<span class="built_in">Fact</span>(r-j)*<span class="built_in">Fact</span>(j))*PW*px;</span><br><span class="line">			Xikmay=Xikmay+<span class="built_in">Fact</span>(r)/(<span class="built_in">Fact</span>(r-j)*<span class="built_in">Fact</span>(j))*PW*py;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">GetPoint</span>(u,px,py,pw);</span><br><span class="line">		<span class="built_in">GetWBPr</span>(r,m_nTimes,u,PX,PY,PW);</span><br><span class="line">		px=(PX-Xikmax)/pw;</span><br><span class="line">		py=(PY-Xikmay)/pw;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">功能：求二维k次NURBS曲线的分子曲线上参数为u的点处的r阶导矢(PX,PY)及分母函数的r阶导数PW。</span><br><span class="line">输入参数：m_aVertex-控制顶点，m_Weights-权因子，m_aNode-节点矢量，都是受保护成员。r-导矢阶数；k -曲线次数；u-参数。</span><br><span class="line">输出参数：(PX,PY)- r阶导矢；PW-r阶导数。当u为内节点值,r&gt;<span class="number">0</span>时,m_KnotMark=<span class="number">0</span>与<span class="number">1</span>分布输出右导矢、左导矢与右导数、左导数。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">GetWBPr</span>(<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">double</span> u,<span class="type">double</span> &amp;PX,<span class="type">double</span> &amp;PY,<span class="type">double</span> &amp;PW)</span><br><span class="line">&#123;</span><br><span class="line">	CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; tempx,tempy,tempw;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;k)</span><br><span class="line">	&#123;PX=<span class="number">0</span>;  PY=<span class="number">0</span>;  PW=<span class="number">0</span>;  <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=m_aNode.<span class="built_in">GetSize</span>()-m_nTimes<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(u&gt;=m_aNode[i]) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u&lt;m_aNode[k]) i=k;</span><br><span class="line">	<span class="keyword">if</span>((k==<span class="number">1</span>&amp;&amp;r==<span class="number">1</span>&amp;&amp;u!=m_aNode[i])||(m_KnotMark==<span class="number">0</span>&amp;&amp;i==k&amp;&amp;u==m_aNode[i])||m_KnotMark==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PX=<span class="built_in">int</span>((m_aVertex[i].x*m_Weights[i]-m_aVertex[i<span class="number">-1</span>].x*m_Weights[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]));</span><br><span class="line">		PY=<span class="built_in">int</span>((m_aVertex[i].y*m_Weights[i]-m_aVertex[i<span class="number">-1</span>].y*m_Weights[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]));</span><br><span class="line">		PW=(m_Weights[i]-m_Weights[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;r==<span class="number">1</span>&amp;&amp;m_KnotMark==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PX=<span class="built_in">int</span>((m_aVertex[i<span class="number">-1</span>].x*m_Weights[i<span class="number">-1</span>]-m_aVertex[i<span class="number">-2</span>].x*m_Weights[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]));</span><br><span class="line">		PY=<span class="built_in">int</span>((m_aVertex[i<span class="number">-1</span>].y*m_Weights[i<span class="number">-1</span>]-m_aVertex[i<span class="number">-2</span>].y*m_Weights[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]));</span><br><span class="line">		PW=(m_Weights[i<span class="number">-1</span>]-m_Weights[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;<span class="number">1</span>&amp;&amp;r==k&amp;&amp;m_KnotMark==<span class="number">1</span>&amp;&amp;u==m_aNode[i]&amp;&amp;i!=k) i=i<span class="number">-1</span>;	</span><br><span class="line">	<span class="keyword">if</span>((k==<span class="number">1</span>&amp;&amp;r==<span class="number">0</span>)||k&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i-k;j&lt;=i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tempx.<span class="built_in">Add</span>(<span class="built_in">double</span>(m_aVertex[j].x*m_Weights[j]));</span><br><span class="line">			tempy.<span class="built_in">Add</span>(<span class="built_in">double</span>(m_aVertex[j].y*m_Weights[j]));</span><br><span class="line">			tempw.<span class="built_in">Add</span>(m_Weights[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=r;l++)  <span class="comment">//本修订版教材(7.7)式第一式的r级递推</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(j=i-k;j&lt;=i-l;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">double</span> beta=(k-l+<span class="number">1</span>)/(m_aNode[j+k+<span class="number">1</span>]-m_aNode[j+l]);</span><br><span class="line">					<span class="type">int</span> jj=j-(i-k);</span><br><span class="line">					tempx[jj]=beta*(tempx[jj+<span class="number">1</span>]-tempx[jj]);</span><br><span class="line">					tempy[jj]=beta*(tempy[jj+<span class="number">1</span>]-tempy[jj]);</span><br><span class="line">					tempw[jj]=beta*(tempw[jj+<span class="number">1</span>]-tempw[jj]);</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//本修订版教材(7.7c)式德布尔算法,次数已由k降为k-r</span></span><br><span class="line">		<span class="keyword">for</span>(l=<span class="number">1</span>;l&lt;=k-r;l++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=i-k;j&lt;=i-l-r;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">double</span> alpha,du=m_aNode[j+k+<span class="number">1</span>]-m_aNode[j+r+l];</span><br><span class="line">				<span class="keyword">if</span>(du==<span class="number">0.0</span>) alpha=<span class="number">0.0</span>;</span><br><span class="line">				<span class="keyword">else</span> alpha=(u-m_aNode[j+r+l])/du;</span><br><span class="line">				tempx[j-i+k]=(<span class="number">1</span>-alpha)*tempx[j-i+k]+alpha*tempx[j-i+k+<span class="number">1</span>];</span><br><span class="line">				tempy[j-i+k]=(<span class="number">1</span>-alpha)*tempy[j-i+k]+alpha*tempy[j-i+k+<span class="number">1</span>];</span><br><span class="line">				tempw[j-i+k]=(<span class="number">1</span>-alpha)*tempw[j-i+k]+alpha*tempw[j-i+k+<span class="number">1</span>];</span><br><span class="line">				<span class="type">double</span> ww=tempw[j-i+k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		PX=tempx[<span class="number">0</span>];</span><br><span class="line">		PY=tempy[<span class="number">0</span>];</span><br><span class="line">		PW=tempw[<span class="number">0</span>];</span><br><span class="line">		tempx.<span class="built_in">RemoveAll</span>();</span><br><span class="line">		tempy.<span class="built_in">RemoveAll</span>();</span><br><span class="line">		tempw.<span class="built_in">RemoveAll</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NURBS曲线的形状修改">NURBS曲线的形状修改</h3>
<p><strong>实际中应用控制顶点粗调，用权因子细调</strong></p>
<p>重新定位控制顶点</p>
<p>反插节点</p>
<p>重新确定权因子</p>
<p>NURBS编程实例</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 给定一组数据点，即型值点，反求其控制顶点，并构造通过这些型值点的2D或3D nurbs曲线，首末型值点与控制顶点重合，称为nurbs曲线插值</span></span><br><span class="line"><span class="comment">% 具有n个型值点的k次nurbs插值曲线，将有n+2个未知控制顶点，首末节点取重复度r=k+1,从而具有n+2+k+1个节点</span></span><br><span class="line"><span class="comment">% 三次Nurbs曲线的首末节点取重复度r=k+1=4，u1=u2=u3=u4=0,Un+3=Un+4=Un+5=Un+6=1</span></span><br><span class="line">clear</span><br><span class="line">pt=load(<span class="string">&#x27;data2.txt&#x27;</span>); </span><br><span class="line">[row,column]=<span class="built_in">size</span>(pt);  <span class="comment">%每行代表一个型值点，采用列向量表示x,y,z坐标，便于线性方程组求解</span></span><br><span class="line">n=<span class="built_in">length</span>(pt);  <span class="comment">%型值点数量</span></span><br><span class="line">k=<span class="number">3</span>;  <span class="comment">%样条阶数</span></span><br><span class="line">U=<span class="built_in">zeros</span>(<span class="number">1</span>,n+k+<span class="number">3</span>);  <span class="comment">%节点矢量</span></span><br><span class="line"><span class="comment">%第一步：计算节点矢量********************</span></span><br><span class="line"><span class="keyword">if</span>(column == <span class="number">2</span>)   <span class="comment">% 2D curve</span></span><br><span class="line">    x=pt(:,<span class="number">1</span>);</span><br><span class="line">    y=pt(:,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span>              <span class="comment">% 3D curve</span></span><br><span class="line">    x=pt(:,<span class="number">1</span>);</span><br><span class="line">    y=pt(:,<span class="number">2</span>);</span><br><span class="line">    z=pt(:,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%n个数据点，利用规范积累弦长法进行型值点参数化处理</span></span><br><span class="line">temp=<span class="built_in">zeros</span>(<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n<span class="number">-1</span>  <span class="comment">%n个数据点，n-1段弦长</span></span><br><span class="line">   <span class="keyword">if</span>(column == <span class="number">2</span>)    <span class="comment">% 2D curve</span></span><br><span class="line">   temp(<span class="built_in">i</span>)=<span class="built_in">sqrt</span>((x(<span class="built_in">i</span>+<span class="number">1</span>)-x(<span class="built_in">i</span>))^<span class="number">2</span>+(y(<span class="built_in">i</span>+<span class="number">1</span>)-y(<span class="built_in">i</span>))^<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">else</span>               <span class="comment">% 3D curve</span></span><br><span class="line">   temp(<span class="built_in">i</span>)=<span class="built_in">sqrt</span>((x(<span class="built_in">i</span>+<span class="number">1</span>)-x(<span class="built_in">i</span>))^<span class="number">2</span>+(y(<span class="built_in">i</span>+<span class="number">1</span>)-y(<span class="built_in">i</span>))^<span class="number">2</span>+(z(<span class="built_in">i</span>+<span class="number">1</span>)-z(<span class="built_in">i</span>))^<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">sumtemp=sum(temp);<span class="comment">%顺序相邻两型值点之间距离的和,即总弦长</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:k+<span class="number">1</span>      <span class="comment">%前k+1个节点为0</span></span><br><span class="line">    U(<span class="built_in">i</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=n+k:n+k+<span class="number">3</span>  <span class="comment">%后k+1个节点为1</span></span><br><span class="line">    U(<span class="built_in">i</span>)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> <span class="comment">%n个数据点，内节点为n-2个，U(k+1)作为初始值</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=k+<span class="number">1</span>:n+k<span class="number">-2</span></span><br><span class="line">    U(<span class="built_in">i</span>+<span class="number">1</span>)=U(<span class="built_in">i</span>)+temp(<span class="built_in">i</span>-k)/sumtemp;  <span class="comment">%n-1段弦长，U（k+1）到U（n+k）共n个节点</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%第二步：反算n+2个控制点，采用切矢边界*****************************</span></span><br><span class="line"><span class="comment">%控制顶点的首末端点和给定型值点的首末端点重合</span></span><br><span class="line"><span class="keyword">if</span>(column == <span class="number">2</span>)</span><br><span class="line">    dpt1=[<span class="number">0</span> <span class="number">1</span>];<span class="comment">%给定首数据点切矢</span></span><br><span class="line">    dptn=[<span class="number">-1</span> <span class="number">0</span>];<span class="comment">%给定末数据点切矢</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dpt1=[<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];<span class="comment">%给定首数据点切矢</span></span><br><span class="line">    dptn=[<span class="number">-1</span> <span class="number">0</span> <span class="number">0</span>];<span class="comment">%给定末数据点切矢</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">dU=<span class="built_in">zeros</span>(<span class="number">1</span>,n+k+<span class="number">3</span>);  <span class="comment">%节点增量，△U=Ui+1-Ui</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=k+<span class="number">1</span>:n+k<span class="number">-1</span></span><br><span class="line">    dU(<span class="built_in">i</span>)=U(<span class="built_in">i</span>+<span class="number">1</span>)-U(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%求解线性方程组获得控制顶点向量，A*D=E,A为系数矩阵，元素为B样条基函数的值；D是控制顶点列向量；E是列向量</span></span><br><span class="line">A=<span class="built_in">zeros</span>(n);</span><br><span class="line"><span class="keyword">if</span>(column == <span class="number">2</span>)</span><br><span class="line">    E=<span class="built_in">zeros</span>(n,<span class="number">2</span>);  <span class="comment">%2D curve</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    E=<span class="built_in">zeros</span>(n,<span class="number">3</span>);  <span class="comment">%3D curve</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>)=<span class="number">1</span>;  <span class="comment">%切矢条件a1=1,b1=c1=0</span></span><br><span class="line">A(n,n)=<span class="number">1</span>;  <span class="comment">%切矢条件an=bn=0,cn=1</span></span><br><span class="line">E(<span class="number">1</span>,:)=pt(<span class="number">1</span>,:)+(dU(<span class="number">4</span>)/<span class="number">3</span>)*dpt1;    <span class="comment">%首端点条件</span></span><br><span class="line">E(n,:)=pt(n,:)-(dU(n+<span class="number">2</span>)/<span class="number">3</span>)*dptn;  <span class="comment">%末端点条件</span></span><br><span class="line"><span class="comment">%计算系数矩阵A的元素a,b,c以及列向量E的元素e的值</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:n<span class="number">-1</span>  </span><br><span class="line">    A(<span class="built_in">i</span>,<span class="built_in">i</span><span class="number">-1</span>)=dU(<span class="built_in">i</span>+<span class="number">3</span>).^<span class="number">2</span>/(dU(<span class="built_in">i</span>+<span class="number">1</span>)+dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>));                  <span class="comment">%a的值</span></span><br><span class="line">    A(<span class="built_in">i</span>,<span class="built_in">i</span>)=dU(<span class="built_in">i</span>+<span class="number">3</span>)*(dU(<span class="built_in">i</span>+<span class="number">1</span>)+dU(<span class="built_in">i</span>+<span class="number">2</span>))/(dU(<span class="built_in">i</span>+<span class="number">1</span>)+dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>))+...  <span class="comment">%b的值</span></span><br><span class="line">        dU(<span class="built_in">i</span>+<span class="number">2</span>)*(dU(<span class="built_in">i</span>+<span class="number">3</span>)+dU(<span class="built_in">i</span>+<span class="number">4</span>))/(dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>)+dU(<span class="built_in">i</span>+<span class="number">4</span>));</span><br><span class="line">    A(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>)=dU(<span class="built_in">i</span>+<span class="number">2</span>).^<span class="number">2</span>/(dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>)+dU(<span class="built_in">i</span>+<span class="number">4</span>));                  <span class="comment">%c的值</span></span><br><span class="line">    E(<span class="built_in">i</span>,:)=(dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>))*pt(<span class="built_in">i</span>,:);                               <span class="comment">%e的值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">D=A\E;  <span class="comment">%解方程组，获得去除首末端点的控制顶点向量</span></span><br><span class="line">D=[pt(<span class="number">1</span>,:);D;pt(n,:)]; <span class="comment">%控制顶点向量，控制顶点比数据点多两个，加上首末端点</span></span><br><span class="line">[s,t]=<span class="built_in">size</span>(D);  <span class="comment">%s：控制点数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%第三步：求出Nurbs曲线*****************************</span></span><br><span class="line">dt=<span class="number">0.001</span>;  <span class="comment">%Nurbs曲线插值密度，dt越小，越光滑</span></span><br><span class="line">P=[];      <span class="comment">%Nurbs曲线</span></span><br><span class="line">syms dx;   <span class="comment">%定义节点间的递增变量为变量dx</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=k+<span class="number">1</span>:s</span><br><span class="line">    u=U;</span><br><span class="line">    d=sym(D);</span><br><span class="line">    <span class="comment">%每次迭代后将d恢复初值</span></span><br><span class="line">    <span class="keyword">for</span> m=<span class="number">1</span>:k</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="built_in">i</span>-k:<span class="built_in">i</span>-m</span><br><span class="line">            alpha(<span class="built_in">j</span>)=(dx-u(<span class="built_in">j</span>+m))/(u(<span class="built_in">j</span>+k+<span class="number">1</span>)-u(<span class="built_in">j</span>+m));</span><br><span class="line">            d(<span class="built_in">j</span>,:)=(<span class="number">1</span>-alpha(<span class="built_in">j</span>))*d(<span class="built_in">j</span>,:)+alpha(<span class="built_in">j</span>)*d(<span class="built_in">j</span>+<span class="number">1</span>,:);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%带入变量dx求出各节点区间[ui,ui+1]内m=3的控制点d</span></span><br><span class="line">    M=subs(d(<span class="built_in">i</span>-k,:),dx,(u(<span class="built_in">i</span>):dt:(u(<span class="built_in">i</span>+<span class="number">1</span>)-dt))&#x27;);    <span class="comment">%节点区间内的插值点替换dx</span></span><br><span class="line">    P=[P;double(M)];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">M=subs(d(s-k,:),dx,<span class="number">1</span>);</span><br><span class="line">P=[P;double(M)];<span class="comment">%补上最后一个点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%第四步、绘制给定型值点、控制点及其Nurbs曲线*****************************</span></span><br><span class="line"><span class="keyword">if</span>(column == <span class="number">2</span>)  <span class="comment">%2D curve</span></span><br><span class="line">    <span class="built_in">plot</span>(pt(:,<span class="number">1</span>),pt(:,<span class="number">2</span>),<span class="string">&#x27;*r&#x27;</span>);  <span class="comment">%绘制型值点</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot</span>(D(:,<span class="number">1</span>),D(:,<span class="number">2</span>),<span class="string">&#x27;b-o&#x27;</span>);   <span class="comment">%绘制控制点</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot</span>(P(:,<span class="number">1</span>),P(:,<span class="number">2</span>),<span class="string">&#x27;r&#x27;</span>);     <span class="comment">%绘制nurbs曲线</span></span><br><span class="line">    <span class="built_in">hold</span> on;  </span><br><span class="line"><span class="keyword">else</span>             <span class="comment">%3D curve</span></span><br><span class="line">    <span class="built_in">plot3</span>(pt(:,<span class="number">1</span>),pt(:,<span class="number">2</span>),pt(:,<span class="number">3</span>),<span class="string">&#x27;*r&#x27;</span>); <span class="comment">%绘制型值点</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot3</span>(D(:,<span class="number">1</span>),D(:,<span class="number">2</span>),D(:,<span class="number">3</span>),<span class="string">&#x27;b-o&#x27;</span>);   <span class="comment">%绘制控制点</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot3</span>(P(:,<span class="number">1</span>),P(:,<span class="number">2</span>),P(:,<span class="number">3</span>),<span class="string">&#x27;r&#x27;</span>);     <span class="comment">%绘制nurbs曲线</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">axis equal;</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://supervisen.github.io">Visen Cao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://supervisen.github.io/2022/02/5.1NURBS%E6%9B%B2%E7%BA%BF/">https://supervisen.github.io/2022/02/5.1NURBS曲线/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://supervisen.github.io" target="_blank">Visen</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NURBS/">NURBS</a></div><div class="post_share"><div class="social-share" data-image="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044590.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/0.3%E5%9F%9F%E5%90%8D/"><img class="prev-cover" src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205120947422.jpeg" onerror="onerror=null;src='https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121056143.jpeg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo博客绑定域名</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/3.2Csharp%E7%AC%94%E8%AE%B02/"><img class="next-cover" src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041024.jpeg" onerror="onerror=null;src='https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121056143.jpeg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CSharp系列（二）类Class的概念</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#center-%E5%BC%95%E5%AD%90-center-5"><span class="toc-text">引子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9B%B2%E7%BA%BF%E5%92%8C%E6%9B%B2%E9%9D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA"><span class="toc-text">第一章 曲线和曲面的基本理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B4%E7%BA%BF%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-text">1.直线的表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9B%B2%E7%BA%BF%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-text">2.曲线的表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E5%8C%96%E4%B8%8E%E5%8F%82%E6%95%B0%E5%8F%98%E6%8D%A2"><span class="toc-text">3.参数化与参数变换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%82%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC%E4%B8%8E%E9%80%BC%E8%BF%91"><span class="toc-text">第二章 参数多项式插值与逼近</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E5%87%BD%E6%95%B0"><span class="toc-text">1.基函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%82%B9%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-text">2.数据点的参数化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC%E6%9B%B2%E7%BA%BF"><span class="toc-text">3.多项式插值曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E9%80%BC%E8%BF%91"><span class="toc-text">4.最小二乘逼近</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%8F%82%E6%95%B0%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2"><span class="toc-text">第三章 参数样条曲线曲面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%82%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="toc-text">1.参数连续性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%89%E5%88%87%E7%9F%A2%E6%96%B9%E7%A8%8B"><span class="toc-text">2.三切矢方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="toc-text">3.边界条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF"><span class="toc-text">4.定义的参数三次样条曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AE%A1%E7%AE%97%E6%8F%92%E5%80%BC"><span class="toc-text">5.计算插值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8F%82%E6%95%B0%E6%89%80%E5%9C%A8%E7%9A%84%E8%8A%82%E7%82%B9%E5%8C%BA%E9%97%B4"><span class="toc-text">判断参数所在的节点区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E7%94%A8%E7%9B%B8%E5%BA%94%E7%9A%84%E6%9B%B2%E7%BA%BF%E6%AE%B5%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">选用相应的曲线段表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B"><span class="toc-text">程序实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%85%89%E9%A1%BA%E6%80%A7%EF%BC%88%E5%85%89%E6%BB%91%E9%A1%BA%E7%9C%BC%EF%BC%89"><span class="toc-text">6.光顺性（光滑顺眼）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B4%9D%E9%BD%90%E5%B0%94bezier%E6%9B%B2%E7%BA%BF"><span class="toc-text">第四章 贝齐尔bezier曲线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B4%9D%E9%BD%90%E5%B0%94%E6%9B%B2%E7%BA%BF%E6%96%B9%E7%A8%8B%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8"><span class="toc-text">1.贝齐尔曲线方程及其性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B4%9D%E9%BD%90%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%AF%BC%E7%9F%A2"><span class="toc-text">2.贝齐尔曲线导矢</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">公式计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B"><span class="toc-text">编程实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B4%9D%E9%BD%90%E5%B0%94%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%8D%87%E9%98%B6%E4%B8%8E%E9%99%8D%E9%98%B6"><span class="toc-text">3.贝齐尔曲线的升阶与降阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%87%E9%98%B6"><span class="toc-text">升阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%8D%E9%98%B6%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-text">降阶（略）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B4%9D%E9%BD%90%E5%B0%94%E6%9B%B2%E7%BA%BF%E7%9A%84%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F"><span class="toc-text">4.贝齐尔曲线的矩阵形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA"><span class="toc-text">第五章 B样条曲线曲面的基本理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-B%E6%A0%B7%E6%9D%A1%E4%B8%8EB%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.B样条与B样条曲线的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-B%E6%A0%B7%E6%9D%A1%E7%9A%84%E9%80%92%E6%8E%A8%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8"><span class="toc-text">2.B样条的递推定义及其性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B-2"><span class="toc-text">编程实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-B%E6%A0%B7%E6%9D%A1%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E8%B4%A8"><span class="toc-text">3.B样条的局部性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%9E%E5%9D%87%E5%8C%80B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF"><span class="toc-text">4.非均匀B样条曲线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9F%A2%E9%87%8F%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-text">节点矢量的确定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%8F%8A%E5%85%B6%E5%AF%BC%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="toc-text">B样条基及其导数计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E4%B8%8A%E7%9A%84%E7%82%B9%EF%BC%88%E5%BE%B7%E5%B8%83%E5%B0%94%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">计算B样条曲线上的点（德布尔算法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AF%BC%E7%9F%A2%EF%BC%88%E5%BE%B7%E5%B8%83%E5%B0%94%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">计算B样条曲线的导矢（德布尔算法）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-B%E6%A0%B7%E6%9D%A1%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-text">第六章  B样条方法的基本几何算法（略）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E6%8B%9F%E5%90%88%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">第七章 B样条曲线拟合（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%AC%A1%E6%95%B0k"><span class="toc-text">曲线次数k</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9F%A2%E9%87%8F"><span class="toc-text">节点矢量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%AE%97%E6%8E%A7%E5%88%B6%E9%A1%B6%E7%82%B9"><span class="toc-text">反算控制顶点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B-3"><span class="toc-text">编程实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9C%89%E7%90%86%E8%B4%9D%E9%BD%90%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-text">第八章 有理贝齐尔曲线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%9C%89%E7%90%86%EF%BC%9F"><span class="toc-text">为什么使用有理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%9C%89%E7%90%86B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-text">第九章 有理B样条曲线（核心）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%AD%89%E4%BB%B7%E7%9A%84NURBS%E6%9B%B2%E7%BA%BF%E6%96%B9%E7%A8%8B"><span class="toc-text">三种等价的NURBS曲线方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E5%9B%A0%E5%AD%90%E5%AF%B9NURBS%E6%9B%B2%E7%BA%BF%E5%BD%A2%E7%8A%B6%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">权因子对NURBS曲线形状的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88NURBS%E6%9B%B2%E7%BA%BF%E5%AE%9E%E4%BE%8B"><span class="toc-text">组合NURBS曲线实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%E4%B8%8A%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%88-%EF%BC%89"><span class="toc-text">NURBS曲线上点的计算（*）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95"><span class="toc-text">NURBS曲线的基本几何算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%E5%AF%BC%E7%9F%A2%E8%AE%A1%E7%AE%97%EF%BC%88-%EF%BC%89"><span class="toc-text">NURBS曲线导矢计算（*）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA"><span class="toc-text">计算理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B"><span class="toc-text">两个编程实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NURBS%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%BD%A2%E7%8A%B6%E4%BF%AE%E6%94%B9"><span class="toc-text">NURBS曲线的形状修改</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121056797.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Visen Cao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">持志似心痛，赤子步难停</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://live2d-widget-right.oss-cn-hangzhou.aliyuncs.com/canvas-nest.min.js"></script><div class="aplayer no-destroy" data-id="7058412570" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" data-loop="all" muted></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script src="//code.tidio.co/s75ep2wjnaqpd8czfu2dy2cjzaavhqjj.js" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>