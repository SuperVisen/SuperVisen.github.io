<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自用工具推荐</title>
      <link href="/2100/02/4.1%E8%87%AA%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
      <url>/2100/02/4.1%E8%87%AA%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-6"><center>引子</h2><p>    这里是Visen.本人有点整理癖+强迫症。刚初中那会，学校书桌总是乱的不行，我崇拜的数学老师说书都不理清楚做题条理怎么清晰。Then，开始养成了整理癖🤦‍♂。契机也是陪了五年的老伙计开MATLAB和VS也太卡了吧，想换但又怕一些软件丢掉，考虑到存U盘里实在是太费空间，想做个收纳盒，也正好做一期分享！</p><p>功能需求就是免费优先，好用好看优先。我把每类工具进行对比，好用就置顶，也给出理由，并把所有链接提供给朋友来选择。观察大家下载软件很多都是直接百度，进软件官网倒还好，不然可就病毒跟着跑。</p><p>这里整理自用比较安全、持续更新的软件下载途径（都是不需要关注公众号直接网页下载，🐴住就对了）</p><ul><li>软件各自官网：官网yyds，其他渠道可能没法下载到最新版</li><li><a href="https://lestore.lenovo.com/">联想软件商店</a>：对比腾讯和360的软件管家，基础软件的下载称得上干净又卫生，评论区也挺实在的</li><li><a href="https://www.xiaoyi.vc/">下1个好软件</a>：强烈建议关注，现象级资源分享，没啥套路。<a href="https://www.xiaoyi.vc/">备用网址</a></li><li><a href="https://www.fy6b.com/">枫音应用</a>：五音助手（后来叫悦音）应该听过吧，大佬开始建站来分享一些<s>破解</s>黑科技资源，分类很全，还有一些好玩游戏（比如港诡实录）还有很多破解版手机软件，诚意满满！当然，比较全的还是<a href="https://masuit.com/">懒得勤快</a>和<a href="https://www.423down.com/">423Down</a></li><li><a href="https://mp.weixin.qq.com/s/WnFbxJxkEW_vNqq-1LJkaA">软件管家</a>、<a href="https://mp.weixin.qq.com/s/-xWldWW69opJ4gKrcrsRuw">软件管家中心</a>、<a href="https://mp.weixin.qq.com/s/0QPrmVE7unxoVDSqkm8e_g">软件安装家园</a>：以行业软件为主要内容，无需关注就能获得网盘提取码，还有安装教程。 安装的同时，想顺便学下使用技巧？可以看<a href="http://www.zhanshaoyi.com/rjxz.html">我爱分享网</a>，博主非盈利地更新这些东西</li><li><a href="https://nwuzmed.ga/">DAC导航</a>、<a href="https://hou.qialu999.com/">恰鹿导航</a>、<a href="https://imyshare.com/">imyShare</a>、<a href="https://adzhp.cn/category/shi-pin-zhi-bo/">爱达杂货铺</a>：DAC导航是我见过最全的，也是使用起来不别扭的一个。和站长聊过，完全0成本建站！</li></ul><p>通过这些渠道基本能获取所有软件，当然这里还提供最终极的办法就是云盘搜索：<a href="https://www.chaonengso.com/">超能搜（百度云盘）</a>、<a href="https://www.alipanso.com/">阿里盘搜</a>、<a href="https://www.niceso.fun/?utm_source=iMyShare&amp;utm_medium=Nav">奈斯搜索（阿里云盘）</a></p><hr><h2 id="装机必备">装机必备</h2><h3 id="安全防护">安全防护</h3><p>Microsoft Defender：系统自带的安全防护，但是真的会存在误杀（需要设置排除项）</p><p><a href="https://guanjia.qq.com/">腾讯电脑管家</a>：简洁干净，内置软件库太旧，但一般不用来下载软件</p><p><a href="https://www.huorong.cn/">火绒</a>：满足基本的安全需求</p><p><a href="https://guanjia.lenovo.com.cn/">联想电脑管家</a>：联想的一站式管家软件，火绒帮忙开发，里面有些壁纸还是不错的，还能更新官方驱动</p><h3 id="文件压缩">文件压缩</h3><p><a href="https://www.123pan.com/s/nmk9-su88H">Bandizip 破解专业版</a>：操作简便，右键使用舒服，<a href="https://www.bandisoft.com/bandizip/help/edition-comparison/">解压快</a>还得专业版。记得设置解压完自动关闭窗口，就能体会到解压的爽感。安装完重启，右键菜单才会生效</p><p><a href="https://www.7-zip.org/">7-zip</a>：7z这类压缩速度是最快的，UI稍微少了味，不同类型压缩文件的图标是一样的</p><p><a href="https://www.microsoft.com/zh-cn/p/nanazip/9n8g7tscl18r?rtc=1&amp;activetab=pivot:overviewtab">NanaZip</a>：基于7-zip 21.03开发的压缩软件，可在微软商店下载，UI还是不错的</p><p><a href="https://peazip.github.io/"><s>Peazip</s></a>：豌豆图标我看着还行哈哈哈，不知道为啥被吐槽，支持采用7z格式，操作上还是方便的，只是每次解压都会卡顿下来唤醒软件</p><h3 id="输入法">输入法</h3><p>Windows11自带输入法：自带输入法新增网络词库</p><p><a href="https://www.123pan.com/s/nmk9-jK88H">搜狗输入法</a>：去除大部分广告的版本</p><p><a href="https://srf.xunfei.cn/">讯飞输入法</a>：词库有点少，一些专业名词没法打出来</p><h3 id="音频播放器">音频播放器</h3><p><a href="http://potplayer.tv/?lang=zh_CN">Potplayer</a>：宇宙最强播放器，日常视频和音乐格式全覆盖</p><h3 id="下载工具">下载工具</h3><p><a href="http://neatdownloadmanager.com/index.php/en/">NeatDownloadManager</a>：小白推荐！体积小巧，比IDM更专注资源嗅探和下载，但是操作上更简便，不用破解就完全免费（<strong>记得在设置里开32线程</strong>）,并且能在设置里对文件进行分类。但是有时候在某些破解的视频网站会误下（无法选择下载黑名单）。类似的<a href="https://xdown.org/">xdown</a>界面丑了一些，使用起来困难一些，但是下载功能全一些</p><p><a href="http://www.filecxx.com/zh_CN/index.html">文件蜈蚣</a>：安装扩展后和NDM下载一样，而且功能很齐全，还能用于做种子</p><h3 id="文本阅读">文本阅读</h3><p>微软Edge浏览器：打开pdf速度快，支持笔记（知网安装插件，可以只下载pdf格式）</p><p><a href="http://www.daokeyuedu.com/">稻壳阅读器</a>：轻量阅读器，科研必备，支持pdf、caj、epub等格式</p><p><a href="http://www.zhiyunwenxian.cn/">知云文献翻译</a>：英文阅读软件，软件内实现划词翻译</p><h3 id="软件卸载">软件卸载</h3><p><a href="https://geekuninstaller.com/">Geek</a>：最简洁的卸载软件，日常使用</p><p><a href="http://hibitsoft.ir/Uninstaller.html">HiBit Uninstaller</a>：卸载+清理软件，可更改为中文，功能完善<a href="https://www.123pan.com/s/nmk9-YS88H">HiBitUninstaller v2.6.15</a></p><h3 id="网络优化">网络优化</h3><p><a href="https://github.com/dotnetcore/FastGithub">FastGithub</a>：Github加速神器，通过从公共DNS服务器拿到github的大量ip数据，检测哪些ip可用，来编写一个本地版DNS服务。解决github打不开、用户头像无法加载、releases无法上传下载、git-clone、git-pull、git-push失败等问题（但是有时候在文件上传时，最好关闭该代理）</p><p><a href="https://www.123pan.com/s/nmk9-gv08H">ChromeGo网页科学上网</a>：网页科学上网，必须使用谷歌内核的浏览器（Edge和Chrome亲测可用）</p><p><a href="https://www.123pan.com/s/nmk9-5k08H">小牛、太阳VPN</a>：电脑版的翻墙软件，这里就不细说了，下载后记得关闭防火墙和杀毒软件。再提供<a href="https://www.123pan.com/s/nmk9-qk08H">手机版</a></p><h3 id="快捷操作">快捷操作</h3><p><a href="https://www.u.tools/">uTool</a>：快捷搜索各种软件，Win键功能太简陋，下载这个好多了！！</p><p><a href="https://www.voidtools.com/zh-cn/">Everything</a>：基于名称快速定位文件和文件夹，电脑一出问题，找文件就不会很难受</p><p><a href="https://pooi.moe/QuickLook">QuickLook</a>：在不运行关联程序的情况下，可快速预览文件内容，省下看图软件等，支持安装<a href="https://github.com/QL-Win/QuickLook/wiki/Available-Plugins">插件</a>（空格预览插件，右下角有安装按钮）</p><p><a href="https://efotinis.neocities.org/deskpins/">DeskPins</a>：图钉📌，把软件界面置顶并固定，类似地还有<a href="https://windowtop.info/">Windowtop</a></p><h3 id="桌面整理">桌面整理</h3><p><a href="https://www.coodesker.com/">酷呆桌面</a>：自用最好的桌面整理，整理盒可以套几个小整理盒，完美收纳，功能不用太多。再配合<a href="https://apps.microsoft.com/store/detail/%E6%8B%BE%E5%85%89%E5%A3%81%E7%BA%B8/9N7VHQ989BB7?hl=zh-cn&amp;gl=CN">拾光壁纸</a>，基本的整理和美化需求绝对够了</p><h3 id="截图工具">截图工具</h3><p><a href="https://www.snipaste.com/">Snipaste</a>：推荐，但是不支持长截屏</p><p><a href="https://verycapture.com/cn/index.html">Verycapture</a>：支持长截屏，还支持GIF制作，UI好看使用很舒服，稳定性不大行</p><p><a href="https://getsharex.com/">ShareX</a>：专业级截图工具，功能最全，支持拾色器各种功能，但是长截屏差了点东西</p><p><a href="https://picpick.app/zh/">Picpick</a>：和ShareX类似，使用上比较友好，但是长截图功能不算强大，界面和Word很像，更适合截图编辑人员</p><hr><h2 id="日常必备">日常必备</h2><h3 id="观影网站">观影网站</h3><p><a href="http://www.549.tv/">👍影视森林</a>：强烈建议收藏，国内免费观影网站聚合，博主持续更新并测评</p><p><a href="http://www.996dm.com/">樱花动漫</a>、<a href="http://www.dmdm2020.com/">哆咪动漫</a>：比较常用的动漫网站</p><p><a href="https://guapitv.xyz/">瓜皮TV</a>、<a href="https://www.libvio.me/">LIBVIO</a>：平常自用的高清看片网站</p><h3 id="屏幕护眼">屏幕护眼</h3><p><a href="https://iristech.co/">👍Iris</a>：国外付费软件，可设置多种模式，其中水墨屏真的是让人哇塞💓！这里提供<a href="https://www.123pan.com/s/nmk9-6K88H">免费Iris Pro下载</a></p><p><a href="https://lestore.lenovo.com/detail/L101658"><s>f.lux</s></a>：英文劝退</p><p><a href="https://www.duba.net/dbt/eyes.html?f=sem">猎豹护眼大师</a>：简单的国内护眼软件，带休息提醒功能，偶尔会出bug</p><h3 id="思维导图">思维导图</h3><p><a href="https://www.xmind.cn/">Xmind</a>：全功能的思维导图和头脑风暴软件下面，下面很多软件都支持导入XMind，所以可以保存为xmind格式，然后使用其他平台导出无水印格式</p><p><a href="https://gitmind.cn/">👍Gitmind</a>：在线画图，流程图、脑图都可以绘制，<s>全部免费</s>（最近收费了，有文件数量限制，只能生成十个，不过够用了，想要扩充需购买会员），支持Xmind格式并且能导出很多格式。可以打开网页直接使用Web端，也可以使用公众号直接打开自己的文件</p><p><a href="https://www.zhixi.com/">知犀思维导图</a>：在线画图，UI稍好看，希望永久免费，还有<a href="https://www.liuchengtu.com/">迅捷流程图</a></p><p><a href="https://naotu.baidu.com">百度脑图</a>：简单易用，完全免费，但是模板比较少</p><p><a href="https://zhimap.com/">zhiMap</a>：通过微信可以登陆账号，满足大多数人思维导图需求，交互体验不错</p><p><a href="https://www.processon.com">ProcessOn</a>：全能、专业。普通用户只有 9 个文件存储限制，可付费或邀请好友推广来扩容</p><p><a href="https://flowchart.fun/">Flowchart</a>：输入文本直接生成流程图，和Python类似主要根据空格来实现结构，语法有点像markdown里的Mermaid</p><p><a href="https://excalidraw.com/">Excalidraw</a>：手写风格的绘图软件，适合设计师玩玩</p><h3 id="待办清单">待办清单</h3><p><a href="https://todo.microsoft.com/tasks/">Microsoft To Do</a>：可在微软应用商店安装，推荐</p><p><a href="https://www.shiguangxu.com/home">时光序</a>：基本免费，操作简单，有web端，UI好看</p><p><a href="https://www.dida365.com">滴答清单</a>：多平台同步，功能齐全，但是有收费内容</p><h3 id="格式转换">格式转换</h3><p><a href="http://www.wofficebox.com/">万彩办公大师</a>：小工具百宝箱，还有免安装版，可U盘随身携带</p><p><a href="https://convertio.co/zh/">Convertio</a>：宣传支持任意格式的转换，可喜的是可以把图片转换为AVG矢量图，粘贴不失真（论文必备）</p><p><a href="https://cn.office-converter.com">全能转换</a>：office文件转换工具，比如word转换pdf后，目录仍然保留，并且可以调用NDM多线程下载</p><p><a href="https://www.pdfpai.com/">PDF派</a>/<a href="https://www.addpdf.cn">加加PDF</a>/<a href="https://www.cleverpdf.com/cn">CleverPDF</a>/<a href="https://www.ilovepdf.com/zh-cn">iLovePDF</a>/<a href="https://lightpdf.com/zh/">LightPDF</a>：pdf在线工具</p><p><a href="https://jinaconvert.com/cn/">图片格式转换</a>:图片格式转换工具</p><h3 id="OCR工具">OCR工具</h3><p><a href="https://github.com/AnyListen/tools-ocr">树洞OCR文字识别</a>：（天若OCR文字识别的新版）点击截图（F4），选定区域，然后按<code>Enter</code> 或者 <code>Space</code> 键，或者鼠标左键双击即可确认圈选，会自动OCR文字识别。这里提供<a href="https://www.123pan.com/s/nmk9-Wu88H">1.2.1版本</a></p><p><a href="https://www.123pan.com/s/nmk9-Cu88H">天若OCR文字识别</a>：算是比较常见的OCR工具，肯定还是推荐新版，实现了跨平台</p><p>QQ的OCR工具：可圈可点</p><h3 id="简历制作">简历制作</h3><p><a href="https://www.polebrief.com/index">极简Polebrief</a>/<a href="https://www.jianliben.com/">简历本</a>：免费在线制作简历平台，界面简约，填写完信息后，导出PDF进行打印就好了</p><p><a href="https://www.mujicv.com/">木及简历</a>/<a href="https://resume.mdnice.com/">Markdown简历</a>：将 Markdown文字 和 用户选择的主题模板快速转化不同风格的简历</p><h3 id="在线工具">在线工具</h3><p><a href="https://www.photopea.com/">在线PS</a>/<a href="https://tinypng.com/">在线图片压缩</a>/<a href="http://24mail.chacuo.net/">临时邮箱</a>/<a href="https://www.remove.bg/zh">remove.bg AI抠图</a>/<a href="https://www.gaituya.com/">改图鸭 图片编辑</a></p><h3 id="其他工具">其他工具</h3><p><a href="https://www.soman.com/">搜漫</a>/<a href="http://www.iewoai.com/">vomic</a>：漫画搜索引擎，全网漫画一网打尽</p><p><a href="http://m.fanqianxs.com/">西红柿小说网</a>：平时看小说的网站</p><h2 id="科研必备">科研必备</h2><h3 id="资料搜集">资料搜集</h3><h5 id="网站聚合">网站聚合</h5><p><a href="https://scholar.chongbuluo.com/">虫部落搜索引擎聚合</a>：论文、图书和日常搜索全部包含，在最上面的导航栏进行选择：快搜-日常搜索、学术搜索-论文搜索、图书搜索-图书搜索</p><p><a href="https://mp.weixin.qq.com/s/ElGoNopa2ftAlNjbl28Zfg">青柠学术干货荟萃</a>：青柠学术博主收纳平时学术用的技巧和小工具，有需要可以关注他公众号，推荐！！</p><h5 id="论文检索">论文检索</h5><p><a href="https://www.cnki.net/">中国知网</a>：没办法，中国就这个呗。配合油猴插件<a href="https://greasyfork.org/zh-CN/scripts/390733-%E7%9F%A5%E7%BD%91pdf%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B">知网pdf下载助手</a>，可以不下载caj文件，再用<a href="https://www.123pan.com/s/nmk9-Tu88H">PdgCntEditor</a>插入目录<a href="https://www.jianshu.com/p/9683e7094871">（软件使用教程）</a>。</p><p><a href="https://www.x-mol.com/">X-MOL科学知识平台</a>：搜索英文文献，可开启中文模式，只看摘要，快速查找所需文献，并提供原文下载，配合Sci脚本食用极佳。支持登录，收藏。最完美的是可配合Zetero，直接进行文献管理，科研者必备！</p><p><a href="http://www.4243.net/">大木虫</a>/<a href="https://gfsoso.99lb.net/">谷粉学术</a>/<a href="http://sci.xueshuwu.cn/#opennewwindow">学术屋</a>/<a href="https://ac.scmor.com/">思谋学术导航</a>：一些出名的学术导航。一般我都使用Zotero配合X-mol检索和自动下载论文插件</p><p><a href="https://www.library.ac.cn/">常用镜像站</a>：更新一些谷歌搜索、谷歌学术、维普、GitHub等镜像站</p><h5 id="找专利">找专利</h5><p><a href="http://www.innojoy.com/search/home.html">大为专利搜索引擎</a>：收费，高校都有采购，不过下载次数有限制，可用于专利搜索</p><p><a href="https://www.drugfuture.com/cnpat/cn_patent.asp">中国专利全文打包下载</a>：搜索到对应专利可以使用该网站进行免费下载</p><h5 id="找图书">找图书</h5><p><a href="https://xmsoushu.com/#/">熊猫搜索</a>：图书资源聚合，收纳了很多搜索引擎，比如鸠摩搜索、快搜猫…</p><p><a href="https://zh.usa1lib.org/">数字图书馆 </a>：全球最大图书馆Z-Library项目的部分，不用翻墙，使用很舒服！👍推荐！</p><p><a href="https://www.shuzhou.cc/">书舟搜索</a>：网站已收录了超过三十万的数据，几乎收录了电子书下载网站的所有内容，一站搜索即可获取全网内容</p><p><a href="https://www.pdfdrive.com/">PDF Drive</a>：免费，需注册，有大量英文原版pdf资源，只支持英文搜索</p><p><a href="http://en.bookfi.net/">Bookfi</a>：世界上最受欢迎的多语言在线图书馆之一，完全免费</p><p><a href="http://libgen.is/">Library Genesis</a>：外文书籍大多可以在这找到，需科学上网</p><h5 id="找术语">找术语</h5><p><a href="https://www.termonline.cn/index">术语在线</a>：全国科学技术名词审定委员会发布的术语平台</p><p><a href="http://www.onedict.com/">一本字典</a>：在海量科技材料、专利信息、学术论文数据中查到所需的翻译</p><p><a href="https://h.bkzx.cn/">中国大百科全书数据库</a>：如其名，大百科全书的数据库</p><p><a href="https://shuyu.cnki.net/#/">中国规范术语</a>：知网百科，中国知网整理的百科</p><h5 id="找行业标准">找行业标准</h5><p><a href="https://www.164580.com/">易紧通</a>：紧固件的搜索和购买，并附上行业标准</p><p><a href="http://std.samr.gov.cn/">全国标准信息公共服务平台</a>:查一些国家标准</p><h5 id="文献-资源管理">文献/资源管理</h5><p><a href="https://www.zotero.org/">Zetero</a>：基本实现Endnote所有功能，无需破解。并可以搭配<a href="https://zhuanlan.zhihu.com/p/112141757">SCI-hub自动下载到本地</a>、<a href="https://mp.weixin.qq.com/s/AjvNBM4B_B5eKjL8Az6XRA">TeraCloud云同步</a>、<a href="https://zhuanlan.zhihu.com/p/62396113">GB/T7714 理工科引用样式</a>配合使用。目前推荐使用<a href="https://www.zotero.org/support/dev_builds">内测版</a>，稳定版没内置pdf浏览器（更多使用可以参考<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319074508795641857&amp;__biz=MzAxNzgyMDg0MQ==&amp;scene=21#wechat_redirect">青柠学术Zotero专栏</a>）</p><h3 id="论文攥写">论文攥写</h3><h5 id="公式编辑">公式编辑</h5><p><a href="https://www.latexlive.com/home">LaTeXlive</a>：在线Latex公式编辑器</p><p><a href="https://latex.codecogs.com/eqneditor/editor.php">Codecogs</a>：和Latexlive一样，UI稍微丑了一些</p><p><a href="https://www.aliyundrive.com/s/MzvRbJPt55j">MathType</a>：公式编辑器</p><h5 id="科研绘图">科研绘图</h5><p>OriginLab：科研作图必备，可使用教育邮箱<a href="https://my.originlab.com/forum/topic.asp?TOPIC_ID=22328">申请</a></p><p><a href="https://labplot.kde.org/">labplot</a>：可以直接进入微软商店<a href="https://www.microsoft.com/en-us/p/labplot/9ngxfc68925l#activetab=pivot:overviewtab">下载</a>，和Origin蛮像，推荐使用Origin发文</p><p><a href="https://www.diagrams.net/">draw.io</a>：免费画图，Web端右上角可改成中文模式。支持粘贴<a href="https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a">阿里矢量素材</a>。<a href="https://gitmind.cn/">Gitmind</a>和它类似，但是没法粘贴素材</p><p><a href="https://www.freedgo.com/">freedgo在线绘图</a>：和draw.io类似，功能更全，但是存在收费内容</p><p>Visio：微软工具，可在<a href="https://otp.landian.vip/zh-cn/">Office tool</a>中勾选，还是比较稳定的</p><p><a href="https://www.processon.com/"><s>ProcessOn</s></a>：免费版容量不多，很多功能只能充值</p><h5 id="图片处理">图片处理</h5><p><a href="https://bigjpg.com/zh">AI人工智能图片放大</a>：使用最新人工智能深度学习技术——深度卷积神经网络。它会将噪点和锯齿的部分进行补充，实现图片的无损放大</p><p><a href="https://convertio.co/zh/">Convertio</a>：宣传支持任意格式的转换，可喜的是可以把图片转换为AVG矢量图，粘贴不失真</p><p><a href="https://www.photopea.com/">在线PS</a>：无需下载PS就能实现PS的一些基础功能</p><h5 id="英语写作模板">英语写作模板</h5><p><a href="https://www.phrasebank.manchester.ac.uk/">Academic Phrasebank</a>：英语写作的词句模板库，网站总共分为6大板块，并且介绍了每个版块在英文中的含义、作用以及常用的写作方式，而且还罗列出许多例句以供参考</p><h5 id="英语语法检查">英语语法检查</h5><p><a href="https://hemingwayapp.com/">Hemingway</a>：使用很简单，从默认的&quot;Edit&quot;状态改为&quot;Write&quot;状态，输入要检查语法的内容，输入完成后再切换到&quot;Edit&quot;状态，就会用各种颜色标注出错误，甚至可以判断用词的感情色彩</p><p><a href="https://www.gingersoftware.com/grammarcheck#.VtlJq3H6hqg">Ginger</a>：世界排名第一的语法检查器，准确度很高，能够有效更正文本，还支持edge浏览器和word等</p><p><a href="https://www.nounplus.net/">nounplus</a>：由韩国人开发的英语句子语法检测工具，纠正你英语中的语法问题，Nounplus工具的语法算法主要侧重于语法、句法</p><p><a href="https://virtualwritingtutor.com/">Virtual writing tutor</a>：可以检查语法，标点符号，拼写，释义和词汇等，操作简单</p><p><a href="https://www.grammarly.com/">Grammarly</a>：下载后会出现小悬浮按钮，当电脑上出现语法错误，就会显示有多少处，并给予修改意见，或者使用<a href="https://demo.grammarly.com/">在线版</a></p><p><a href="https://mypitaya.com/?home&amp;bd_source=">火龙果写作</a>：提供从内容生成、素材推荐、修改润色、审核校对、多语言翻译的全流程文字生产力工具，和AI一起，很酷</p><h5 id="翻译">翻译</h5><p><a href="http://www.zhiyunwenxian.cn/">知云文献翻译</a>：英文文献阅读必备</p><p><a href="https://www.deepl.com/translator">DeepL翻译</a>：翻译起来还是比较地道的</p><p><a href="https://copytranslator.github.io/">CopyTranslator</a>：复制即翻译的外文辅助阅读翻译解决方案</p><p><a href="https://fanyi.caiyunapp.com/#/">彩云小译</a>、<a href="https://fanyi.youdao.com/">有道翻译</a>：其他基础的翻译平台</p><h3 id="论文投稿">论文投稿</h3><h5 id="查重">查重</h5><p><a href="https://www.lunwengo.net/">论文狗查重</a>：每天免费查重一篇，免费提供修改</p><p><a href="https://dsa.dayainfo.com/">大雅相似度分析</a>：免费查重要啥自行车</p><h5 id="选刊">选刊</h5><p><a href="https://journalfinder.elsevier.com/">JournalFinder</a>：Elsevier旗下的产品，只需输入论文的标题和摘要，并选择合适的研究领域就能轻松找到最适合发表的期刊</p><p><a href="https://www.edanz.com/journal-selector">Edanz Journal Selector</a>：可以输入论文摘要或者关键词进行选刊</p><p><a href="https://journalsuggester.springer.com/">Journal Suggester Springer</a>：Springer Nature出版社推出的选刊系统，在搜寻期刊时的限定条件比较多和具体</p><p><a href="https://jane.biosemantics.org/">JANE</a>：输入文章题目或摘要进行选刊</p><p><a href="https://www.scimagojr.com/">SCImago Journal Rank</a>：以期刊的综合评价指标进行排名，而不只是传统的影响因子值</p>]]></content>
      
      
      <categories>
          
          <category> 疯狂安利 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公式编辑器</title>
      <link href="/2022/07/1.3MathType/"/>
      <url>/2022/07/1.3MathType/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-2"><center>引子</h2><p>    大家常用的公式编辑器肯定是Mathtype，这里提供Mathtype的安装和使用指南吧！</p><h2 id="安装">安装</h2><p><a href="https://www.123pan.com/s/nmk9-6k08H">MathType</a></p><h2 id="使用">使用</h2><h2 id="常见问题">常见问题</h2><p><a href="https://blog.csdn.net/qq_33612918/article/details/88264289">Word里mathtype公式显示不全的三种解决办法</a></p><p>调整段落，行间距设置为最小值或者单倍行距，具体值随意</p><p>如果不想调整整个文档的结构，则有两种方法</p><p>其一：进入mathtype页面，进入大小&gt;定义，调整字体大小。然而这种方法会缩小公式，显得不是那么好看<br>其二：选中公式，进入页面布局&gt;间距，将增加段前或者段后属性，即可</p>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
          <category> 自用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MathType </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器必备脚本</title>
      <link href="/2022/07/1.2Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2022/07/1.2Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-3"><center>引子</h2><p>    大家使用最多的肯定是浏览器，而浏览器现在也能完成很多功能，尤其是装上了一些脚本，所以在这里也是想分享一下自己觉得好用的脚本。浏览器推荐使用Edge和Chrome，因为很多Web开发者现在都先在这上面调试，其他浏览器可能会有一些Bug。</p><p>这里推荐使用一些插件站去下载</p><p><a href="https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home?hl=zh-CN">Edge扩展库</a>：Edge浏览器自的带扩展站</p><p><a href="https://crxsoso.com/">Crx搜搜</a>/<a href="https://chrome.zzzmh.cn/#/index">极简插件</a>：浏览器插件收纳站</p><h2 id="插件安装">插件安装</h2><p>点击安装</p><p>使用Crx文件安装</p><p>可能碰到的问题</p><h2 id="推荐插件">推荐插件</h2><p><a href="https://chrome.zzzmh.cn/info?token=jinjaccalgkegednnccohejagnlnfdag">暴力猴</a>：个人觉得比油猴好用，Edge浏览器插件里就可以<a href="https://microsoftedge.microsoft.com/addons/detail/%E6%9A%B4%E5%8A%9B%E7%8C%B4/eeagobfjdenkkddmbclomhiblgggliao">下载</a>，安装后可以去<a href="https://greasyfork.org/zh-CN">Greasy Fork</a>安装JS脚本，可玩性很高</p><p><a href="https://microsoftedge.microsoft.com/addons/detail/easyscholar/bpepicgagmdchlkjjeeiekpoafehpagm">easyScholar</a>：显示会议、期刊等级，科研云盘以及在线翻译功能</p><p>SuperCopy 超级复制</p><p>扩展管理器（Extension Manager）</p><p>暴力猴</p><p>Listen 1</p>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
          <category> 自用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Edge浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程自学指南</title>
      <link href="/2022/02/4.2%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/"/>
      <url>/2022/02/4.2%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-5"><center>引子</h2><p>    👋这里是Visen.蛮多人问我如何自学编程，这里提供一篇文章，点出自身学习编程的步骤，也希望大家给予宝贵意见！</p><p>我的学习思路是</p><ol><li>计算机基础：从计算机导论开始，对整体有把握！然后学习计算机学科的基础知识，补齐专业知识</li><li>学习路线：了解想要从事方向的学习路线</li><li>分类学习：对自己方向进行分类学习，按照学习路线完善自己技术栈</li><li>掌握工具：掌握必备工具，比如Git、IDE等</li></ol><hr><h2 id="综合网站">综合网站</h2><p><a href="https://veal98.gitee.io/cs-wiki/#/README">CS-WIKI</a>：记录博主的学习之路，还是很贴合实际的，博主还总结后开发了<a href="https://veal98.github.io/LeetCode-Offer/">Leetcode-Offer刷题网站</a>！实在大佬。类似的还有<a href="https://szufrank.top/#/README">菜饼同学</a></p><p><a href="https://www.runoob.com/">菜鸟教程</a>：站长<a href="https://www.zhihu.com/people/runoob">Runoob</a>一个人维护的网站，将大家的知识整理成笔记。导航栏的在线菜鸟工具也很不错。类似的还有<a href="https://www.w3school.com.cn/index.html">W3school</a>/<a href="https://www.w3cschool.cn/">W3Cschool</a>/<a href="http://c.biancheng.net/">C语言中文网</a></p><p><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md">自学计算机科学</a>：对 <a href="https://teachyourselfcs.com/">TeachYourselfCS</a> 内容的中文翻译，可以借助建议的教材或者视频课程来自学计算机科学</p><p><a href="https://www.liaoxuefeng.com/">廖雪峰的网站</a>：廖雪峰的Git教程是必须看看的！</p><p><a href="https://www.programschool.com/">编程学院</a>：简单注册后，可以左侧侧边栏展示教程，配合右侧在线Vscode编程，一步步教学，免费版用户的使用时长就够用了</p><p><a href="https://www.coursera.org/">Coursera</a>：与‎<strong>‎200多所领先的大学‎</strong>‎和公司合作，为全球的个人和组织提供在线学习，这里的一些计算机课程很推荐，比如北大的计算机组成，斯坦福大学的机器学习等</p><p><a href="https://www.r2coding.com/#/">编程自学之路</a>：整理收录几个大方向（岗位）的学习路线和知识点大梳理</p><p><a href="https://www.iamshuaidi.com/">帅地玩编程</a>：面向工作，更新一些学习资源和大厂面经</p><p><a href="https://www.jb51.net/">脚本之家</a>：专业的收藏整理多类脚本学习资料的个人网站，可以搜索书籍和教程</p><p><a href="https://www.dotcpp.com/course/">C语言网</a>：网站更新的内容以C、C++语言来玩单片机的教程，简单实用</p><p><a href="https://www.php.cn/">PHP中文网</a>：不只是PHP学习，里面还有很多其他语言教程和在线工具</p><p><a href="https://markerhub.com/">Markerhub</a>：梳理Java知识、解析开源项目，内容以项目为主</p><h2 id="计算机基础">计算机基础</h2><p><strong>数学基础</strong>：《线性代数》、《离散数学及其应用》</p><p><strong>计算机入门知识</strong>：《计算机科学导论》</p><p><strong>计算机组成</strong>：<a href="https://www.coursera.org/learn/jisuanji-zucheng/home/welcome">计算机组成 北大</a></p><p><strong>计算机网络</strong>：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=1">计算机网络微课堂</a></p><p><strong>操作系统</strong></p><p><strong>数据结构及算法</strong>：</p><ul><li>《大话数据结构》</li><li>《图解算法》</li><li><a href="https://cswiki.top/">CS-Wiki</a>：里面包含了很多知识，基本可以按照这个入门。然后还提供循序渐进地刷leetcode题的平台，理论和实践配合，非常nice。配合<a href="https://codetop.cc/home">CodeTop</a>企业题库，完美!</li><li><a href="https://leetcode-cn.com/">力扣leetcode</a>：leetcode永远滴神，但是题目量太多，失去专一性，解答可以看题解或者<a href="https://github.com/grandyang/leetcode/blob/master/README-CN.md">Leetcode All in one</a></li><li><a href="https://visualgo.net/zh">visualgo</a>：数据结构和算法动态可视化网站，支持中文，支持对算法的详细说明和讲解，还可以查看算法的执行过程</li><li><a href="https://github.com/MisterBooo/LeetCodeAnimation">LeetCodeAnimation</a>：博主致力于将 LeetCode 上所有的题目都用动画的形式演示出来，计划用3到4年时间去完成它（哎，目前进度感人）</li><li><a href="https://algorithm-visualizer.org/">algorithm-visualizer</a>：算法可视化网站，支持Java、JS、C++等多种语言，执行过程和速度可控制，还能暂停播放，在控制台也能看到算法执行输出的中间结果</li></ul><p><strong>数据库系统</strong></p><h2 id="学习路线">学习路线</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzkwOTE2OTY1Nw==&amp;mid=2247488453&amp;idx=1&amp;sn=3f0130bc0023e8aec9776d5b559c8278&amp;chksm=c13f9553f6481c45288a3cc28a4f899498f11fc23c9a80432c679fe4f2bb2547247af2ac009b&amp;mpshare=1&amp;scene=1&amp;srcid=1222Nxdz9eayKqfYXx1NI4mp&amp;sharer_sharetime=1608600133782&amp;sharer_shareid=923e2ca13b94fb37b5e934fd379ea5a7&amp;key=7e71c072312859fdd72cda61cff8e039709540f41018778aad3a645372cfcef7da15aa686f16596d64ab1dad3221a7038aebaa5f4a4ddd130f99e9de20b4861297225d74bbbd2c9f4602517d110a91e4392b9276079b4a3ee44dc8b152769d4c8178cf13293ca76667cf0773fc676722214a8c76aff49310574e52011df0dbc8&amp;ascene=1&amp;uin=MTQ0NzQyNzc2OA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090538&amp;lang=zh_CN&amp;exportkey=ASgkUNYTH1V0AJtD50ismA8%3D&amp;pass_ticket=nwkycQGTJ8ple3lfhpOF1mdueeKvtKsN3MiY90BGZI8wp6Cb1%2Bufx02XuN0GtpAp&amp;wx_header=0">C++ 后台开发路线 2020</a></p><p><a href="https://www.cnblogs.com/qianguyihao/p/8776837.html">Web前端入门自学路线 2021</a></p><p><a href="https://www.cnblogs.com/qianduanpiaoge/articles/13831380.html">前端开发从入门到进阶完全指南</a></p><h2 id="分类学习">分类学习</h2><h3 id="前端">前端</h3><p><a href="https://web.qianguyihao.com/">千古前端图文教程</a>：不用去自己整理学习路线，只管学习就好，可以关注<a href="https://www.cnblogs.com/qianguyihao/">千古壹号博客园</a></p><p><a href="https://github.com/JacksonTian/fks">Frontend Knowledge Structure</a>：作者根据前端知识结构图，更新前端开发知识结构，非常细致</p><p><a href="https://github.com/haizlin/fe-interview">前端知识每日3+1</a>/<a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Question">前端开发面试题</a>：以面试题驱动学习，更新前端面试题</p><p><a href="https://github.com/luffyZh/offer-javascript">Offer-Javascript</a>/<a href="https://www.nowcoder.com/discuss/49349">剑指 offer–JavaScript 版</a>/<a href="https://blog.csdn.net/owen1190/category_9269623_2.html">Javascript版 剑指offer</a>：剑指offer编程题–JavaScript版本</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn">Web开发入门</a>：MDN的Web开发教程，为 Web 开发的纯粹初学者提供一切开始编写简单网站所需的知识</p><h3 id="后端">后端</h3><p>Java</p><p>PHP</p><h3 id="客户端">客户端</h3><p>Net平台</p><p>QT</p><p>PyQt</p><p><a href="http://www.electronjs.org/">Electron</a></p><h2 id="辅助网站">辅助网站</h2><h3 id="计算机书籍">计算机书籍</h3><p><a href="https://www.jb51.net/">脚本之家</a>：专业的收藏整理多类脚本学习资料的个人网站</p><p><a href="https://www.xz577.com/">码农之家</a>：给程序员和编程爱好者分享计算机编程电子书以及相关的学习资源和技术文章</p><p><a href="https://github.com/niudai/How-to-be-a-good-programmer">How-to-be-a-good-programmer</a>/<a href="https://github.com/iamshuaidi/CS-Book">CS-Book</a>/<a href="https://github.com/Hacker233/free-programming-books-zh_CN">free-programming-books-zh_CN</a>:Github上比较好用的一些书籍分享项目</p><p><a href="http://www.banshujiang.cn/">搬书匠</a>：更新的是原版计算机类的书籍</p><h3 id="其他学习">其他学习</h3><p><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解Git</a>：图解git中的最常用命令</p><p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式</a>：使用图形和代码结合的方式来解析设计模式</p><p><a href="https://www.1keydata.com/cn/sql/">SQL语句教程</a>：网站列出及解释常用指令的语法，然后用例子让读者了解如何运用该指令</p><p><a href="https://learngitbranching.js.org/?locale=zh_CN">Learning Git Branching</a>：在沙盒里执行相应的Git命令，还能看到每个命令的执行情况，学习Git最佳方式</p><p><a href="https://vim-adventures.com/">Vim-adventures</a>：游戏般学习Vim</p><h3 id="常用工具">常用工具</h3><p><a href="https://unbug.github.io/codelf/">CodeIF</a>：输入想命名的变量名，帮你选择英文变量名，避免无意义的中文变量名</p><p><a href="https://kaifa.baidu.com/">开发者搜索</a>：把百度搜索的内容过滤，筛选出和开发有关的答案</p><p><a href="https://pythontutor.com/#mode=edit">代码运行可视化</a>：可以编写Python，Java，C，C++，JavaScript和Ruby代码，并逐步查看其执行可视化，了解计算机运行每行代码时会发生什么</p><p><a href="https://jsoneditoronline.org/">‎JSON Editor Online</a>：用于查看、编辑 JSON 并设置其格式的工具</p><p><a href="http://css.doyoe.com/">CSS参考手册</a>：提供CSS语法速查表，并提供chm版下载</p><p><a href="http://semi.design/zh-CN/">Semi Design</a>：抖音系的企业应用设计系统，设计语言、React 组件、主题等开箱即用的中后台解决方案</p>]]></content>
      
      
      <categories>
          
          <category> 疯狂安利 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客绑定域名</title>
      <link href="/2022/02/0.3%E5%9F%9F%E5%90%8D/"/>
      <url>/2022/02/0.3%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-center-2"><center>引子</center></h2><p>​ 👋这里是Visen.相信每个博主都希望自己的网站能够分享给大家看，而这一步就需要绑定域名。这里选择了阿里云购买域名，大家当然也可以通过腾讯云，大致过程都是一样的</p><p>本篇内容参考<a href="https://help.aliyun.com/product/35473.html">阿里云 域名帮助中心</a></p><hr><h2 id="购买域名">购买域名</h2><h3 id="创建持有者信息">创建持有者信息</h3><blockquote><p>创建域名持有者信息模板，信息模板就是个人信息的模板，里面有实名信息，后续购买直接勾选该模板</p></blockquote><p>进入<a href="https://wanwang.aliyun.com/domain/">万网（阿里云）</a>，点击右上角的登录，通过支付宝登录并完成注册</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121031373.png" alt="image-20220214121045440"></p><p>点击万网主页导航栏的控制台</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121031752.png" alt="202205050933300"></p><p>在左上角选择域名，进入域名服务</p><p><img src="D:/Downloads/Compressed/BlogImg-main/Blog/202205050933658.png" alt="image-20220214122011647"></p><p>点击信息模板，创建个人信息模板</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032478.png" alt="image-20220214122218668"></p><p>填写基本信息，等待审核通过（两个小时左右）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032939.png" alt="image-20220214122758131"></p><h3 id="挑选域名并购买">挑选域名并购买</h3><p>在万网首页搜索你想取的域名，我填入supervisen进行搜索（.com是世界顶级域名，.cn是中国顶级域名）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032765.png" alt="image-20220214122932683"></p><p><a href="http://xn--ykq29r0whrwaq1cbwbj07dnf9bbii.cn">爱国情怀让我选择了.cn</a>（也有部分因为没钱），加入清单，再进入域名清单进行结算</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032127.png" alt="image-20220214123315533"></p><p>选择购买年限，选择所有者类型为个人并勾选刚才创建的信息模板，确定购买</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032605.png" alt="image-20220214123357335"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121033130.png" alt="img"></p><h2 id="绑定域名">绑定域名</h2><h3 id="获取博客IP地址">获取博客IP地址</h3><p>命令行输入<code>ping 用户名.github.io</code>（不要挂载一些代理，比如FastGithub）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032857.png" alt="image-20220214130932754"></p><p>进入万网的控制台，选择域名服务中的域名列表，选择刚购买的域名，进行解析</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032242.png" alt="image-20220214131151055"></p><p>添加两个解析信息，使superisen.github.io与www.supervisen.cn链接起来（这里显示实名认证审核中，域名处于serverhold状态，此时无法使用）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032015.png" alt="image-20220214131608758"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032145.png" alt="image-20220214134516970"></p><h3 id="创建CNAME文件">创建CNAME文件</h3><p>在本地博客根目录下的source文件夹里，创建一个名为<strong>CNAME</strong>的文件（注意要大写），写上购买的域名</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032401.png" alt="image-20220214132501334"></p><p>进入GitHub中的博客仓库，绑定该域名</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032498.png" alt="image-20220214132839820"></p><h2 id="网站提交给搜索引擎">网站提交给搜索引擎</h2><h3 id="百度">百度</h3><p>百度中输入<code>site:www.supervisen.cn</code>，发现并未收录，点击<code>提交网址</code></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032239.png" alt="image-20220215120008054"></p><p>填入网址，如果出现<code>您无权访问该页面，点击确定按钮返回首页</code>，更换360极速浏览器再试试</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032318.png" alt="image-20220215122026413"></p><p>回到主页<a href="https://ziyuan.baidu.com/">百度搜索引擎平台</a>,进入用户中心的站点管理</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032746.png" alt="image-20220215123531434"></p><p>输入博客域名，勾选博客的站点属性</p><p><img src="https://s2.loli.net/2022/05/05/EsYoVq63ybj7f2Q.png" alt="image-20220215123950940"></p><p>开始第三步的验证网站，有三种验证方法</p><ul><li>文件验证：下载验证文件放置在网站目录</li><li>HTML标签验证：在HTML代码中的head标签中插入元数据</li><li>CNAME验证：使用域名解析</li></ul><p>这里选择第一种，点击下载好验证文件，放入博客的source目录下方（和CNAME文件放一起）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032553.png" alt="image-20220215124436058"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121032652.png" alt="image-20220215124745930"></p><p>更改博客根目录下的_config.yml文件，选择跳过对这个HTML文件的“加工”</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121033644.png" alt="image-20220215130307586"></p><p>博客使用<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>上传到GitHub进行更新</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121033975.png" alt="image-20220215125127293"></p><p>点击确认进行验证文件正常访问，完成验证</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121033222.png" alt="image-20220215125223560"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121033126.png" alt="image-20220215130339322"></p><h3 id="谷歌（没VPN）">谷歌（没VPN）</h3><h2 id="结果展示">结果展示</h2><h3 id="绑定域名-2">绑定域名</h3><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121033906.png" alt="image-20220215113239993"></p><h3 id="搜索引擎收录">搜索引擎收录</h3><p>必应（不用操作就有）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121033028.png" alt="image-20220215115734339"></p><p>百度</p><p>谷歌</p>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NURBS曲线（待整理）</title>
      <link href="/2022/02/5.1NURBS%E6%9B%B2%E7%BA%BF/"/>
      <url>/2022/02/5.1NURBS%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-center-5"><center>引子</center></h2><p>    👋这里是Visen.平时需要和CAGD（计算机辅助几何设计）打交道，这里参考施法中<a href="https://www.123pan.com/s/nmk9-vl88H">《计算机辅助几何设计与非均匀有理B样条 修订版》</a>和<a href="https://www.123pan.com/s/nmk9-vl88H">配套书籍光盘</a>，整理出NURBS曲线编程所需基础知识点和C++编程实例，只为对知识快速上手，而且能理清书籍的脉络，剔除曲面部分。整理不是为了丢掉书，而是为了更好地利用书！</p><hr><h2 id="第一章-曲线和曲面的基本理论">第一章 曲线和曲面的基本理论</h2><h3 id="1-直线的表示方法">1.直线的表示方法</h3><p>动点p是随着某个参数u在规范参数域$u\in[0，1]$内按线性关系运动，则动点p把来直线分为长度比为u:1-u两段</p><p>有 $p=p(u) ,u\in [0,1]$</p><p>则有$p-p_{0}=\frac{u}{1-u}(p_{1}-p)$，$p-p_{0}=u(p_1-p_0)$</p><p>整理可得$p(u)=p_{0}+u(p_{1}-p_{0})$，分析时偏向使用$p(u)=(1-u)p_{0}+up_{1}$</p><h3 id="2-曲线的表示方法">2.曲线的表示方法</h3><p>空间解析几何（参数表示）：动点p的3个坐标$x=x(u),y=y(u),z=z(u)$</p><p>微分几何（一般矢函数表示）：$p(u)=[x(u),y(u),z(u)]$=&gt;$p(u)=x(u)i+y(u)j+z(u)k$(i,j,k为三个方向的3个单位矢量)</p><p>计算机辅助几何设计（基表示）：$p(u)=\sum_{i=0}^{n}\varphi <em>{i}(u) a</em>{i}$，直线表示方法$p(u)=(1-u)p_{0}+up_{1}$算是它的一个最简单的基表示形式</p><p>tips：如果把参数u设置为时间，则p(u)为一质点随时间变化的运动轨迹，一阶导矢和二阶导矢分别代表速度和加速度矢量</p><p>参数连续性：函数曲线具有直到k阶的连续导数，称为是k次可微的，或简称是C^k^的。类似地，参数曲线具有关于参数的直到k阶的连续导矢，也称为是k次可微的，或简称是C^k^的。由于参数曲线的这种可微性与参数有关，故又称之为参数连续性</p><h3 id="3-参数化与参数变换">3.参数化与参数变换</h3><p>参数化的意义在于将u=u(t)，代入到式子中，使得p(u)变成p(t)，但是不合适的参数变换，可能会出现$\frac{du}{dt} =0$或者某个原函数对应多个新参数</p><p>比如弧长参数化，取自身弧长为参数（但是n次参数多项式曲线不能使用），需要选择合适的参数变换</p><hr><h2 id="第二章-参数多项式插值与逼近">第二章 参数多项式插值与逼近</h2><p>构造曲线顺序过给定的数据点称为插值，构造曲线在某种意义上最为接近给定的数据点称为逼近，两者统称为拟合</p><h3 id="1-基函数">1.基函数</h3><p>前一章知道计算机辅助几何设计中采用的是基表示的参数矢函数形式，而需要选择哪一类函数作为基函数？</p><p>这里只介绍多项式基：无穷次可微，曲线曲面足够光滑，且容易计算函数值及各阶导数值[$p(u)=\sum_{i=0}^{n} a_{i}u^i$]</p><p>后续还有有理基函数…</p><h3 id="2-数据点的参数化">2.数据点的参数化</h3><p>节点决定了位于曲线上的这些数据点与其参数域$u\in[u_{0}，u_{n}]$内的相应点之间的一种对应关系，而对一组有序数据点决定一个参数分割，称之为对这组数据点实现参数化。同一组数据点，即使采用同样的插值法，若数据点的参数化不同，将可能获得不同的插值曲线，会呈现出不同的性质。</p><ul><li>均匀参数化（等距参数化）</li><li>积累弦长参数化(<strong>文献显示，该方法完全适合于工程应用</strong>)</li><li>向心参数化</li><li>福利参数化（修正弦长参数化）</li></ul><p>编程实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">功能：对数据点实现参数化</span><br><span class="line">输入参数：m_aVertex-数据点; m_pType-参数化类型，由数据点参数化对话框输入；两者均为受保护成员。</span><br><span class="line">输出参数：m_aU-数据点参数值数组，受保护成员。</span><br><span class="line">调用函数：<span class="built_in">Normalize</span>()-对参数化序列实行规范化；Distance-求两点间距离；InitK-确定福利参数化的修正系数m_k；InitSita-计算弦线夹角的外角。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitU</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m_aU.<span class="built_in">GetSize</span>()&gt;<span class="number">0</span>) m_aU.<span class="built_in">RemoveAll</span>();</span><br><span class="line"><span class="type">int</span> i,n;</span><br><span class="line">n=m_aVertex.<span class="built_in">GetSize</span>();</span><br><span class="line">m_aU.<span class="built_in">Add</span>(<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">switch</span>(m_pType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//规范均匀参数化</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++) m_aU.<span class="built_in">Add</span>(i);</span><br><span class="line"><span class="built_in">Normalize</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//规范弦长参数化</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> temp;</span><br><span class="line">temp=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]);</span><br><span class="line">temp+=m_aU[i<span class="number">-1</span>];</span><br><span class="line">m_aU.<span class="built_in">Add</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Normalize</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//规范向心参数化</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> temp;</span><br><span class="line">temp=<span class="built_in">sqrt</span>(<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]));</span><br><span class="line">temp+=m_aU[i<span class="number">-1</span>];</span><br><span class="line">m_aU.<span class="built_in">Add</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Normalize</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//规范福利参数化</span></span><br><span class="line"><span class="built_in">InitK</span>();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> temp;</span><br><span class="line">temp=m_k[i]*<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]);</span><br><span class="line">temp+=m_aU[i<span class="number">-1</span>];</span><br><span class="line">m_aU.<span class="built_in">Add</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Normalize</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Normalize</span><span class="params">()</span>  <span class="comment">//规范化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="built_in">GetVertexCount</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) m_aU[i]=m_aU[i]/m_aU[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitK</span><span class="params">()</span>  <span class="comment">//初始化修正系数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m_k.<span class="built_in">GetSize</span>()&gt;<span class="number">0</span>) m_k.<span class="built_in">RemoveAll</span>();</span><br><span class="line"><span class="type">double</span> tempk,temp1,temp2,temp3;</span><br><span class="line"><span class="built_in">InitSita</span>();</span><br><span class="line">m_k.<span class="built_in">Add</span>(<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">GetVertexCount</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)  temp1=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">else</span> temp1=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-2</span>],m_aVertex[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(i==<span class="built_in">GetVertexCount</span>()<span class="number">-1</span>)  temp3=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> temp3=<span class="built_in">Distance</span>(m_aVertex[i],m_aVertex[i+<span class="number">1</span>]);</span><br><span class="line">temp2=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]);</span><br><span class="line">tempk=<span class="number">1</span>+<span class="number">1.5</span>*((temp1*m_sita[i<span class="number">-1</span>])/(temp1+temp2)+</span><br><span class="line">(temp3*m_sita[i])/(temp2+temp3));</span><br><span class="line">m_k.<span class="built_in">Add</span>(tempk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSita</span><span class="params">()</span>  <span class="comment">//计算弦线夹角的外角</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m_sita.<span class="built_in">GetSize</span>()&gt;<span class="number">0</span>) m_sita.<span class="built_in">RemoveAll</span>();</span><br><span class="line"><span class="type">double</span> temp,temp1,temp2,temp3;</span><br><span class="line">m_sita.<span class="built_in">Add</span>(<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">GetVertexCount</span>()<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">temp1=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i]);</span><br><span class="line">temp2=<span class="built_in">Distance</span>(m_aVertex[i],m_aVertex[i+<span class="number">1</span>]);</span><br><span class="line">temp3=<span class="built_in">Distance</span>(m_aVertex[i<span class="number">-1</span>],m_aVertex[i+<span class="number">1</span>]);</span><br><span class="line">temp=<span class="built_in">acos</span>((temp1*temp1+temp2*temp2-temp3*temp3)/</span><br><span class="line">(<span class="number">2.0</span>*temp1*temp2));</span><br><span class="line"><span class="keyword">if</span>((PI-temp)&lt;(PI/<span class="number">2.0</span>))  m_sita.<span class="built_in">Add</span>(PI-temp);</span><br><span class="line"><span class="keyword">else</span>  m_sita.<span class="built_in">Add</span>(PI/<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">m_sita.<span class="built_in">Add</span>(<span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述各种对数据点的参数化法都是非规范的，即$[u_{0}，u_{n}]$不等于[0,1]仅$u_{0}=0$。首先需要进行规范参数化使得$[u_{0}，u_{n}]=[0,1]$</p><p>只需要简单处理$ u_{i}=u_{i}/u_{n} $，这样构造的形状相同，取向相同，且点的分布与参数域内点的分布的对应关系都是相同的</p><p>当定义曲线的点不是曲线上的数据点，而是控制顶点时，将遇到另一类参数化问题，后续介绍…</p><h3 id="3-多项式插值曲线">3.多项式插值曲线</h3><p>这里讲解多项式基中，如何对插值曲线方程进行求解</p><p>插值曲线方程：$p(u)=\sum_{j=0}^{n} =<br>\begin{bmatrix}<br>1  &amp; u &amp; … &amp; u^n<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0 \<br>a_1\<br>… \<br>a_n\<br>\end{bmatrix}$</p><p><strong>解法一：</strong></p><p>根据$p(u)=\sum_{j=0}^{n} a_{j}u_i^j=p_i=\begin{bmatrix}<br>1  &amp; u_i &amp; … &amp; u_i^n<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0 \<br>a_1\<br>… \<br>a_n\<br>\end{bmatrix}$，可以得到矩阵运算</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044176.png" alt="image-20220205102645380"></p><p>前面是范德蒙矩阵，非奇异，存在唯一解</p><p><strong>解法二：</strong></p><p>将$p(u)=\sum_{j=0}^{n} a_{j}u_i^j$改写为嵌套乘法的格式：$p(u)=a_0+u(a_1+…+u(a_{n-1}+u(a_n)))$</p><p>为了能同时计算曲线任一处的各阶导矢，可改用如下计算n阶曲线各阶导矢的通用公式</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044452.png" alt="image-20220205103228228"></p><h3 id="4-最小二乘逼近">4.最小二乘逼近</h3><p>如果使用$p(u_k)=\sum_{i=0}^{n}\varphi <em>{i}(u_k) a</em>{i}=p_k$</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044756.png" alt="image-20220205191556813"></p><p>方程组是超定的/矛盾方程组，解不存在，只能使用逼近，可以使得曲线点和数据点的距离平方和达到最小，称为最小二乘法逼近</p><hr><h2 id="第三章-参数样条曲线曲面">第三章 参数样条曲线曲面</h2><p>这里主要记录参数三次样条曲线</p><h3 id="1-参数连续性">1.参数连续性</h3><p>光滑程度可以对其变量的可微性来度量，一函数y=y(x)在某一点$x_0$处具有相等的直到k阶的左右导数，则称它在$x_0$处是k次连续可微的，或称它在$x_0$处是k阶连续，记作$C^k$。</p><h3 id="2-三切矢方程">2.三切矢方程</h3><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044548.png" alt="image-20220205193327878"></p><h3 id="3-边界条件">3.边界条件</h3><p>对于开曲线及首末端虽封闭但不要求整体$C^2$的情况，必须再给出两个附加方程，才有可能唯一定解，这两个附加方程通常由两端点处的约束条件提供，称为边界条件或端点条件</p><p>边界条件类型：</p><ul><li>切矢条件：首末端切矢</li><li>自由端点条件：在端点不受力矩作用</li><li>虚节点条件</li><li>抛物线条件：首末段为抛物线，即各具有常矢量的二阶导矢</li><li>“非节点”条件：使首末各两段分别为同一参数三次多项式</li></ul><h3 id="4-定义的参数三次样条曲线">4.定义的参数三次样条曲线</h3><p>联立三切矢方程与边界条件所确立的两个附加方程，就可以得到含n+1个未知切矢的由n+1个矢量方程组成的线性方程组，写出矩阵形式为</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044066.png" alt="image-20220205193542701"></p><p>其系数矩阵为标准的三对角方阵，因主对角元素占优，该系数矩阵是非奇异的，存在唯一解。这种标准的三对角度方程组可采用所谓“追赶法”的高斯消元法求解。</p><p>具体过程是先自上而下把下对角元素消为零，称为追，然后求出$\vec{p_n} $，再回代求出其余全部未知切矢，即所谓“赶”。</p><p>编程实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">功能：求解参数三次样条曲线在数据点（即分段连接点）处未知切矢的三对角线性方程组。</span><br><span class="line">输入参数：dia-存三对角系数矩阵的三对角元素，其中第二维<span class="number">0</span>、１ 、２依次为一行中下对角、主对角和上对角元素：n-矩阵有从第０行到第n行共n+<span class="number">1</span>行；k-维数；t-线性方程组右端列阵中n+<span class="number">1</span>个k维矢量；iflag-选择码，当多次调用本子程序时，若系数矩阵保持不变，则输入iflag一个非零整数，否则输入整数零。</span><br><span class="line">输出参数：t-n+<span class="number">1</span>个数据点处的切矢。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tridia</span><span class="params">(<span class="type">int</span> n,intk,</span></span></span><br><span class="line"><span class="params"><span class="function">    CArray&lt;CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;,CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&amp;&gt;&amp;dia，</span></span></span><br><span class="line"><span class="params"><span class="function">    CArray&lt;CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;,CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&amp;&gt;&amp;t,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> iflag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(iflag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">dia[i][<span class="number">0</span>]=-(dia[i][<span class="number">0</span>]/dia[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">dia[i][<span class="number">1</span>]=dia[i][<span class="number">1</span>]+dia[i<span class="number">-1</span>][<span class="number">2</span>]*dia[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lk=<span class="number">0</span>;lk&lt;k;lk++)</span><br><span class="line">t[i][lk]=t[i][lk]+t[i<span class="number">-1</span>][lk]*dia[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lk=<span class="number">0</span>;lk&lt;k;lk++)</span><br><span class="line">t[n][lk]=t[n][lk]/dia[n][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">for</span>(lk=<span class="number">0</span>;lk&lt;k;lk++)</span><br><span class="line">t[i][lk]=(t[i][lk]-dia[i][<span class="number">2</span>]*t[i+<span class="number">1</span>][lk])/dia[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-计算插值">5.计算插值</h3><p>这里介绍曲线所要求解的曲线上各种信息的计算：给定已经定义的参数三次样条曲线，计算曲线上各点及其各阶段导矢</p><h4 id="判断参数所在的节点区间">判断参数所在的节点区间</h4><p>$u_i\le u\le u_i+1$，即确定区间指标i（曲线的段指标/第几段），取该节点区间左端节点的下标</p><h4 id="选用相应的曲线段表达式">选用相应的曲线段表达式</h4><p>先将曲线变成分段格式：</p><p>首先得确定参数三次样条曲线的类型</p><p>基表示形式有埃尔米特形式、幂基形式、基样条形式、B样条形式</p><p>参数化方法有均匀参数化、积累弦长参数化、向心参数化、修正弦长参数化</p><p>（这里介绍的是$C^1$分段三次埃尔米特插值）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044972.png" alt="image-20220209105129174"></p><p>然而实际问题只给出数据点，比较少给出数据点处得切矢，这时候要求构造一条$C^1$分段三次多项式曲线插值于这些数据点</p><p>可以采用以下方法确定数据点处的切矢</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121044908.png" alt="image-20220209105701342" style="zoom:110%;" /><p>为了实际编程节省计算量，需要将式（4.1）改写形式</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045155.png" alt="image-20220209111034067"  /><h4 id="程序实例">程序实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">功能：计算参数三次样条曲线段上一点处j 阶导矢，若j=<span class="number">0</span>，即为曲线上点。</span><br><span class="line">输入参数：m_aVertex-数据点，受保护成员；i-曲线段所在节点区间左端点下标；u-曲线参数；j-导矢的阶数（若求点，则输入j =<span class="number">0</span>）。</span><br><span class="line">输出参数：p-j阶导矢。若j=<span class="number">0</span>，则为曲线上的点。</span><br><span class="line">调用函数：GetCubicCuvValue -由（<span class="number">4.8</span>）式计算导矢值。</span><br><span class="line">注：该函数不能计算内节点处的左导矢。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">GetSplineDerivat</span>(<span class="type">int</span> i,<span class="type">double</span> u,<span class="type">int</span> j, CPoint &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n=m_aVertex.<span class="built_in">GetSize</span>();</span><br><span class="line"><span class="type">double</span> u1=u;</span><br><span class="line">CDoubleArray tx;</span><br><span class="line">CDoubleArray ty;</span><br><span class="line">tx.<span class="built_in">SetSize</span>(<span class="number">4</span>);</span><br><span class="line">ty.<span class="built_in">SetSize</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">/*以下8行语句计算（4.7）式左端列阵四个系数矢量*/</span></span><br><span class="line">tx[<span class="number">0</span>]=m_aVertex[i].x;</span><br><span class="line">tx[<span class="number">1</span>]=m_Cx[i];</span><br><span class="line">ty[<span class="number">0</span>]=m_aVertex[i].y;</span><br><span class="line">ty[<span class="number">1</span>]=m_Cy[i];</span><br><span class="line">tx[<span class="number">2</span>]=<span class="number">2</span>/delta[i]*(<span class="number">3</span>/delta[i]*(m_aVertex[i+<span class="number">1</span>].x-tx[<span class="number">0</span>])<span class="number">-2</span>*tx[<span class="number">1</span>]-m_Cx[i+<span class="number">1</span>]);</span><br><span class="line">ty[<span class="number">2</span>]=<span class="number">2</span>/delta[i]*(<span class="number">3</span>/delta[i]*(m_aVertex[i+<span class="number">1</span>].y-ty[<span class="number">0</span>])<span class="number">-2</span>*ty[<span class="number">1</span>]-m_Cy[i+<span class="number">1</span>]);</span><br><span class="line">tx[<span class="number">3</span>]=<span class="number">6</span>/delta[i]/delta[i]*(<span class="number">-2</span>/delta[i]*(m_aVertex[i+<span class="number">1</span>].x-tx[<span class="number">0</span>])+tx[<span class="number">1</span>]+m_Cx[i+<span class="number">1</span>]);</span><br><span class="line">ty[<span class="number">3</span>]=<span class="number">6</span>/delta[i]/delta[i]*(<span class="number">-2</span>/delta[i]*(m_aVertex[i+<span class="number">1</span>].y-ty[<span class="number">0</span>])+ty[<span class="number">1</span>]+m_Cy[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">GetCubicCuvValue</span> (i,tx,ty,u1,j,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetCubicCuvValue</span><span class="params">(<span class="type">int</span> i,CDoubleArray &amp;tx, CDoubleArray &amp;ty, <span class="type">double</span> u,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">int</span> j, CPoint &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> pjx=<span class="number">0</span>,pjy=<span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> du=u-m_aU[i];</span><br><span class="line">nt fj=<span class="number">4</span>-j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">3</span>;k&gt;=j;k--)</span><br><span class="line">&#123;</span><br><span class="line">pjx=(pjx/fj)*du+tx[k];</span><br><span class="line">pjy=(pjy/fj)*du+ty[k];</span><br><span class="line">fj=fj<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">p.x=(<span class="type">int</span>)pjx;</span><br><span class="line">p.y=(<span class="type">int</span>)pjy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-光顺性（光滑顺眼）">6.光顺性（光滑顺眼）</h3><p>判断准则：二阶几何连续（位置、切线方向与曲率矢连续，记$G^2$）、不存在奇点与多余拐点、曲率变化较小、应变能较小</p><p>如何处理光顺性：见书本</p><hr><h2 id="第四章-贝齐尔bezier曲线">第四章 贝齐尔bezier曲线</h2><p>贝齐尔曲线是参数多项式曲线，不同的是它采用了不同的一组独特的多项式基函数，使得它有了很多优良的性质。NURBS曲线就是从B样条曲线继承而来，而B样条是从贝齐尔曲线继承而来。</p><h3 id="1-贝齐尔曲线方程及其性质">1.贝齐尔曲线方程及其性质</h3><p>定义式：</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045848.png" alt="image-20220209133039537"></p><p>贝齐尔曲线的定义基础是抛物线的<strong>三切线定理</strong></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045529.png" alt="image-20220209133338016"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045516.png" alt="image-20220210103322513"></p><p>于是，可以通过德卡斯特里奥递推算法来推算出控制顶点，这一算法重要特点就是几何直观，甚至可以通过简单的几何作图实现</p><p><img src="https://s2.loli.net/2022/02/09/Lt3wERqsVF4WJia.png" alt="image-20220209133824132"></p><h3 id="2-贝齐尔曲线导矢">2.贝齐尔曲线导矢</h3><p>一阶导矢可以按照</p><h4 id="公式计算">公式计算</h4><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045003.png" alt="image-20220210103621221" style="zoom:150%;" /><h4 id="编程实例">编程实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">功能：deCasteliau算法计算n次贝齐尔曲线<span class="built_in">p</span>(t)参数为t那点处的jd阶导矢pt，若jd=<span class="number">0</span>,pt=<span class="built_in">p</span>(t)。</span><br><span class="line">输入参数： n-顶点数减<span class="number">1</span>即次数；m_aVertex-控制顶点，为受保护成员；t-参数值；jd-导矢阶数(若求曲线上的点，输入jd＝０)。</span><br><span class="line">输出参数：pt-曲线上参数为t的点(当jd＝<span class="number">0</span>)或jd阶导矢(当jd≥１)。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">GetBezierCuvDerivat</span>(<span class="type">int</span> n,<span class="type">int</span> jd,<span class="type">double</span> t,CPoint &amp;pt)</span><br><span class="line">&#123;</span><br><span class="line">CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; TemVertex_x;</span><br><span class="line">CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; TemVertex_y;</span><br><span class="line">TemVertex_x.<span class="built_in">SetSize</span>(n+<span class="number">1</span>);</span><br><span class="line">TemVertex_y.<span class="built_in">SetSize</span>(n+<span class="number">1</span>);</span><br><span class="line">pt.x=<span class="number">0</span>;</span><br><span class="line">pt.y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(jd&gt;n) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(n&gt;=<span class="number">0</span>&amp;&amp;jd&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i0=<span class="number">0</span>;i0&lt;=n;i0++)</span><br><span class="line">&#123;</span><br><span class="line">TemVertex_x[i0]=m_aVertex[i0].x;</span><br><span class="line">TemVertex_y[i0]=m_aVertex[i0].y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">1</span>;i1&lt;=n-jd;i1++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i1;j++)</span><br><span class="line">&#123;</span><br><span class="line">TemVertex_x[j]=TemVertex_x[j]+t*(TemVertex_x[j+<span class="number">1</span>]-TemVertex_x [j]; </span><br><span class="line">TemVertex_y[j]=TemVertex_y[j]+t*(TemVertex_y[j+<span class="number">1</span>]-TemVertex_y[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> njd=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(jd!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> ll=<span class="number">1</span>;ll&lt;=jd;ll++)</span><br><span class="line">&#123;</span><br><span class="line">njd=njd*(n-ll+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=jd-ll;j++)</span><br><span class="line">&#123;</span><br><span class="line">TemVertex_x[j]=TemVertex_x[j+<span class="number">1</span>]-TemVertex_x[j];</span><br><span class="line">TemVertex_y[j]=TemVertex_y[j+<span class="number">1</span>]-TemVertex_y[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pt.x=<span class="built_in">int</span>(njd*TemVertex_x[<span class="number">0</span>]);</span><br><span class="line">pt.y=<span class="built_in">int</span>(njd*TemVertex_y[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-贝齐尔曲线的升阶与降阶">3.贝齐尔曲线的升阶与降阶</h3><p>这里说n次贝齐尔曲线，其次数n是指曲线在伯恩斯坦基表示中的伯恩斯坦基函数的最高次数，它也等于最后那个控制顶点的下标值。人们称该次数为名义次数。</p><p>​相对而言，贝齐尔曲线还有<strong>真实次数</strong>。将贝齐尔曲线的伯恩斯坦基表示转换成幂基表示，则按幂次升序排列，加权于最后那个非零系数矢量的那个具有最高次数的单项式函数的次数就是该贝齐尔曲线的真实次数。名义次数可能等于或高于真实次数。</p><p>​保持贝齐尔曲线的形状与定向不变，增加定义它的控制顶点数，也即增加它的名义次数，那么，怎样从原控制顶点求出新控制顶点，就是贝齐尔曲线的升阶问题</p><h4 id="升阶">升阶</h4><p>升阶能降低刚性，增加柔性，增加控制顶点，就增加了对曲线进行形状控制的潜在灵活性。虽然增加了控制顶点个数，但是曲线形状及定向保持不变，所以曲线的真实次数不变</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045804.png" alt="image-20220211161922403"></p><h4 id="降阶（略）">降阶（略）</h4><h3 id="4-贝齐尔曲线的矩阵形式">4.贝齐尔曲线的矩阵形式</h3><p>从这里可以知道NURBS曲线的矩阵表示形式以及运算方法</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045739.png" alt="image-20220211162920640"></p><h2 id="第五章-B样条曲线曲面的基本理论">第五章 B样条曲线曲面的基本理论</h2><h3 id="1-B样条与B样条曲线的基本概念">1.B样条与B样条曲线的基本概念</h3><p>B样条方法是在保留贝齐尔方法的优点的同时，克服了其由于整体表示带来不具有局部性质的缺点，以及解决在描述复杂形状时带来的连接问题下提出来的。为了保留贝齐尔方法的优点，仍采用控制顶点定义曲线。为了能描述复杂形状和具有局部性质，改用另一套特殊的基函数即B样条基函数</p><p>于是，B样条曲线方程可写为</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121045688.png" alt="image-20220211170829844" style="zoom:120%;" /><h3 id="2-B样条的递推定义及其性质">2.B样条的递推定义及其性质</h3><p>这里只介绍作为标准算法的德布尔-考克斯的递推定义公式</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046322.png" alt="image-20220212104917129"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046404.png" alt="image-20220212104949959"></p><p>如何使用可以看书</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046372.png" alt="image-20220212112247397" style="zoom:150%;" /><h4 id="编程实例-2">编程实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//功能: 根据参数u值和次数k与节点矢量，计算第i个k次B样条基函数。</span></span><br><span class="line"><span class="comment">//输入参数: u-参数值；k-次数；i-第i个k次B样条的支承区间左端节点下标；m_aNode-节点矢量双精度数组，受保护成员。</span></span><br><span class="line"><span class="comment">//输出参数: 返回函数值。</span></span><br><span class="line"><span class="comment">//调用函数: 递归调用自身。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">GetBaseFunVal</span><span class="params">(<span class="type">double</span> u,<span class="type">int</span> i,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> Val=<span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> val1=<span class="number">0.</span>;</span><br><span class="line"><span class="type">double</span> val2=<span class="number">0.</span>;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(u&lt;m_aNode[i]||u&gt;m_aNode[i+<span class="number">1</span>]) <span class="keyword">return</span> Val;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Val=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">return</span> Val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(u&lt;m_aNode[i]||u&gt;m_aNode[i+k+<span class="number">1</span>]) <span class="keyword">return</span> Val;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> alpha=<span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> beta=<span class="number">0.0</span>; </span><br><span class="line"><span class="type">double</span> dTemp=<span class="number">0.0</span>;</span><br><span class="line">dTemp=m_aNode[i+k]-m_aNode[i];</span><br><span class="line"><span class="keyword">if</span>(dTemp==<span class="number">0.</span>) alpha=<span class="number">0.</span>;</span><br><span class="line"><span class="keyword">else</span> alpha=(u-m_aNode[i])/dTemp;</span><br><span class="line">dTemp=m_aNode[i+k+<span class="number">1</span>]-m_aNode[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (dTemp==<span class="number">0.</span>) beta=<span class="number">0.</span>; </span><br><span class="line"><span class="keyword">else</span> beta=(m_aNode[i+k+<span class="number">1</span>]-u)/dTemp;  </span><br><span class="line">val1=alpha*<span class="built_in">GetBaseFunVal</span>(u,i,k<span class="number">-1</span>);</span><br><span class="line">val2=beta*<span class="built_in">GetBaseFunVal</span>(u,i+<span class="number">1</span>,k<span class="number">-1</span>);</span><br><span class="line">Val=val1+val2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-B样条的局部性质">3.B样条的局部性质</h3><p>k次B样条曲线上一点p(u),u在[$u_i,u_{i+1}$]至多与k+1个控制顶点$d_j(j为i-k到i)$有关，与其他控制顶点无关；移动该曲线的第i个控制顶点$d_i$至多将影响到定义在第i个k次B样条的开支承区间($u_i，u_{i+k+1}$)上那部分曲线的形状，对曲线的其余部分不发生影响</p><p>根据这个性质，当定义一个曲线，节点矢量U=[$u_0,u_1,···,u_{n+k+1}$]，则曲线定义域为$u_3$到$u_9$，不含重节点的话，曲线段数为n-k-1</p><p>一些其他性质，可以看书</p><h3 id="4-非均匀B样条曲线">4.非均匀B样条曲线</h3><h4 id="节点矢量的确定">节点矢量的确定</h4><p>与其他类型的B样条曲线不同的是，给定控制顶点后，还需要确定它的节点矢量中具体的节点值</p><p>对于开曲线包括首末端点仅位置连续的闭曲线，都建议两端节点<strong>取重复度k+1</strong>,且通常地将曲线的定义域取成规范参数域u∈[$u_k,u_{n+1}$]=[0,1]，于是$u_0=u_1=···=u_k=0，u_{n+1}=u_{n+2}=···=u_{n+k+1}=1$，剩下的就是确定$u_{k+1},u_{k+2},···,u_n$那些内节点，共n-k个</p><h4 id="B样条基及其导数计算">B样条基及其导数计算</h4><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046872.png" alt="image-20220212131637515"></p><h4 id="计算B样条曲线上的点（德布尔算法）">计算B样条曲线上的点（德布尔算法）</h4><p>给点控制顶点$d_i$、次数k及确定节点矢量U后，就定义了一条k次B样条曲线。如果给出曲线定义域内的某个参数值u=$[u_i,u_{n+1}]$，想计算该B样条曲线上对应一点p(u)</p><p><img src="https://s2.loli.net/2022/02/12/M75kVX2AltxnS83.png" alt="image-20220212132209559"></p><h4 id="计算B样条曲线的导矢（德布尔算法）">计算B样条曲线的导矢（德布尔算法）</h4><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046041.png" alt="image-20220212132339534"></p><p>程序实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">功能：用德布尔算法求kk次平面B样条曲线上参数为u点处的r阶导矢(px,py)。</span><br><span class="line">输入参数：kk-次数；u-参数；r-导矢阶数：</span><br><span class="line">          (m_xAVertex,m_yAVertex)-控制顶点，m_aNode-节点矢量为受保护成员；m_KnotMark-节点值导矢选择码,公有成员。</span><br><span class="line">输出参数：曲线上参数为u点处的r阶导矢(px,py)，若r=<span class="number">0</span>，表示曲线上点<span class="built_in">p</span>(u)；</span><br><span class="line">          当u为内节点值,r&gt;<span class="number">0</span>时,m_KnotMark=<span class="number">0</span>与<span class="number">1</span>分别输出右导矢与左导矢。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">GetBPr</span>(<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">double</span> u,<span class="type">double</span> &amp;px,<span class="type">double</span> &amp;py)</span><br><span class="line">&#123;</span><br><span class="line">CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; tempx,tempy;</span><br><span class="line"><span class="keyword">if</span>(r&gt;k) &#123;px=<span class="number">0</span>;  py=<span class="number">0</span>;  <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=m_aNode.<span class="built_in">GetSize</span>()-k<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(u&gt;=m_aNode[i]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u&lt;m_aNode[k]) i=k;</span><br><span class="line"><span class="keyword">if</span>((k==<span class="number">1</span>&amp;&amp;r==<span class="number">1</span>)&amp;&amp;(u!=m_aNode[i]||(u==m_aNode[i]&amp;&amp;m_KnotMark==<span class="number">0</span>)))</span><br><span class="line">&#123;</span><br><span class="line">px=(m_xAVertex[i]-m_xAVertex[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]);</span><br><span class="line">py=(m_yAVertex[i]-m_yAVertex[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;r==<span class="number">1</span>&amp;&amp;m_KnotMark==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">px=(m_xAVertex[i<span class="number">-1</span>]-m_xAVertex[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]);</span><br><span class="line">py=(m_yAVertex[i<span class="number">-1</span>]-m_yAVertex[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&gt;k&amp;&amp;i&lt;=m_xAVertex.<span class="built_in">GetSize</span>()<span class="number">-1</span>)    <span class="comment">//限于计算内节点的重复度Multiple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Multiple=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ii=i;</span><br><span class="line"><span class="keyword">while</span>(u==m_aNode[ii<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">Multiple++;</span><br><span class="line">ii--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">1</span>&amp;&amp;m_KnotMark==<span class="number">1</span>&amp;&amp;u==m_aNode[i]&amp;&amp;i!=k) i=i-Multiple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((k==<span class="number">1</span>&amp;&amp;r==<span class="number">0</span>)||k&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i-k;j&lt;=i;j++)</span><br><span class="line">&#123;</span><br><span class="line">tempx.<span class="built_in">Add</span>(m_xAVertex[j]);</span><br><span class="line">tempy.<span class="built_in">Add</span>(m_yAVertex[j]);</span><br><span class="line"><span class="type">double</span> x=m_xAVertex[j],  y=m_yAVertex[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=r;l++)  <span class="comment">//教材(7.7)式第一式的r级递推</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i-k;j&lt;=i-l;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> beta=(k-l+<span class="number">1</span>)/(m_aNode[j+k+<span class="number">1</span>]-m_aNode[j+l]);</span><br><span class="line"><span class="type">int</span> jj=j-(i-k);</span><br><span class="line">tempx[jj]=beta*(tempx[jj+<span class="number">1</span>]-tempx[jj]);</span><br><span class="line">tempy[jj]=beta*(tempy[jj+<span class="number">1</span>]-tempy[jj]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//德布尔算法</span></span><br><span class="line"><span class="keyword">for</span>(l=<span class="number">1</span>;l&lt;=k-r;l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i-k;j&lt;=i-l-r;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> alpha,du=m_aNode[j+k+<span class="number">1</span>]-m_aNode[j+r+l];</span><br><span class="line"><span class="keyword">if</span>(du==<span class="number">0.0</span>) alpha=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">else</span> alpha=(u-m_aNode[j+r+l])/du;</span><br><span class="line">tempx[j-i+k]=(<span class="number">1</span>-alpha)*tempx[j-i+k]+alpha*tempx[j-i+k+<span class="number">1</span>];</span><br><span class="line">tempy[j-i+k]=(<span class="number">1</span>-alpha)*tempy[j-i+k]+alpha*tempy[j-i+k+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">px=tempx[<span class="number">0</span>];</span><br><span class="line">py=tempy[<span class="number">0</span>];</span><br><span class="line">tempx.<span class="built_in">RemoveAll</span>();</span><br><span class="line">tempy.<span class="built_in">RemoveAll</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第六章-B样条方法的基本几何算法（略）">第六章  B样条方法的基本几何算法（略）</h2><p>插入节点</p><p>节点细化</p><p>曲线分割</p><p>节点消去</p><p>升阶和降阶</p><h2 id="第七章-B样条曲线拟合（重点）">第七章 B样条曲线拟合（重点）</h2><p>计算已定义的B样条曲线上的点与各阶导矢称为正算过程，而日常主要遇到的是从给定数据点来确定节点矢量与控制顶点的反算问题，即反算三次B样条插值曲线的控制顶点</p><h3 id="曲线次数k">曲线次数k</h3><p>由于高次插值开曲线将带来更多的难以给出的边界条件等问题及实际工程问题需要，实践中广泛采用$C^2$连续的三次B样条曲线</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046160.png" alt="image-20220212134059833"></p><h3 id="节点矢量">节点矢量</h3><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046846.png" alt="image-20220212134212220"></p><h3 id="反算控制顶点">反算控制顶点</h3><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046057.png" alt="image-20220212134343699"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046002.png" alt="image-20220212134401238"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121046675.png" alt="image-20220212134420435"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047525.png" alt="image-20220212134446385"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047354.png" alt="image-20220212134502087"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047998.png" alt="image-20220212134530968"></p><p><img src="https://s2.loli.net/2022/02/12/vEGklpnCIgTd25F.png" alt="image-20220212134600711"></p><h3 id="编程实例-3">编程实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">功能：反算三次B样条插值开曲线控制顶点。</span><br><span class="line">输入参数：(m_xDVertex,m_yDVertex[i])-为受保护成员,i=<span class="number">0</span>,<span class="number">1</span>,...,n<span class="number">-2</span>存数据点,i=n<span class="number">-1</span>存首端显示切矢矢端,i=n存末端显示切矢矢端。m_eType0,m_eType1-首末边界条件标识码。</span><br><span class="line">输出参数：(m_xAVertex,m_yAVertex)-控制顶点，为受保护成员。</span><br><span class="line">调用函数：InitEdge-置首末边界条件系数与右端矢量；delta-节点值向前差分。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">BTridia</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n= m_xDVertex.<span class="built_in">GetSize</span>()<span class="number">-1</span>; </span><br><span class="line"><span class="type">int</span> k=<span class="number">2</span>;</span><br><span class="line">m_xAVertex.<span class="built_in">SetSize</span>(n+<span class="number">1</span>), m_yAVertex.<span class="built_in">SetSize</span>(n+<span class="number">1</span>);     <span class="comment">//i=0,1,...,n存控制顶点</span></span><br><span class="line">m_xAVertex[<span class="number">0</span>]=m_xDVertex[<span class="number">0</span>];</span><br><span class="line">m_yAVertex[<span class="number">0</span>]=m_yDVertex[<span class="number">0</span>];</span><br><span class="line">m_xAVertex[n]=m_xDVertex[n<span class="number">-2</span>];</span><br><span class="line">m_yAVertex[n]=m_yDVertex[n<span class="number">-2</span>];</span><br><span class="line"><span class="type">double</span> a1,b1,c1,e1x,e1y,an_1,bn_1,cn_1,en_1x,en_1y;</span><br><span class="line"><span class="built_in">InitEdge</span>(b1,c1,a1,e1x,e1y,cn_1,an_1,bn_1,en_1x,en_1y); CArray&lt;CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;,CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&amp;&gt; dia;<span class="comment">//系数矩阵存三对角元素</span></span><br><span class="line">dia.<span class="built_in">SetSize</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//系数矩阵含第1，2,...,n-1行，行数为n-1。第i 行dia[0][i],dia[1][i],dia[2][i]存ai,bi,ci </span></span><br><span class="line"><span class="comment">//三个元素。因系数矩阵不含第0行，dia[0][0],dia[1][0],dia[2][0]三元素空置。</span></span><br><span class="line"><span class="comment">//系数矩阵既有三对角元素，又首行多出a1与末行多出cn_1两个元素。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) dia[i].<span class="built_in">SetSize</span>(n); </span><br><span class="line">CArray&lt;CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;,CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&amp;&gt; t;</span><br><span class="line">t.<span class="built_in">SetSize</span>(k);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++) t[i].<span class="built_in">SetSize</span>(n);</span><br><span class="line"><span class="comment">//生成系数矩阵第2，3，...,n-2行元素与右端矢量(t[0][i], t[1][i]),i=2，3，...,n-2</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n<span class="number">-2</span>;i++)    <span class="comment">//函数double delta(int i);在头文件中声明为受保护(protected)</span></span><br><span class="line">&#123;                      <span class="comment">//成员，用于计算节点矢量中节点值的一阶向前差分</span></span><br><span class="line">dia[<span class="number">0</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">2</span>)*<span class="built_in">delta</span>(i+<span class="number">2</span>))/(<span class="built_in">delta</span>(i)+<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>));</span><br><span class="line">dia[<span class="number">1</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">2</span>)*(<span class="built_in">delta</span>(i)+<span class="built_in">delta</span>(i+<span class="number">1</span>)))/(<span class="built_in">delta</span>(i)+<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>))   +(<span class="built_in">delta</span>(i+<span class="number">1</span>)*(<span class="built_in">delta</span>(i+<span class="number">2</span>)+<span class="built_in">delta</span>(i+<span class="number">3</span>)))/(<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>)+<span class="built_in">delta</span>(i+<span class="number">3</span>));</span><br><span class="line">dia[<span class="number">2</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">1</span>)*<span class="built_in">delta</span>(i+<span class="number">1</span>))/(<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>)+<span class="built_in">delta</span>(i+<span class="number">3</span>));</span><br><span class="line">t[<span class="number">0</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>))*m_xDVertex[i<span class="number">-1</span>];</span><br><span class="line">t[<span class="number">1</span>][i]=(<span class="built_in">delta</span>(i+<span class="number">1</span>)+<span class="built_in">delta</span>(i+<span class="number">2</span>))*m_yDVertex[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">dia[<span class="number">0</span>][<span class="number">1</span>]=a1; dia[<span class="number">1</span>][<span class="number">1</span>]=b1;dia[<span class="number">2</span>][<span class="number">1</span>]=c1;            <span class="comment">//首行边界条件系数矩阵三元素</span></span><br><span class="line">dia[<span class="number">0</span>][n<span class="number">-1</span>]=an_1; dia[<span class="number">1</span>][n<span class="number">-1</span>]= bn_1;dia[<span class="number">2</span>][n<span class="number">-1</span>]=cn_1;  <span class="comment">//末行边界条件系数矩阵三元素</span></span><br><span class="line">t[<span class="number">0</span>][<span class="number">1</span>]=e1x;  t[<span class="number">1</span>][<span class="number">1</span>]=e1y;                         <span class="comment">//首行边界条件右端首点矢量。</span></span><br><span class="line">t[<span class="number">0</span>][n<span class="number">-1</span>]=en_1x; t[<span class="number">1</span>][n<span class="number">-1</span>]=en_1y;                   <span class="comment">//末行边界条件右端末点矢量。</span></span><br><span class="line"><span class="keyword">if</span>(m_eType0!=<span class="number">5</span>&amp;&amp;m_eType1!=<span class="number">5</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">dia[<span class="number">0</span>][<span class="number">1</span>]=-dia[<span class="number">0</span>][<span class="number">1</span>]/dia[<span class="number">2</span>][<span class="number">2</span>];             <span class="comment">//开始消元过程，将首行a1消为0</span></span><br><span class="line">dia[<span class="number">1</span>][<span class="number">1</span>]=dia[<span class="number">1</span>][<span class="number">1</span>]+dia[<span class="number">0</span>][<span class="number">2</span>]*dia[<span class="number">0</span>][<span class="number">1</span>];          </span><br><span class="line">dia[<span class="number">2</span>][<span class="number">1</span>]=dia[<span class="number">2</span>][<span class="number">1</span>]+dia[<span class="number">1</span>][<span class="number">2</span>]*dia[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">t[<span class="number">0</span>][<span class="number">1</span>]=t[<span class="number">0</span>][<span class="number">1</span>]+t[<span class="number">0</span>][<span class="number">2</span>]*dia[<span class="number">0</span>][<span class="number">1</span>]; </span><br><span class="line">t[<span class="number">1</span>][<span class="number">1</span>]=t[<span class="number">1</span>][<span class="number">1</span>]+t[<span class="number">1</span>][<span class="number">2</span>]*dia[<span class="number">0</span>][<span class="number">1</span>]; </span><br><span class="line">dia[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0.</span>; </span><br><span class="line">dia[<span class="number">2</span>][n<span class="number">-1</span>]=-dia[<span class="number">2</span>][n<span class="number">-1</span>]/dia[<span class="number">0</span>][n<span class="number">-2</span>];         <span class="comment">//将末行cn_1消为0</span></span><br><span class="line">dia[<span class="number">0</span>][n<span class="number">-1</span>]=dia[<span class="number">0</span>][n<span class="number">-1</span>]+dia[<span class="number">1</span>][n<span class="number">-2</span>]*dia[<span class="number">2</span>][n<span class="number">-1</span>];  </span><br><span class="line">dia[<span class="number">1</span>][n<span class="number">-1</span>]=dia[<span class="number">1</span>][n<span class="number">-1</span>]+dia[<span class="number">2</span>][n<span class="number">-2</span>]*dia[<span class="number">2</span>][n<span class="number">-1</span>];</span><br><span class="line">t[<span class="number">0</span>][n<span class="number">-1</span>]=t[<span class="number">0</span>][n<span class="number">-1</span>]+t[<span class="number">0</span>][n<span class="number">-2</span>]*dia[<span class="number">2</span>][n<span class="number">-1</span>];</span><br><span class="line">t[<span class="number">1</span>][n<span class="number">-1</span>]=t[<span class="number">1</span>][n<span class="number">-1</span>]+t[<span class="number">1</span>][n<span class="number">-2</span>]*dia[<span class="number">2</span>][n<span class="number">-1</span>]; </span><br><span class="line">dia[<span class="number">2</span>][n<span class="number">-1</span>]=<span class="number">0.</span>;  <span class="comment">//至此，系数矩阵已成为标准三对角矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++)                           <span class="comment">//将下三角元素全部消为0</span></span><br><span class="line">&#123;</span><br><span class="line">dia[<span class="number">0</span>][i]=-dia[<span class="number">0</span>][i]/dia[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">dia[<span class="number">1</span>][i]=dia[<span class="number">1</span>][i]+dia[<span class="number">2</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">t[<span class="number">0</span>][i]=t[<span class="number">0</span>][i]+t[<span class="number">0</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">t[<span class="number">1</span>][i]=t[<span class="number">1</span>][i]+t[<span class="number">1</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;k;l++) t[l][n<span class="number">-1</span>]=t[l][n<span class="number">-1</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];   <span class="comment">//得第n-1个控制顶点</span></span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-2</span>;i&gt;=<span class="number">1</span>;i--)                            <span class="comment">//回代求得第n-2,n-3,...,1个控制顶点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;k;l++) t[l][i]=(t[l][i]-dia[<span class="number">2</span>][i]*t[l][i+<span class="number">1</span>])/dia[<span class="number">1</span>][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//当用于非节点条件，消元时可能出现主对角元素为0，作相应处理。</span></span><br><span class="line"><span class="keyword">if</span>(m_eType0==<span class="number">5</span>||m_eType1==<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">dia[<span class="number">0</span>][n<span class="number">-2</span>]=dia[<span class="number">0</span>][n<span class="number">-2</span>]-dia[<span class="number">2</span>][n<span class="number">-1</span>]*dia[<span class="number">2</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];  <span class="comment">//将dia[2][n-2]消为0;</span></span><br><span class="line">dia[<span class="number">1</span>][n<span class="number">-2</span>]=dia[<span class="number">1</span>][n<span class="number">-2</span>]-dia[<span class="number">0</span>][n<span class="number">-1</span>]*dia[<span class="number">2</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">t[<span class="number">0</span>][n<span class="number">-2</span>]=t[<span class="number">0</span>][n<span class="number">-2</span>]-t[<span class="number">0</span>][n<span class="number">-1</span>]*dia[<span class="number">2</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">t[<span class="number">1</span>][n<span class="number">-2</span>]=t[<span class="number">1</span>][n<span class="number">-2</span>]-t[<span class="number">1</span>][n<span class="number">-1</span>]*dia[<span class="number">2</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">dia[<span class="number">2</span>][n<span class="number">-2</span>]=<span class="number">0.</span>;                           </span><br><span class="line">dia[<span class="number">1</span>][<span class="number">2</span>]=dia[<span class="number">1</span>][<span class="number">2</span>]-dia[<span class="number">2</span>][<span class="number">1</span>]*dia[<span class="number">0</span>][<span class="number">2</span>]/dia[<span class="number">1</span>][<span class="number">1</span>];           <span class="comment">//dia[0][2]消为0;</span></span><br><span class="line">dia[<span class="number">2</span>][<span class="number">2</span>]=dia[<span class="number">2</span>][<span class="number">2</span>]-dia[<span class="number">0</span>][<span class="number">1</span>]*dia[<span class="number">0</span>][<span class="number">2</span>]/dia[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">t[<span class="number">0</span>][<span class="number">2</span>]=t[<span class="number">0</span>][<span class="number">2</span>]-t[<span class="number">0</span>][<span class="number">1</span>]*dia[<span class="number">0</span>][<span class="number">2</span>]/dia[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">t[<span class="number">1</span>][<span class="number">2</span>]=t[<span class="number">1</span>][<span class="number">2</span>]-t[<span class="number">1</span>][<span class="number">1</span>]*dia[<span class="number">0</span>][<span class="number">2</span>]/dia[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">dia[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0.</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n<span class="number">-2</span>;i++)                                    <span class="comment">//将下三角元素消为0</span></span><br><span class="line">&#123;</span><br><span class="line">dia[<span class="number">0</span>][i]=-dia[<span class="number">0</span>][i]/dia[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">dia[<span class="number">1</span>][i]=dia[<span class="number">1</span>][i]+dia[<span class="number">2</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">t[<span class="number">0</span>][i]=t[<span class="number">0</span>][i]+t[<span class="number">0</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">t[<span class="number">1</span>][i]=t[<span class="number">1</span>][i]+t[<span class="number">1</span>][i<span class="number">-1</span>]*dia[<span class="number">0</span>][i];</span><br><span class="line">dia[<span class="number">0</span>][i]=<span class="number">0.</span>;</span><br><span class="line">&#125;</span><br><span class="line">t[<span class="number">0</span>][n<span class="number">-2</span>]=t[<span class="number">0</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-2</span>];                <span class="comment">//得顶点(m_xAVertex[n-2], m_yAVertex[n-2])</span></span><br><span class="line">t[<span class="number">1</span>][n<span class="number">-2</span>]=t[<span class="number">1</span>][n<span class="number">-2</span>]/dia[<span class="number">1</span>][n<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-3</span>;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">&#123;   <span class="comment">//回代求顶点(m_xAVertex[n-3], m_yAVertex[n-3]),...,(m_xAVertex[2], m_yAVertex[2])</span></span><br><span class="line">t[<span class="number">0</span>][i]=(t[<span class="number">0</span>][i]-dia[<span class="number">2</span>][i]*t[<span class="number">0</span>][i+<span class="number">1</span>])/dia[<span class="number">1</span>][i];</span><br><span class="line">t[<span class="number">1</span>][i]=(t[<span class="number">1</span>][i]-dia[<span class="number">2</span>][i]*t[<span class="number">1</span>][i+<span class="number">1</span>])/dia[<span class="number">1</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回代求顶点(m_xAVertex[1], m_yAVertex[1])</span></span><br><span class="line">t[<span class="number">0</span>][<span class="number">1</span>]=(t[<span class="number">0</span>][<span class="number">1</span>]-dia[<span class="number">2</span>][<span class="number">1</span>]*t[<span class="number">0</span>][<span class="number">2</span>]-dia[<span class="number">0</span>][<span class="number">1</span>]*t[<span class="number">0</span>][<span class="number">3</span>])/dia[<span class="number">1</span>][<span class="number">1</span>];  t[<span class="number">1</span>][<span class="number">1</span>]=(t[<span class="number">1</span>][<span class="number">1</span>]-dia[<span class="number">2</span>][<span class="number">1</span>]*t[<span class="number">1</span>][<span class="number">2</span>]-dia[<span class="number">0</span>][<span class="number">1</span>]*t[<span class="number">1</span>][<span class="number">3</span>])/dia[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="comment">//求顶点(m_xAVertex[n-1], m_yAVertex[n-1]</span></span><br><span class="line">t[<span class="number">0</span>][n<span class="number">-1</span>]=(t[<span class="number">0</span>][n<span class="number">-1</span>]-dia[<span class="number">2</span>][n<span class="number">-1</span>]*t[<span class="number">0</span>][n<span class="number">-3</span>]-dia[<span class="number">0</span>][n<span class="number">-1</span>]*t[<span class="number">0</span>][n<span class="number">-2</span>])/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">t[<span class="number">1</span>][n<span class="number">-1</span>]=(t[<span class="number">1</span>][n<span class="number">-1</span>]-dia[<span class="number">2</span>][n<span class="number">-1</span>]*t[<span class="number">1</span>][n<span class="number">-3</span>]-dia[<span class="number">0</span>][n<span class="number">-1</span>]*t[<span class="number">1</span>][n<span class="number">-2</span>])/dia[<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得第1，2，...,n-1个控制顶点</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">m_xAVertex[i]=t[<span class="number">0</span>][i]; </span><br><span class="line">m_yAVertex[i]=t[<span class="number">1</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m_eType0!=<span class="number">2</span>&amp;&amp;m_eType0!=<span class="number">3</span>)</span><br><span class="line">&#123;   <span class="comment">//该段解决拖动显示首端切矢矢端(m_xDVertex[n-1],m_yDVertex[n-1])</span></span><br><span class="line"><span class="type">double</span> px,py;</span><br><span class="line"><span class="type">int</span> rank=<span class="number">1</span>,nTime=<span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> u=<span class="number">0.</span>;</span><br><span class="line"><span class="built_in">GetDerivat</span>(rank,nTime,u,px,py);</span><br><span class="line">m_ftx=px;</span><br><span class="line">m_fty=py;</span><br><span class="line">m_xDVertex[n<span class="number">-1</span>]=m_xDVertex[<span class="number">0</span>]+<span class="number">0.5</span>*<span class="built_in">delta</span>(<span class="number">3</span>)*m_ftx;</span><br><span class="line">m_yDVertex[n<span class="number">-1</span>]=m_yDVertex[<span class="number">0</span>]+<span class="number">0.5</span>*<span class="built_in">delta</span>(<span class="number">3</span>)*m_fty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m_eType1!=<span class="number">2</span>&amp;&amp;m_eType1!=<span class="number">3</span>)</span><br><span class="line">&#123;   <span class="comment">//该段解决拖动显示末端切矢矢端(m_xDVertex[n],m_yDVertex[n])</span></span><br><span class="line"><span class="type">double</span> px,py;</span><br><span class="line"><span class="type">int</span> rank=<span class="number">1</span>,nTime=<span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> u=<span class="number">1.</span>;</span><br><span class="line"><span class="built_in">GetDerivat</span>(rank,nTime,u,px,py);</span><br><span class="line">m_ltx=px;</span><br><span class="line">m_lty=py;</span><br><span class="line">m_xDVertex[n]=m_xDVertex[n<span class="number">-2</span>]+<span class="number">0.5</span>*<span class="built_in">delta</span>(n)*m_ltx;</span><br><span class="line">m_yDVertex[n]=m_yDVertex[n<span class="number">-2</span>]+<span class="number">0.5</span>*<span class="built_in">delta</span>(n)*m_lty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第八章-有理贝齐尔曲线">第八章 有理贝齐尔曲线</h2><h3 id="为什么使用有理？">为什么使用有理？</h3><p>在飞机外形设计与绝大多数机械零件中经常遇到许多由二次曲线弧与二次曲面表示的形状，如机身框截面外形曲线一般由多段圆弧、椭圆弧、抛物线弧等二次曲线弧与直线段连接而成。机械零件、塑料制品中圆柱面、圆锥面、圆环面等二次曲面及平面构成的形状更是比比皆是。这些形状在设计上都由图纸明确无误地给出，在制造上往往又要求较高的精度。非有理贝齐尔方法和B样条方法都不能精确表示除抛物面外的二次曲面，而只能给出近似表示。近似表示将带来处理上的麻烦，使本来简单的问题复杂化，还带来原来不存在的设计误差问题。例如，为用贝齐尔方法较精确地表示某一半径的半圆，需要用到五次贝齐尔曲线，并必须专门计算其控制顶点。如果改变圆的半径或要求更高的精度，就必须重新确定次数及计算控制顶点。<br>显然，专门用于自由型曲线曲面的B样条方法包括贝齐尔方法根本不能适应初等曲面的要求。为了精确表示二次曲线弧与二次曲面，就不得不采用另外一套数学描述方法，譬如用隐方程表示。这样不仅又重新带来隐方程表示所存在的问题，而且将导致一个几何设计系统采用并存的两种不同数学方法。这将使系统变得十分庞杂，是系统研制人员最为忌讳的。</p><p>第5章介绍的贝齐尔方法实际采用参数整多项式，而有理贝齐尔方法采用分子分母分别是参数多项式与多项式函数的分式表示，是有理的。相对而言，我们把以前介绍的贝齐尔方法称为非有理的，相应的贝齐尔曲线曲面加上非有理的修饰词。</p><p>$有理=\frac{参数多项式}{多项式函数} $</p><h2 id="第九章-有理B样条曲线（核心）">第九章 有理B样条曲线（核心）</h2><p>有理B样条曲线通常都采用非均匀节点矢量，因此就有非均匀有理B样条(Non Uniform Rational B-Spline)曲线，即NURBS曲线，基于贝齐尔和B样条方法发展过来，并改成有理基函数</p><p>$NURBS的有理=\frac{分段参数多项式}{分段多项式函数} $</p><h3 id="三种等价的NURBS曲线方程">三种等价的NURBS曲线方程</h3><ol><li>有理分式表示</li></ol><p><img src="https://s2.loli.net/2022/02/13/z3PlMwIRpuYvfUT.png" alt="image-20220213112449075"></p><ol start="2"><li><p>有理基函数表示</p><p><img src="https://s2.loli.net/2022/02/13/GLka82FPEpgMUfZ.png" alt="image-20220213113108466"></p></li><li><p>齐次坐标表示</p><p><img src="https://s2.loli.net/2022/02/13/lBELoRJD19Wqwur.png" alt="image-20220213113434789"></p><p><img src="https://s2.loli.net/2022/02/13/AmEvG9hVu8n27bQ.png" alt="image-20220213113452269"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047453.png" alt="image-20220213113505380"></p></li></ol><h3 id="权因子对NURBS曲线形状的影响">权因子对NURBS曲线形状的影响</h3><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047766.png" alt="image-20220213124640171"></p><h3 id="组合NURBS曲线实例">组合NURBS曲线实例</h3><p>采用NURBS方法可以将顺序相接的各种连续性的各种非有理与有理贝齐尔曲线、非有理与有理B样条曲线在更高层次上组合，用一个统一方程表示，成为最具有一般意义的NURBS曲线</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047581.png" alt="image-20220213140649373" style="zoom:80%;" /><p>解决步骤：（具体查看书）</p><ol><li>确定组合后曲线的次数k。各分段曲线的最高次数</li><li>把各非B样条表示的分段曲线都取B样条表示。只需给出它们的节点矢量，其他不用变</li><li>把次数低于k的曲线升阶，并给出NURBS表示</li><li>确定组合NURBS曲线的控制顶点与权因子</li><li>确定各别曲线段在整体参数域[0,1]中的定义区间</li></ol><h3 id="NURBS曲线上点的计算（-）">NURBS曲线上点的计算（*）</h3><p>除了NURBS曲线的分式表示给出曲线方程直接计算NURBS曲线上的点，还可以使用德布尔算法来计算</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121048866.png" alt="image-20220213141408283"></p><p>编程实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">功能：计算NURBS曲线上参数u所对应的点(px,py)及其权因子w0。</span><br><span class="line">输入参数：(m_xAVertex,m_yAVertex)-控制顶点；m_Weights-权因子；m_aNode-节点矢量，都是受保护成员。m_nTimes –曲线次数,属公有成员；u-参数值。</span><br><span class="line">输出参数：px，py，w0-分别是NURBS曲线上参数u所对应的点的两个坐标与权因子。</span><br><span class="line">调用函数：无</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetPoint</span><span class="params">(<span class="type">double</span> u,<span class="type">double</span> &amp;px,<span class="type">double</span> &amp;py,<span class="type">double</span> &amp;w0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; ax,ay;</span><br><span class="line">    CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; aw;</span><br><span class="line"><span class="type">int</span> k=m_nTimes;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> iN=m_aNode.<span class="built_in">GetSize</span>()-k<span class="number">-2</span>;iN&gt;=<span class="number">0</span>;iN--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(u&gt;=m_aNode[iN])</span><br><span class="line">&#123;</span><br><span class="line">i=iN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i-k;j&lt;=i;j++)</span><br><span class="line">&#123;</span><br><span class="line">ax.<span class="built_in">Add</span>(m_xAVertex[j]*m_Weights[j]);</span><br><span class="line">ay.<span class="built_in">Add</span>(m_yAVertex[j]*m_Weights[j]);</span><br><span class="line">aw.<span class="built_in">Add</span>(m_Weights[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//德布尔算法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=k;l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i-k+l;j&lt;=i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> alpha,du=m_aNode[j+k+<span class="number">1</span>-l]-m_aNode[j];</span><br><span class="line"><span class="keyword">if</span>(du==<span class="number">0.0</span>) alpha=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">else</span> alpha=(u-m_aNode[j])/du;</span><br><span class="line"><span class="type">int</span> n=j-(i-k+l);</span><br><span class="line">ax[n]=(<span class="number">1</span>-alpha)*ax[n]+alpha*ax[n+<span class="number">1</span>];</span><br><span class="line">ay[n]=(<span class="number">1</span>-alpha)*ay[n]+alpha*ay[n+<span class="number">1</span>];</span><br><span class="line">aw[n]=(<span class="number">1</span>-alpha)*aw[n]+alpha*aw[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">px=ax[<span class="number">0</span>]/aw[<span class="number">0</span>];</span><br><span class="line">py=ay[<span class="number">0</span>]/aw[<span class="number">0</span>];</span><br><span class="line">w0=aw[<span class="number">0</span>];</span><br><span class="line">ax.<span class="built_in">RemoveAll</span>();</span><br><span class="line">ay.<span class="built_in">RemoveAll</span>();</span><br><span class="line">aw.<span class="built_in">RemoveAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NURBS曲线的基本几何算法">NURBS曲线的基本几何算法</h3><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121047728.png" alt="image-20220213141705236"></p><p>插入节点（书上有例子）</p><p>节点细化</p><p>曲线分割</p><p>节点消去</p><p>升阶和降阶</p><h3 id="NURBS曲线导矢计算（-）">NURBS曲线导矢计算（*）</h3><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121048207.png" alt="image-20220213142017826"></p><h4 id="计算理论">计算理论</h4><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121048186.png" alt="image-20220213142058704"></p><h4 id="两个编程实例">两个编程实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">功能：求二维NURBS曲线参数为u的点处的r阶导矢(px,py)</span><br><span class="line">输入参数：r-导矢阶数；m_nTimes-曲线次数；u-参数。</span><br><span class="line">输出参数：(px,py)- r阶导矢。</span><br><span class="line">调用函数：GetWBPr-计算分子 的r阶导矢与分母 的r阶导数。</span><br><span class="line">  GetNURBSDerivat-递归调用自身。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNURBSDerivat</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> m_nTimes,<span class="type">double</span> u,<span class="type">double</span> &amp;px,<span class="type">double</span> &amp;py)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> pw,PX,PY,PW;</span><br><span class="line"><span class="type">double</span> Xikmax,Xikmay;</span><br><span class="line"><span class="keyword">if</span>(r==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GetPoint</span>(u,px,py,pw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GetWBPr</span>(r,m_nTimes,u,PX,PY,PW);</span><br><span class="line">Xikmax=<span class="number">0</span>;  Xikmay=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=r;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GetWBPr</span>(j,m_nTimes,u,PX,PY,PW);</span><br><span class="line"><span class="built_in">GetNURBSDerivat</span>(r-j,m_nTimes,u,px,py);</span><br><span class="line">Xikmax=Xikmax+<span class="built_in">Fact</span>(r)/(<span class="built_in">Fact</span>(r-j)*<span class="built_in">Fact</span>(j))*PW*px;</span><br><span class="line">Xikmay=Xikmay+<span class="built_in">Fact</span>(r)/(<span class="built_in">Fact</span>(r-j)*<span class="built_in">Fact</span>(j))*PW*py;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">GetPoint</span>(u,px,py,pw);</span><br><span class="line"><span class="built_in">GetWBPr</span>(r,m_nTimes,u,PX,PY,PW);</span><br><span class="line">px=(PX-Xikmax)/pw;</span><br><span class="line">py=(PY-Xikmay)/pw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">功能：求二维k次NURBS曲线的分子曲线上参数为u的点处的r阶导矢(PX,PY)及分母函数的r阶导数PW。</span><br><span class="line">输入参数：m_aVertex-控制顶点，m_Weights-权因子，m_aNode-节点矢量，都是受保护成员。r-导矢阶数；k -曲线次数；u-参数。</span><br><span class="line">输出参数：(PX,PY)- r阶导矢；PW-r阶导数。当u为内节点值,r&gt;<span class="number">0</span>时,m_KnotMark=<span class="number">0</span>与<span class="number">1</span>分布输出右导矢、左导矢与右导数、左导数。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">GetWBPr</span>(<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">double</span> u,<span class="type">double</span> &amp;PX,<span class="type">double</span> &amp;PY,<span class="type">double</span> &amp;PW)</span><br><span class="line">&#123;</span><br><span class="line">CArray&lt;<span class="type">double</span>,<span class="type">double</span>&gt; tempx,tempy,tempw;</span><br><span class="line"><span class="keyword">if</span>(r&gt;k)</span><br><span class="line">&#123;PX=<span class="number">0</span>;  PY=<span class="number">0</span>;  PW=<span class="number">0</span>;  <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=m_aNode.<span class="built_in">GetSize</span>()-m_nTimes<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(u&gt;=m_aNode[i]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u&lt;m_aNode[k]) i=k;</span><br><span class="line"><span class="keyword">if</span>((k==<span class="number">1</span>&amp;&amp;r==<span class="number">1</span>&amp;&amp;u!=m_aNode[i])||(m_KnotMark==<span class="number">0</span>&amp;&amp;i==k&amp;&amp;u==m_aNode[i])||m_KnotMark==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">PX=<span class="built_in">int</span>((m_aVertex[i].x*m_Weights[i]-m_aVertex[i<span class="number">-1</span>].x*m_Weights[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]));</span><br><span class="line">PY=<span class="built_in">int</span>((m_aVertex[i].y*m_Weights[i]-m_aVertex[i<span class="number">-1</span>].y*m_Weights[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]));</span><br><span class="line">PW=(m_Weights[i]-m_Weights[i<span class="number">-1</span>])/(m_aNode[i+<span class="number">1</span>]-m_aNode[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;r==<span class="number">1</span>&amp;&amp;m_KnotMark==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PX=<span class="built_in">int</span>((m_aVertex[i<span class="number">-1</span>].x*m_Weights[i<span class="number">-1</span>]-m_aVertex[i<span class="number">-2</span>].x*m_Weights[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]));</span><br><span class="line">PY=<span class="built_in">int</span>((m_aVertex[i<span class="number">-1</span>].y*m_Weights[i<span class="number">-1</span>]-m_aVertex[i<span class="number">-2</span>].y*m_Weights[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]));</span><br><span class="line">PW=(m_Weights[i<span class="number">-1</span>]-m_Weights[i<span class="number">-2</span>])/(m_aNode[i]-m_aNode[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">1</span>&amp;&amp;r==k&amp;&amp;m_KnotMark==<span class="number">1</span>&amp;&amp;u==m_aNode[i]&amp;&amp;i!=k) i=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>((k==<span class="number">1</span>&amp;&amp;r==<span class="number">0</span>)||k&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i-k;j&lt;=i;j++)</span><br><span class="line">&#123;</span><br><span class="line">tempx.<span class="built_in">Add</span>(<span class="built_in">double</span>(m_aVertex[j].x*m_Weights[j]));</span><br><span class="line">tempy.<span class="built_in">Add</span>(<span class="built_in">double</span>(m_aVertex[j].y*m_Weights[j]));</span><br><span class="line">tempw.<span class="built_in">Add</span>(m_Weights[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=r;l++)  <span class="comment">//本修订版教材(7.7)式第一式的r级递推</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i-k;j&lt;=i-l;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> beta=(k-l+<span class="number">1</span>)/(m_aNode[j+k+<span class="number">1</span>]-m_aNode[j+l]);</span><br><span class="line"><span class="type">int</span> jj=j-(i-k);</span><br><span class="line">tempx[jj]=beta*(tempx[jj+<span class="number">1</span>]-tempx[jj]);</span><br><span class="line">tempy[jj]=beta*(tempy[jj+<span class="number">1</span>]-tempy[jj]);</span><br><span class="line">tempw[jj]=beta*(tempw[jj+<span class="number">1</span>]-tempw[jj]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本修订版教材(7.7c)式德布尔算法,次数已由k降为k-r</span></span><br><span class="line"><span class="keyword">for</span>(l=<span class="number">1</span>;l&lt;=k-r;l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i-k;j&lt;=i-l-r;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> alpha,du=m_aNode[j+k+<span class="number">1</span>]-m_aNode[j+r+l];</span><br><span class="line"><span class="keyword">if</span>(du==<span class="number">0.0</span>) alpha=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">else</span> alpha=(u-m_aNode[j+r+l])/du;</span><br><span class="line">tempx[j-i+k]=(<span class="number">1</span>-alpha)*tempx[j-i+k]+alpha*tempx[j-i+k+<span class="number">1</span>];</span><br><span class="line">tempy[j-i+k]=(<span class="number">1</span>-alpha)*tempy[j-i+k]+alpha*tempy[j-i+k+<span class="number">1</span>];</span><br><span class="line">tempw[j-i+k]=(<span class="number">1</span>-alpha)*tempw[j-i+k]+alpha*tempw[j-i+k+<span class="number">1</span>];</span><br><span class="line"><span class="type">double</span> ww=tempw[j-i+k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PX=tempx[<span class="number">0</span>];</span><br><span class="line">PY=tempy[<span class="number">0</span>];</span><br><span class="line">PW=tempw[<span class="number">0</span>];</span><br><span class="line">tempx.<span class="built_in">RemoveAll</span>();</span><br><span class="line">tempy.<span class="built_in">RemoveAll</span>();</span><br><span class="line">tempw.<span class="built_in">RemoveAll</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NURBS曲线的形状修改">NURBS曲线的形状修改</h3><p><strong>实际中应用控制顶点粗调，用权因子细调</strong></p><p>重新定位控制顶点</p><p>反插节点</p><p>重新确定权因子</p><p>NURBS编程实例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 给定一组数据点，即型值点，反求其控制顶点，并构造通过这些型值点的2D或3D nurbs曲线，首末型值点与控制顶点重合，称为nurbs曲线插值</span></span><br><span class="line"><span class="comment">% 具有n个型值点的k次nurbs插值曲线，将有n+2个未知控制顶点，首末节点取重复度r=k+1,从而具有n+2+k+1个节点</span></span><br><span class="line"><span class="comment">% 三次Nurbs曲线的首末节点取重复度r=k+1=4，u1=u2=u3=u4=0,Un+3=Un+4=Un+5=Un+6=1</span></span><br><span class="line">clear</span><br><span class="line">pt=load(<span class="string">&#x27;data2.txt&#x27;</span>); </span><br><span class="line">[row,column]=<span class="built_in">size</span>(pt);  <span class="comment">%每行代表一个型值点，采用列向量表示x,y,z坐标，便于线性方程组求解</span></span><br><span class="line">n=<span class="built_in">length</span>(pt);  <span class="comment">%型值点数量</span></span><br><span class="line">k=<span class="number">3</span>;  <span class="comment">%样条阶数</span></span><br><span class="line">U=<span class="built_in">zeros</span>(<span class="number">1</span>,n+k+<span class="number">3</span>);  <span class="comment">%节点矢量</span></span><br><span class="line"><span class="comment">%第一步：计算节点矢量********************</span></span><br><span class="line"><span class="keyword">if</span>(column == <span class="number">2</span>)   <span class="comment">% 2D curve</span></span><br><span class="line">    x=pt(:,<span class="number">1</span>);</span><br><span class="line">    y=pt(:,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span>              <span class="comment">% 3D curve</span></span><br><span class="line">    x=pt(:,<span class="number">1</span>);</span><br><span class="line">    y=pt(:,<span class="number">2</span>);</span><br><span class="line">    z=pt(:,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%n个数据点，利用规范积累弦长法进行型值点参数化处理</span></span><br><span class="line">temp=<span class="built_in">zeros</span>(<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n<span class="number">-1</span>  <span class="comment">%n个数据点，n-1段弦长</span></span><br><span class="line">   <span class="keyword">if</span>(column == <span class="number">2</span>)    <span class="comment">% 2D curve</span></span><br><span class="line">   temp(<span class="built_in">i</span>)=<span class="built_in">sqrt</span>((x(<span class="built_in">i</span>+<span class="number">1</span>)-x(<span class="built_in">i</span>))^<span class="number">2</span>+(y(<span class="built_in">i</span>+<span class="number">1</span>)-y(<span class="built_in">i</span>))^<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">else</span>               <span class="comment">% 3D curve</span></span><br><span class="line">   temp(<span class="built_in">i</span>)=<span class="built_in">sqrt</span>((x(<span class="built_in">i</span>+<span class="number">1</span>)-x(<span class="built_in">i</span>))^<span class="number">2</span>+(y(<span class="built_in">i</span>+<span class="number">1</span>)-y(<span class="built_in">i</span>))^<span class="number">2</span>+(z(<span class="built_in">i</span>+<span class="number">1</span>)-z(<span class="built_in">i</span>))^<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">sumtemp=sum(temp);<span class="comment">%顺序相邻两型值点之间距离的和,即总弦长</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:k+<span class="number">1</span>      <span class="comment">%前k+1个节点为0</span></span><br><span class="line">    U(<span class="built_in">i</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=n+k:n+k+<span class="number">3</span>  <span class="comment">%后k+1个节点为1</span></span><br><span class="line">    U(<span class="built_in">i</span>)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> <span class="comment">%n个数据点，内节点为n-2个，U(k+1)作为初始值</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=k+<span class="number">1</span>:n+k<span class="number">-2</span></span><br><span class="line">    U(<span class="built_in">i</span>+<span class="number">1</span>)=U(<span class="built_in">i</span>)+temp(<span class="built_in">i</span>-k)/sumtemp;  <span class="comment">%n-1段弦长，U（k+1）到U（n+k）共n个节点</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%第二步：反算n+2个控制点，采用切矢边界*****************************</span></span><br><span class="line"><span class="comment">%控制顶点的首末端点和给定型值点的首末端点重合</span></span><br><span class="line"><span class="keyword">if</span>(column == <span class="number">2</span>)</span><br><span class="line">    dpt1=[<span class="number">0</span> <span class="number">1</span>];<span class="comment">%给定首数据点切矢</span></span><br><span class="line">    dptn=[<span class="number">-1</span> <span class="number">0</span>];<span class="comment">%给定末数据点切矢</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dpt1=[<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];<span class="comment">%给定首数据点切矢</span></span><br><span class="line">    dptn=[<span class="number">-1</span> <span class="number">0</span> <span class="number">0</span>];<span class="comment">%给定末数据点切矢</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">dU=<span class="built_in">zeros</span>(<span class="number">1</span>,n+k+<span class="number">3</span>);  <span class="comment">%节点增量，△U=Ui+1-Ui</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=k+<span class="number">1</span>:n+k<span class="number">-1</span></span><br><span class="line">    dU(<span class="built_in">i</span>)=U(<span class="built_in">i</span>+<span class="number">1</span>)-U(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%求解线性方程组获得控制顶点向量，A*D=E,A为系数矩阵，元素为B样条基函数的值；D是控制顶点列向量；E是列向量</span></span><br><span class="line">A=<span class="built_in">zeros</span>(n);</span><br><span class="line"><span class="keyword">if</span>(column == <span class="number">2</span>)</span><br><span class="line">    E=<span class="built_in">zeros</span>(n,<span class="number">2</span>);  <span class="comment">%2D curve</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    E=<span class="built_in">zeros</span>(n,<span class="number">3</span>);  <span class="comment">%3D curve</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>)=<span class="number">1</span>;  <span class="comment">%切矢条件a1=1,b1=c1=0</span></span><br><span class="line">A(n,n)=<span class="number">1</span>;  <span class="comment">%切矢条件an=bn=0,cn=1</span></span><br><span class="line">E(<span class="number">1</span>,:)=pt(<span class="number">1</span>,:)+(dU(<span class="number">4</span>)/<span class="number">3</span>)*dpt1;    <span class="comment">%首端点条件</span></span><br><span class="line">E(n,:)=pt(n,:)-(dU(n+<span class="number">2</span>)/<span class="number">3</span>)*dptn;  <span class="comment">%末端点条件</span></span><br><span class="line"><span class="comment">%计算系数矩阵A的元素a,b,c以及列向量E的元素e的值</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:n<span class="number">-1</span>  </span><br><span class="line">    A(<span class="built_in">i</span>,<span class="built_in">i</span><span class="number">-1</span>)=dU(<span class="built_in">i</span>+<span class="number">3</span>).^<span class="number">2</span>/(dU(<span class="built_in">i</span>+<span class="number">1</span>)+dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>));                  <span class="comment">%a的值</span></span><br><span class="line">    A(<span class="built_in">i</span>,<span class="built_in">i</span>)=dU(<span class="built_in">i</span>+<span class="number">3</span>)*(dU(<span class="built_in">i</span>+<span class="number">1</span>)+dU(<span class="built_in">i</span>+<span class="number">2</span>))/(dU(<span class="built_in">i</span>+<span class="number">1</span>)+dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>))+...  <span class="comment">%b的值</span></span><br><span class="line">        dU(<span class="built_in">i</span>+<span class="number">2</span>)*(dU(<span class="built_in">i</span>+<span class="number">3</span>)+dU(<span class="built_in">i</span>+<span class="number">4</span>))/(dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>)+dU(<span class="built_in">i</span>+<span class="number">4</span>));</span><br><span class="line">    A(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>)=dU(<span class="built_in">i</span>+<span class="number">2</span>).^<span class="number">2</span>/(dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>)+dU(<span class="built_in">i</span>+<span class="number">4</span>));                  <span class="comment">%c的值</span></span><br><span class="line">    E(<span class="built_in">i</span>,:)=(dU(<span class="built_in">i</span>+<span class="number">2</span>)+dU(<span class="built_in">i</span>+<span class="number">3</span>))*pt(<span class="built_in">i</span>,:);                               <span class="comment">%e的值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">D=A\E;  <span class="comment">%解方程组，获得去除首末端点的控制顶点向量</span></span><br><span class="line">D=[pt(<span class="number">1</span>,:);D;pt(n,:)]; <span class="comment">%控制顶点向量，控制顶点比数据点多两个，加上首末端点</span></span><br><span class="line">[s,t]=<span class="built_in">size</span>(D);  <span class="comment">%s：控制点数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%第三步：求出Nurbs曲线*****************************</span></span><br><span class="line">dt=<span class="number">0.001</span>;  <span class="comment">%Nurbs曲线插值密度，dt越小，越光滑</span></span><br><span class="line">P=[];      <span class="comment">%Nurbs曲线</span></span><br><span class="line">syms dx;   <span class="comment">%定义节点间的递增变量为变量dx</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=k+<span class="number">1</span>:s</span><br><span class="line">    u=U;</span><br><span class="line">    d=sym(D);</span><br><span class="line">    <span class="comment">%每次迭代后将d恢复初值</span></span><br><span class="line">    <span class="keyword">for</span> m=<span class="number">1</span>:k</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="built_in">i</span>-k:<span class="built_in">i</span>-m</span><br><span class="line">            alpha(<span class="built_in">j</span>)=(dx-u(<span class="built_in">j</span>+m))/(u(<span class="built_in">j</span>+k+<span class="number">1</span>)-u(<span class="built_in">j</span>+m));</span><br><span class="line">            d(<span class="built_in">j</span>,:)=(<span class="number">1</span>-alpha(<span class="built_in">j</span>))*d(<span class="built_in">j</span>,:)+alpha(<span class="built_in">j</span>)*d(<span class="built_in">j</span>+<span class="number">1</span>,:);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%带入变量dx求出各节点区间[ui,ui+1]内m=3的控制点d</span></span><br><span class="line">    M=subs(d(<span class="built_in">i</span>-k,:),dx,(u(<span class="built_in">i</span>):dt:(u(<span class="built_in">i</span>+<span class="number">1</span>)-dt))&#x27;);    <span class="comment">%节点区间内的插值点替换dx</span></span><br><span class="line">    P=[P;double(M)];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">M=subs(d(s-k,:),dx,<span class="number">1</span>);</span><br><span class="line">P=[P;double(M)];<span class="comment">%补上最后一个点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%第四步、绘制给定型值点、控制点及其Nurbs曲线*****************************</span></span><br><span class="line"><span class="keyword">if</span>(column == <span class="number">2</span>)  <span class="comment">%2D curve</span></span><br><span class="line">    <span class="built_in">plot</span>(pt(:,<span class="number">1</span>),pt(:,<span class="number">2</span>),<span class="string">&#x27;*r&#x27;</span>);  <span class="comment">%绘制型值点</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot</span>(D(:,<span class="number">1</span>),D(:,<span class="number">2</span>),<span class="string">&#x27;b-o&#x27;</span>);   <span class="comment">%绘制控制点</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot</span>(P(:,<span class="number">1</span>),P(:,<span class="number">2</span>),<span class="string">&#x27;r&#x27;</span>);     <span class="comment">%绘制nurbs曲线</span></span><br><span class="line">    <span class="built_in">hold</span> on;  </span><br><span class="line"><span class="keyword">else</span>             <span class="comment">%3D curve</span></span><br><span class="line">    <span class="built_in">plot3</span>(pt(:,<span class="number">1</span>),pt(:,<span class="number">2</span>),pt(:,<span class="number">3</span>),<span class="string">&#x27;*r&#x27;</span>); <span class="comment">%绘制型值点</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot3</span>(D(:,<span class="number">1</span>),D(:,<span class="number">2</span>),D(:,<span class="number">3</span>),<span class="string">&#x27;b-o&#x27;</span>);   <span class="comment">%绘制控制点</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot3</span>(P(:,<span class="number">1</span>),P(:,<span class="number">2</span>),P(:,<span class="number">3</span>),<span class="string">&#x27;r&#x27;</span>);     <span class="comment">%绘制nurbs曲线</span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">axis equal;</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机科学，计算机图学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NURBS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSharp系列（二）类Class的概念</title>
      <link href="/2022/01/3.2Csharp%E7%AC%94%E8%AE%B02/"/>
      <url>/2022/01/3.2Csharp%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-center-4"><center>引子</center></h2><p>  👋这里是Visen.我参考刘老师课程和一些文档，对接下来更新的<strong>Csharp基础学习</strong>的框架进行了梳理。</p><p>主体部分如下所示，而为了方便其理解，会更新一些扩展内容，使得整个主体具有连贯性，以保证知识的完整性和学习的流畅度</p><ol><li>面向对象思想：理解类的思想，贯穿整个章节</li><li>Csharp的词法结构：讲解C#语言程序如何被编译，有哪些基础元素</li><li>Csharp基本概念：类型、变量与常量、方法等。方法概述：方法的概念和方法的基础使用（为后续章节准备</li><li>表达式：概述和操作符的介绍</li><li>语句：详细讲解各个语句（foreach穿插进类中的迭代器和接口的理解）</li><li>类前导部分：常量，字段、属性、索引器，方法详解，事件</li><li>类详解：类的成员</li><li>接口详解</li><li>结构</li></ol><p>扩展部分为命名空间、委托、枚举、事件、方法和其他函数成员、结构体</p><p>专项部分：数组、字符串、LINQ、Lambda表达式</p><p>程序由<strong>关键字</strong>、<strong>表达式</strong>和<strong>运算符</strong>组成的<strong>语句</strong>组成</p><p>待更新</p><p>本篇介绍面向对象的思想，可以理解为把架子先摆好，后续把书放上去。在入门的时候，我曾经说过C#程序主体是类，甚至连程序都是类，这也是面向对象语言的特点，该篇可以在复习中慢慢体会。</p><hr><h2 id="center-何为“面向对象”"><center>何为“面向对象”</h2><p>    我们生活中经常会遇到很多定义或者概念，我相信大家肯定也会困惑，为什么这样定义或者说出于什么目的去把这类事物描述出来</p><p>   比如为什么有加法？这个大家肯定都能解释了，是为了满足生活中计算的需要。加法对应的就是加法的逻辑，你脑袋里第一个思考的肯定是两个数对应的位相加，甚至连计算的方法都想好了。</p><p>能不能有一种方法能把这个思考过程表示出来呢？有，面向对象！</p><ol><li>首先我们得有需求，发明东西肯定是为了简便，为了生产。面向对象的需求是，想要<strong>描述出我想编程的所有现实事物</strong>（以汽车为例）</li><li>那现实事物对应哪些特点？我们大脑认出那是辆汽车，肯定是得有四个轮子，有汽车品牌，可以移动等等。那我们<strong>抽象</strong>出来完成<strong>建模</strong>，让我们程序模拟大脑的思考过程。可以得到程序中汽车的模型，以后碰到个东西，程序比对判断是否符合这个模型。符合的话，我们会喊它是一种/类汽车（我们定义的<strong>汽车类</strong>）—— <strong>定义类</strong>：从实际到抽象</li><li>前一步只是抽象出汽车这个概念呀，那怎么描述现实的汽车呢？对啊，那比如我碰到个现实中的比亚迪电动汽车（<strong>待描述的对象</strong>），程序怎么用刚才定义的汽车类去描述？有没有发现其实这是<strong>定义类</strong>的逆过程，<strong>把抽象转化成现实事物</strong>，我们把这过程称为<strong>实例化</strong>，程序中表示的对象称为<strong>实例</strong></li></ol><p>思考完后，进行总结：</p><blockquote><p>类（class）是对现实世界事物的模型，将现实事物进行抽象，事物包括“物质”（实体）与“运动”（逻辑）</p></blockquote><p>比如，汽车有四个轮子（实体）和能够运动（逻辑）</p><blockquote><p>对象也叫实例，现实中称为对象，程序世界称为实例，是类经过实例化后得到的内存中的实体</p></blockquote><p>通过类，我们可以创建对象，这就是实例化</p><blockquote><p>面向对象编程也就是针对现实中的具体事物进行编程，包含定义类和实例化的过程</p></blockquote><hr><h2 id="CSharp里的面向对象">CSharp里的面向对象</h2><p>理解完面向对象编程，那Csharp被设计如何表现或实现面向对象呢？使用过其他的面向对象语言（C++、Java、Python、Javascript等）的小伙伴，可以发现只是大同小异</p><h3 id="定义类">定义类</h3><blockquote><p>Csharp中采用单词Class的程序块表示某个<strong>类</strong>以及该类的特征（<strong>成员</strong>）</p></blockquote><p>我们先介绍类的三大成员，也就是类的特征。我们翻看微软的某个class的时候，都能发现这里介绍的这三大成员占了大半部分（后续成员会在后面进行讲解）</p><ul><li><p><strong>属性Property</strong>：存储数据，组合起来表示类或者对象当前的<strong>状态</strong>。比如car汽车类，有Price价格属性（car.Price）、Brand品牌属性（car.Brand）、Power能源属性（car.Power）等等</p></li><li><p><strong>方法Method</strong>：由C语言的函数function进化而来，表示类或者对象能做什么**（动作）**</p></li><li><p><strong>事件Event</strong>：类或者对象通知其他类或者对象的机制（<strong>不同类或对象的通信</strong>），为C#所特有（Java是通过其他方法实现），但记住不能滥用</p></li></ul><p>虽然微软文档中类Class基本都有这三大成员，但是某些特殊类或对象在这三个成员的侧重点不同</p><ul><li>模型类或对象侧重属性：如Entity Framework</li><li>工具类或对象侧重方法：如Math、Console</li><li>通知类或对象侧重事件：如各种Timer</li></ul><p>这里我们以上述的比亚迪电动汽车（<strong>对象</strong>）为例，它的特征是</p><ul><li>标价20万</li><li>品牌是比亚迪</li><li>能源是电池</li><li>具有四个轮子</li><li>能够移动</li></ul><p>定义的汽车类，它应该具有特征：价格、品牌、能源、轮子数量、能够移动</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Price;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Brand;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Power;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> WheelNum；</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Move</span>() <span class="comment">//注意方法名的首字母大写</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I can move&quot;</span>); <span class="comment">//命令行输出I can move</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//事件（这里无）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例化">实例化</h3><blockquote><p>Csharp中使用<strong>New操作符</strong>创建类的实例，并将实例附着到<strong>引用变量</strong>上</p></blockquote><p>正常创建类的实例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car mycar = <span class="keyword">new</span> car(); <span class="comment">//实例化，并使用引用变量mycar来作为附着</span></span><br></pre></td></tr></table></figure><p>思考：如果没有引用变量呢？</p><p>x.y中的点操作符：成员访问操作符，能够访问类、对象或方法的成员。x.y语义上表示”x里的y成员“</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> car()).Text = <span class="string">&quot;My car&quot;</span>; <span class="comment">//创建实例，并将实例的Text属性赋值为My car，未附着，自动回收空间</span></span><br><span class="line">(<span class="keyword">new</span> car()).ShowDialog[]; <span class="comment">//创建实例，并将实例通过窗口显示，未附着，自动回收空间</span></span><br></pre></td></tr></table></figure><p>我们发现，系统读取到到<code>;</code>，代表该行程序已经结束，系统会自动检查该行程序中某些数据是否被使用（是否附着到引用变量上），如果未使用，则回收该部分空间。表现为<strong>不使用引用变量，就无法连续地访问和操作同一个实例</strong>。</p><p>更改后：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">car mycar; <span class="comment">//声明属于car类的引用变量mycar(告诉系统，需要使用该数据，别销毁)</span></span><br><span class="line">mycar = <span class="keyword">new</span> car(); <span class="comment">//实例化</span></span><br><span class="line"><span class="comment">//可简写为 car mycar = new car(); </span></span><br><span class="line"></span><br><span class="line">mycar.Text = <span class="string">&quot;My car&quot;</span>; <span class="comment">//把系统保留的引用变量mycar的Text属性赋值My car</span></span><br><span class="line">mycar.ShowDialog(); <span class="comment">//把系统保留的引用变量mycar通过窗体展示</span></span><br></pre></td></tr></table></figure><p>总结：按照刘铁猛老师的讲解，引用变量与实例的关系可以理解为孩子与气球</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有孩子（引用变量）没有气球（实例）❌</span></span><br><span class="line">car mycar;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有气球（实例）没有孩子（引用变量）❌</span></span><br><span class="line"><span class="keyword">new</span> car();</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个孩子（引用变量）牵着同一个气球（实例）✅</span></span><br><span class="line">car mycar1; </span><br><span class="line">car mycar2;</span><br><span class="line">mycar1 = <span class="keyword">new</span> car();</span><br><span class="line">mycar2 =  mycar1; <span class="comment">//多个孩子（引用变量）牵着同一个气球（实例）</span></span><br><span class="line">mycar1.Text = <span class="string">&quot;mycar&quot;</span>;</span><br><span class="line">mycar2.ShowDialog(); </span><br></pre></td></tr></table></figure><h2 id="静态成员和实例成员">静态成员和实例成员</h2><p>定义类的时候，相信大家应该发现了Move方法前面有个<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/static"><strong>static关键字</strong></a>，加与不加static声明的成员有什么不同呢？</p><blockquote><p>关键字是预定义的保留标识符，作用是让程序员标记和区分不同的使用情况</p></blockquote><p>这里的static用来声明静态（static）成员，而静态成员对应着实例成员。成员不仅包括字段、方法、属性、运算符、事件和构造函数，还包括类class，类中的“成员”可以是类</p><ul><li>静态（static）成员，也叫类成员，在语义上表示“类的成员”</li><li>实例（非静态）成员，也叫对象成员，在语义上表示“对象的成员”</li></ul><blockquote><p><strong>通俗理解</strong>：实例表示的是对象（类实例后）的状态，静态表示的是该类的状态。理解起来就像某班级某学生的学习状态（学习刻苦，态度认真）和该班的学生状态（尖子班，学习氛围浓郁）</p></blockquote><p>那么这两种成员声明方式该如何选择，或者回到那个问题，有什么不同？</p><table><thead><tr><th style="text-align:center">不同</th><th style="text-align:left">静态成员</th><th style="text-align:left">非静态成员</th></tr></thead><tbody><tr><td style="text-align:center">访问方法</td><td style="text-align:left">必须由类名调用，不能使用对象调用<br />静态成员只属于类，访问时需使用“<strong>类名.静态成员</strong>”</td><td style="text-align:left"><strong>必须实例化</strong>后，再使用“<strong>对象.实例成员</strong>”进行访问</td></tr><tr><td style="text-align:center">不同类的成员</td><td style="text-align:left"><strong>静态类</strong>不能实例化，只能有静态成员不能有实例成员</td><td style="text-align:left"><strong>非静态类</strong>可以有静态成员和非静态成员</td></tr><tr><td style="text-align:center">类第一次<strong>加载时内存分配</strong></td><td style="text-align:left">该类下的所有的静态成员都会被加载<br />静态成员只分配一次，有且只有一份存储空间<br />无论new出多少个实例，它也只是有那一个空间静态成员会被加载到静态存储区，直到程序退出时才会被释放</td><td style="text-align:left">实例成员有多少个对象，就会创建多少个对象<br />每产生一个实例都要重新分配一个存储空间</td></tr></tbody></table><p>总结：</p><ol><li><p>静态成员不能实例化，只能由类名调用——“<strong>类名.静态成员</strong>”；第一次加载时，会分配一个存储空间，new也是引用这部分空间</p></li><li><p>非静态成员<strong>必须实例化</strong>后，再使用“<strong>对象.实例成员</strong>”进行访问；有多少个对象，就会创建多少个对象，需注意内存管理</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Net开发 </category>
          
          <category> Csharp基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现Word自动化</title>
      <link href="/2021/12/2.1%E6%93%8D%E4%BD%9CExcel%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%A5Word%E6%8C%87%E5%AE%9A%E5%8C%BA%E5%9F%9F/"/>
      <url>/2021/12/2.1%E6%93%8D%E4%BD%9CExcel%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%A5Word%E6%8C%87%E5%AE%9A%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 办公自动化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win系统重装</title>
      <link href="/2021/12/1.1Win%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/"/>
      <url>/2021/12/1.1Win%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-4"><center>引子</h2><p>    👋这里是Visen.旧电脑实在是太没用了，创建收纳盒也是为了以后换电脑/系统准备，本以为实在没救了，打开Matlab或者Vs都够呛，后来升级了Windows11，直接飞升一个档，竟然比肩舍友新电脑，同时开Matlab+VS无压力？！这下五年的老伙计还得陪我再战五年</p><p>    这里以Win11系统安装给大家提供小白式刷机教程，该刷机方法会<strong>清空C盘文件</strong>（桌面、文档等都位于C盘），记得做好备份，而其他盘符不影响。值得注意的是，有些软件的关键性文件会在C盘，推荐刷机后重新安装软件，并集中安装在某个盘（D盘）</p><hr><h2 id="center-刷机准备"><center>刷机准备</h2><h3 id="硬件准备">硬件准备</h3><blockquote><p>电脑：小新700 U盘：闪迪</p></blockquote><ul><li>i5-6300HQ Intel的64位处理器</li><li>8.00 GB 运存（原厂4G，我扩展为8G）</li><li>原机为500G硬盘，我加了一个固态，作为系统盘</li></ul><p>U盘文件在制作启动盘会删除，必须提前备份或者选择闲置U盘</p><h3 id="刷机工具">刷机工具</h3><blockquote><p>下载地址：<a href="https://www.123pan.com/s/nmk9-vu88H">微PE工具箱 v2.2</a></p></blockquote><p>该版本已直接支持绕过TPM2.0安装原版windows11镜像，像刷Win10一样安装Win11，而且制作完后U盘只会显示一个盘(已存收纳盒)</p><p>将U盘制作成启动盘：</p><ul><li><p>插入一个空的U盘，点击下载的WePE.exe文件，再点击右下角制作系统启动盘</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121036210.png" alt="image-20220108153508570"></p></li><li><p>默认设置，点击立即装进U盘。制作时使用exFAT格式（FAT32格式兼容性好，但不支持4GB以上的文件；NTFS啥都好，就是会减短闪存的寿命）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121036032.png" alt="image-20220108153746212"></p></li><li><p>等待完成，系统启动盘制作完成</p></li></ul><h3 id="官方镜像">官方镜像</h3><p>如果只想给这个电脑安装，那么就把镜像放在除C盘的其他盘符。如果想要以后随时都能安装，就把镜像下载到刚制作好的启动盘中</p><p>这里更新下如何找官方纯净镜像：</p><h4 id="微软官网">微软官网</h4><p>进入<a href="https://www.microsoft.com/zh-cn/software-download/windows11">微软官网下载</a>,选择<strong>下载Win11磁盘映像(ISO)</strong>-&gt;<strong>Window 11(Multi-edition ISO)</strong>-&gt;<strong>简体中文</strong>，然后浏览器下载器会开始下载。这里推荐使用NDM一类下载器开多线程下载（收纳盒里有）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121036809.png" alt="image-20220108123040069"></p><h4 id="UUP网站">UUP网站</h4><p><a href="https://proxied.uupdump.net/?lang=zh-cn">UUP 网站</a>是基于Microsoft的API接口开发的，可直接下载到微软原版镜像资源，包括各种渠道的最新版本，选择要下载的系统，可选版本、语言等，然后创建下载包。</p><ul><li><p>点击下载，选择64位处理器最新版本</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121036954.png" alt="image-20220108170232630"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121036978.png" alt="image-20220108170612895"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037577.png" alt="image-20220108170726872"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037795.png" alt="image-20220108184004571"></p></li><li><p>下载后解压会是一个 <strong>“uup_download_windows.cmd”</strong> 批处理文件，运行等待下载镜像文件，之后会合并 ISO 镜像。整个过程比较久，耐心等待。</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037795.png" alt="image-20220108184233360"></p></li></ul><h4 id="MSDN">MSDN</h4><p>可以从<a href="https://next.itellyou.cn/Original/Index">MSDN</a>登录下载纯净镜像，MSDN是个人维护的系统纯净镜像站，刷机必须知道呀！这里推荐迅雷等加速下载Consumer Editions（消费者版）中的Win 11专业版（Windows 11 Pro）。（AMD处理器选第三个）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037380.png" alt="image-20220108111024591"></p><p>这三个方式都可以，推荐使用第一个，可以调用多线程下载，不用考虑云盘限速和国外服务器的问题</p><blockquote><p>Window11和Office激活工具</p></blockquote><h3 id="激活软件">激活软件</h3><p>推荐下载<a href="https://otp.landian.vip/zh-cn/">Office Tool Plus</a>一键部署安装Office，可以自定义office版本和组件，并且自带激活，还能修复一些office的小问题，比如被检测到盗版，可以更改KMS主机号</p><p><a href="https://www.123pan.com/s/nmk9-zK88H">HEU_KMS_Activator_v24.5.0</a>可同时激活Window11和Office</p><p>下载的话可能被Edge浏览器默认下载器拦截，可以在浏览器设置中关闭Windows Smartscreen筛选器</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037028.png" alt="image-20220308112826622"></p><hr><h2 id="center-Win-Office安装"><center>Win+Office安装</h2><h3 id="设置UEFI启动">设置UEFI启动</h3><blockquote><p>重启电脑，进入Bios系统（每个品牌会有区别，参考<a href="https://blog.csdn.net/l_mloveforever/article/details/112756940">CSDN某博主</a>），更改开机启动方式为UEFI启动(Bios系统里的Boot选项)</p></blockquote><p><strong>笔记本</strong></p><ul><li>ThinkPad（开机按f1，部分新型号可以在重新启动时启动按f1，少数机型是Fn+F1或F2）</li><li>惠普hp（启动和重新启动时按f2或者F10，或者先按ESC再按F10）</li><li>索尼sony（启动和重新启动时按f2或者ASSIST键）</li><li>戴尔dell（启动和重新启动时按f2）</li><li>宏碁acer（启动和重新启动时按f2）</li><li>东芝toshiba（冷开机时按esc然后按f1，或者F2）</li><li>惠普康柏hp compaq（开机到右上角出现闪动光标时按f10，或者开机时按f10）</li><li>富士通fujitsu（启动和重新启动时按f2）</li><li>三星Samsung（启动和重新时按f2）</li><li>联想Lenovo(启动时按F2或Fn+F2，部分机型需关机时按Novo恢复键)</li><li>华硕Asus（启动时按F2）</li><li>微星msi（启动时按Delete）</li><li>神舟Hasee（启动时按F2）</li><li>小米、海尔、明基、技嘉、方正、清华同方、雷神、未来人类、外星人、七喜等品牌笔记本也是F2</li></ul><p><strong>台式机</strong></p><ul><li>进入BIOS设置主要按键：DEL, ESC, F1, F2, F8, F9, F10, F12</li><li>组装机不同主板台式机进入BIOS按键： Award BIOS：按“Del”键 AMI BIOS：按“Del”或“ESC”键 Phoenix BIOS：按“F2”键</li><li>品牌台式机进入BIOS按键IBM/thinkpad（冷开机按F1，部分新型号可以在重新启动时启动按F1）</li><li>惠普hp（启动和重新启动时按f2或者F10）</li><li>索尼sony（启动和重新启动时按F2）</li><li>戴尔dell（启动和重新启动时按F2）</li><li>宏碁acer（启动和重新启动时按F2）</li><li>东芝toshiba（冷开机时按esc然后按F1）</li><li>惠普康柏hp compaq（开机到右上角出现闪动光标时按F10，或者开机时按F10）</li><li>富士通fujitsu（启动和重新启动时按F2）</li><li>三星Samsung（启动和重新时按F2）</li><li>联想Lenovo(启动时按F2或Fn+F2，部分机型需关机时按Novo恢复键)</li><li>华硕Asus（启动时按F2）</li><li>大多数中国大陆国产和台湾品牌（启动和重新启动时按F2）</li></ul><h3 id="PE系统清C盘">PE系统清C盘</h3><blockquote><p>打开分区软件软件清理出C盘</p></blockquote><ol><li><p>U盘启动，进入PE系统，点击分区助手，将D盘前面的空间全部快速删除，并点击左上角的应用，点执行</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037949.png" alt="image-20220111214551342" style="zoom:80%;" /><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037988.png" alt="image-20220111214640247"></p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037222.png" alt="image-20220111214815732"  /></li></ol><h3 id="安装系统">安装系统</h3><blockquote><p>win10和win11都支持MediaCreationTool安装，直接挂载安装就可以了，不过得注意安装过程中清理盘</p></blockquote><ol><li><p>右键下载好的镜像（U盘内或者硬盘内），点击文件管理器打开（或者右键挂载），将多出一个DVD驱动器</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037934.png" alt="image-20220111215223990"></p></li><li><p>点击setup.exe文件，开始安装，选择Win11专业版-&gt;没有激活密钥-&gt;选择安装位置，选择刚才删除后的区域作为C盘，等待安装完毕后，开始重启拔掉U盘，迫使让它从硬盘启动。后续就是进行一些win的常用设置</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037334.png" alt="image-20220111215313882"></p></li></ol><h3 id="安装Office">安装Office</h3><blockquote><p>这里使用Office Tool Plus来实现自动安装office</p></blockquote><p>1.解压文件后，点击Office Tool Plus.exe文件，点击部署，开始设置</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037765.png" alt="image-20220111220002555"></p><ol start="2"><li>这里我按需选择了Office 专业增强版 2021里面的三大件——简体中文版，点击开始部署，等待部署完成就可以了</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037561.png" alt="image-20220111220324329"></p><h3 id="激活Win和Office">激活Win和Office</h3><blockquote><p>这里使用HEU_KMS_Activator来智能激活</p></blockquote><ol><li>直接点击软件如果没反应，是win的安全系统不让打开程序，点击开始，搜索<strong>病毒和威胁防护</strong>，点击病毒和威胁防护设置 管理设置</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037058.png" alt="image-20220112091329035"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037835.png" alt="image-20220112091419800"><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121037753.png" alt="image-20220112091534589"></p><ol start="2"><li>关闭实时保护并划到最下面的排除项，点击添加或删除排除项，将HEU_KMS_Activator所处文件夹添加进去</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121038074.png" alt="image-20220112093619410"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121038250.png" alt="排除项"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121038467.png" alt="image-20220112092108075"></p><ol start="3"><li><p>点击exe文件，启动程序，进去直接点击开始，等待激活就可以了，还能查看激活状态</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121038916.png" alt="image-20220112092208527"></p></li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121038711.png" alt="image-20220112093917631"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121038726.png" alt="image-20220112094101939"></p><p>可能出现的问题：Office激活后，发现一直提示：你的许可证不是正版，你可能是盗版软件的受害者？</p><p>参考这个<a href="https://www.coolhub.top/archives/122">文章</a></p><p>首先，使用Office Tool Plus查看激活信息(这里一般显示0.0.0.0:1688)</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202207242022310.png" alt="image-20220720192403893"></p><p>更改KMS主机号为<code>172.16.0.1</code>，点击修复就可以了</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202207242023133.png" alt="image-20220724202318520"></p><ul><li>如果你使用的是在线的 KMS，填写你使用的 KMS 的主机地址即可。若不记得现在用的 KMS 地址，可以前往激活页面查看激活信息。</li><li>如果你使用的是诸如 KMS-VL-ALL 或者 HEU 之类的激活软件，填写172.16.0.1即可</li></ul><h2 id="驱动安装">驱动安装</h2><p>上述安完之后，发现很多朋友安装驱动时会碰到问题，这里提供比较全面的驱动安装</p><p><strong>方法一</strong>：下载驱动软件点击安装</p><ul><li><a href="https://guanjia.lenovo.com.cn/">联想电脑管家</a>：联想电脑直接安装这个电脑管家就完事了</li><li><a href="https://www.sysceo.com/dc">驱动总裁</a>：无绑定推广，无广告，一键智能安装和手动自选安装双安装模式，并提供离线版本下载</li><li><a href="http://dm.weishi.360.cn/home.html">360驱动</a>：360少见的好使工具，一般用完就卸载了哈哈哈</li></ul><p><strong>方法二</strong>：Win11系统自动检查**（推荐）**</p><p>系统现在支持自动安装驱动</p><p>点击设置-&gt;Window更新-&gt;高级选项-&gt;可选功能，下载安装里面的驱动就可以了</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121038895.png" alt="image-20220115193637113"></p><h2 id="微软VC-库安装">微软VC++库安装</h2><p>最近发现常用的一些工业软件，软件本身编程是调用了这些DLL库的，如果不安装微软的依赖库，可能会导致软件安装失败（比如Catia等）</p><p>所以这里提供<a href="https://www.123pan.com/s/nmk9-Vl88H">微软运行库</a></p><p>一直点下一步就好了，如果不用office二次编程，也不需要用到office Runtime运行时。</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121038054.png" alt="image-20220308110404944"></p><h2 id="系统设置修改">系统设置修改</h2><p><a href="https://lestore.lenovo.com/detail/24175">Dism++</a>：优化对Windows的一些设置</p><p><a href="https://www.123pan.com/s/nmk9-tK88H">Windows11自我改善</a>：将右键从Windows11改回Windows10风格</p><p><a href="https://gitee.com/BluePointLilac/ContextMenuManager">ContextMenuManager</a>：管理右键，增加一些高效右键选项，删除一些不常使用的右键，提供<a href="https://www.123pan.com/s/nmk9-LK88H">直接下载</a></p><p><a href="https://zhuanlan.zhihu.com/p/396113249">Windows主题美化</a>：根据文章可以实现Windows美化，切记！美化终点是初始化，哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
          <category> 自用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSharp系列（一）入门</title>
      <link href="/2021/12/3.1Csharp%E7%AC%94%E8%AE%B01/"/>
      <url>/2021/12/3.1Csharp%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-center-3"><center>引子</center></h2><p>    👋这里是Visen.最近在质疑自己学习的高效性，目前学习形式主要是一边屏幕是书籍/视频，另一边是Gitmind做思维导图，我是中间的转换器。虽然发现思维导图做的不错，但知识没进脑子，后续想再查找知识，思维导图省略得太多，还得一个个点开才能穿起来，思维常常打断，又不得不去翻书，吭哧吭哧却也没了之前读时的通透。还是需要改变了！💪但是还是不肯丢失思维导图，刚好md可以使用Mermaid插件实现这功能，md文件又支持局内搜索，我懒得去搞云盘存储，以后学习笔记放到这个博客，也希望大家能够能给予意见。</p><p>    本系列全程使用Net4.8框架下控制台应用（console）来进行编程，开发IDE使用visual studio。虽然更新Net6+C#10.0后，程序样式可以采取新的简化样式（隐式using指令），但是我考虑直接过渡学习路线很陡峭，更新节奏过于激进，反而一知半解</p><p>学习路线为__语言C#__-&gt;<strong>类库</strong>-&gt;<strong>框架Net</strong>，包括：</p><ul><li>介绍入门知识：C#学习方法、学习安排以及开发环境</li><li>介绍C#基础知识等</li><li>C#进阶知识和平时遇到的编程问题和实现的demo</li></ul><p>以刘铁猛《<a href="https://www.bilibili.com/video/BV13b411b7Ht/?spm_id_from=333.788.recommend_more_video.4">C#语言入门详解</a>》B站视频为主体，配合刘老师当时的<a href="https://www.123pan.com/s/nmk9-v788H">微软C#语言规范</a>并比对<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/">微软最新C#文档</a>，再根据自己理解进行记录和编辑，不追求微软文档的全面而在乎把各部分理清，在使用时能快速理解，更好翻文档和上手。</p><p>扩展书籍推荐：<a href="https://www.123pan.com/s/nmk9-d788H">果壳里的C#</a>、<a href="https://www.123pan.com/s/nmk9-Au88H">CLR via C#</a>、<a href="https://csharpindepth.com/">C# in DEPTH</a>、<a href="https://www.123pan.com/s/nmk9-ou88H">其他</a></p><p>本次更新的是入门篇，记录<strong>C#简介</strong>、<strong>学习方法</strong>和<strong>开发环境</strong></p><hr><h2 id="center-CSharp与Net"><center>CSharp与Net</h2><h3 id="Csharp是什么？">Csharp是什么？</h3><p>    C#（Csharp）由Delphi语言开发者Anders Hejlsberg在构建.Net框架期间主持开发，是微软推出的一款<strong>面向对象</strong>的编程语言，其语法与 C++类似，但在编程过程中要比 C++ 简单。</p><p>其特点主要是</p><ul><li><p><strong>简单安全</strong>：不使用指针（并不是没有指针），数据类型比C、C++、Java多，并且固定大小（可在文档中查看）；提供namespace命名空间来管理C#文件，相当于一个文件夹，里面包含一个或多个类；不允许一些不安全操作</p></li><li><p><strong>面向对象</strong>（下一篇将详细讲解）</p><ul><li>封装：代码封装，使用定义好的类、方法等，不需要考虑细节，只需要知道对应参数（提升代码安全性）</li><li>继承：支持对父类的继承，但仅支持单继承（体现代码复用性）</li><li>多态：通过继承和实现接口的方式，让类或接口中的成员表现出不同的作用（体现代码复用性和灵活性）</li></ul></li><li><p><strong>支持跨平台</strong>：当然，目前C#语言支持跨平台，但是一些框架不支持，比如WPF等</p></li><li><p><strong>开发多种类型的程序</strong>：进入Visual Studio后，可选择各类项目</p></li></ul><h3 id="Net？两者关系？">Net？两者关系？</h3><blockquote><p>.NET是开发平台（框架Framework），是一个<strong>抽象</strong>的平台概念</p></blockquote><p>.NET 框架是一个多语言组件开发和执行环境。.NET SDK（Software Development Kit，软件开发工具包）是一组用于开发和运行 .NET 应用程序的库和工具，是我们能接触到的<strong>具体的</strong>库和工具。（NET SDK是Net概念的具象化/实例化）</p><p>包括以下组件：CLI、虚拟机CLR（Common Language Runtime,公共语言运行时）、dotnet驱动程序、编译器等。</p><p>具体可以查看<a href="https://docs.microsoft.com/zh-cn/dotnet/core/introduction">微软 Net简介</a></p><blockquote><p>C# 是一种在.NET平台上运行的编程语言</p></blockquote><p>进入VS软件，可以看到有编程语言的选择，比如Python、C++等，而在.NET平台上C#使用最多。</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121039049.png" alt="Img"></p><p>注意：它并不是.NET的一部分，<a href="http://xn--3dsz4sw0ecx3b33h.NET">总是运行在.NET</a> Framework中才被误解</p><hr><h2 id="center-开发环境"><center>开发环境</h2><p>.NET的集成开发环境包括：Visual Studio、Rider，但是后者在创建一些桌面端框架（Winform、WPF）时，表现得没VS便利，还是VS比较推荐</p><p>下面介绍VS的安装和使用</p><h3 id="环境安装">环境安装</h3><p>进入<a href="https://visualstudio.microsoft.com/zh-hans/vs/">官网</a>，这里推荐下载专业版，点击exe文件开始安装</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121039721.png" alt="image-20220117190954186"></p><p>进入Visual Studio installer安装所需模块（后续可修改），建议安装如下</p><ul><li>工作负荷：.Net桌面开发、通用Window平台开发、数据存储和处理</li><li>单个组件：勾选上Help Viewer</li><li>语言包：中文＋英文</li><li>安装位置：推荐C盘</li></ul><p>安装后点击启动，这里我们创建Window环境下的控制台Console项目开始学习</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040146.png" alt="Img"></p><p>命名后，点击创建（这里推荐使用特定地方来放置我们学习例程）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040163.png" alt="Img"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040764.png" alt="Img"></p><p>我们在main函数内输入cw，然后连续点击两下tab键，并输入hello,world，点击执行</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040115.png" alt="Img"></p><p>就能看到我们的第一个程序</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040650.png" alt="Img"></p><h3 id="C-in-VS">C# in VS</h3><p>程序的编写按照步骤分为编辑-&gt;编译-&gt;调试-&gt;发布</p><p>这里介绍开发工具是如何实现我们的编程开发步骤，顺便也将VS界面进行简单介绍，为后续学习做准备</p><p>需要注意的是，编译过程是依赖于Net框架的编译器，是隐式编译，这里不做讲解</p><h4 id="C-文件结构">C#文件结构</h4><blockquote><p>介绍C#代码是如何存放/C#设计之初是如何整理自己结构来方便开发的</p></blockquote><p><strong>类class构成程序主体（甚至程序本身也是类），namespace以树形结构来组织类和其他类型</strong></p><p>以我们运行的Hello，world程序为例</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040901.png" alt="image-20220118113746320"></p><p><code>解决方案Solution</code>中可存放着多个<code>项目Project</code>（对应于命名空间namespace），<code>项目Project</code>=<code>Program.cs</code>（C#程序，文件后缀cs代表csharp）+ <code>reference</code>（供程序主体using的引用集和C#配置文件） + <code>Properties</code>（程序配置文件，如程序的属性、程序各阶段的设置等）</p><ol><li>右击解决方案,点击添加-&gt;新建项目-&gt;添加一个控制台项目(Solution=Project1+Project2+…)</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040284.png" alt="image-20220118104758309"></p><ol start="2"><li>双击<code>Properties</code>,可以看见我们程序各个过程的设置，比如</li></ol><ul><li><p>创建阶段（软件图标，程序集名称、默认的命名空间、程序类型等），其中程序集信息对应着Assemblyinfo.cs。</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040933.png" alt="image-20220118105504398"></p></li><li><p>程序编辑阶段（所需的资源resource）</p></li><li><p>调试阶段（本地调试、远程调试还是使用Web浏览器调试）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040343.png" alt="image-20220118105903741"></p></li><li><p>生成阶段（生成时输出路径、软件适配的平台等）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040527.png" alt="image-20220119094819197"></p></li></ul><ol start="3"><li><p>右击<code>引用</code>-&gt;添加引用，唤出引用管理器，就可以对需引用的类库（类库=类的仓库=名称空间的物理基础）进行管理</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040656.png" alt="image-20220118114527992"></p></li><li><p>双击<code>Program.cs</code>，就能进入Csharp程序主体，展开树形结构，可以看到里面包含的类和方法（成员函数）</p></li></ol><h4 id="类库的引用">类库的引用</h4><blockquote><p>类库类似于python库，using（C#）相当于import（python），为程序提供了很高的扩展性和代码复用性。可以把自己程序重复使用，不用重复造轮子，在这里较早地介绍。引用分为<strong>DLL引用</strong>和<strong>项目引用</strong></p></blockquote><h5 id="DLL引用-黑盒引用">DLL引用(黑盒引用)</h5><p>DLL引用时，程序员没有源代码，需要查阅文档（记录ddl文件中有哪些名称空间，名称空间包含什么类，类中有什么方法），于是代码bug需要作者去更改，存在依赖关系。（优秀程序追求“高内聚”“低耦合”，耦合关系就是依赖关系，常用UML（通用建模语言）类图展示类和类库之间的关系，使用箭头表示依赖）</p><p>示例：引用微软的Form类</p><ol><li><strong>明确引用哪个库</strong>：微软的类可以查询help Viewer，找到该引用哪个类库</li></ol><ul><li><p>点击<code>帮助</code>-&gt;<code>添加和删除帮助内容</code>，把所需的微软文档（.NET API reference英语和Visual Studio 2015：Visual Basic和Visual C#）添加到本地</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040551.png" alt="image-20220118115915356" style="zoom: 80%;" /><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040678.png" alt="image-20220118120212545"  /><p>点击<code>帮助</code>-&gt;<code>查看帮助</code>-&gt;<code>在目录中显示主题</code>，就能看到我们添加的内容</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040863.png" alt="image-20220118112037749" style="zoom:80%;" /><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040783.png" alt="image-20220118125429108" style="zoom:80%;" /><p>搜索Form class（Form类)，会显示出该类的从属关系以及使用方法，可以知道我们应该引用System.Windows.Forms.dll文件<a href="https://docs.microsoft.com/zh-cn/dotnet/api/?view=net-6.0">微软直接提供的命名空间</a></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040080.png" alt="image-20220118125908145"></p></li></ul><ol start="2"><li><strong>开始引用</strong>：点击<code>项目管理器</code>—<code>右键引用/或者右键项目（这里的ConsoleApp）</code>—<code>添加引用</code>—<code>浏览</code>，选择引用文件</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040192.png" alt="image-20220118132103055"></p><ol start="3"><li><strong>引用后</strong>：可以双击该类库可在对象浏览器中查看，而在程序中使用<code>using System.Windows.Forms;</code>导入，因为目前程序中未使用代码颜色为灰色，使用后会变成黑色</li></ol>  <img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040770.png" alt="image-20220118132437172"  /><ol start="4"><li>但是我们可能会遇上一些情况：当使用某个库时，发现这个库是依赖于其他库，于是还得引用其他库，很不方便！这里微软提供了共享代码的机制——NuGet技术，将该库和该库引用的其他库打包成包文件，在线发布供人引用，而Nuget作为包管理开发工具。<ul><li>将包引用到解决方案Solution中：<code>右击解决方案</code>-&gt;<code>管理解决方案的Nuget程序包</code>，搜索并引用</li><li>将包引用到项目Project中：<code>右击项目内的引用</code>-&gt;<code>管理Nuget程序包</code>，搜索并引用</li></ul></li></ol><hr><h5 id="项目引用-白盒引用">项目引用(白盒引用)</h5><p>项目引用的文件有源代码，是自己创建或者别人开源项目</p><ol><li>引用项目Project到解决方案Solution：</li></ol><ul><li><p>将别人项目添加到解决方案中：<code>解决方案</code>-&gt;<code>右键添加</code>-&gt;<code>现有项目</code>，将项目引用进来</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040467.png" alt="image-20220118134931364" style="zoom: 80%;" /></li><li><p>新建自己项目添加到解决方案：<code>解决方案</code>-&gt;<code>右键添加</code>-&gt;<code>新建项目</code>，新建一些自己想建立的项目，比如类库</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040208.png" alt="image-20220118134957989" style="zoom: 80%;" /></li></ul><ol start="2"><li>引用解决方案中的项目otherProject到自己项目myProject：</li></ol><ul><li><code>右击项目Project</code>-&gt;<code>添加</code>-&gt;<code>引用</code>，开始引用</li></ul><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040225.png" alt="image-20220118135629403" style="zoom: 80%;" /><ul><li><p><code>项目</code>-&gt;<code>解决方案</code>-&gt;<code>勾选上待引用的库</code>，点击确定完成引用</p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040881.png" alt="image-20220118135932861" style="zoom: 80%;" /><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121040362.png" alt="image-20220118140016189" style="zoom:80%;" /></li></ul><h3 id="VS导航栏">VS导航栏</h3><blockquote><p>这里想介绍一下Visual Studio的导航栏，进一步介绍VS功能，后续不会在学习中产生工具不跟手的情况</p></blockquote><p>1.文件：可以新建、打开、添加、保存项目文件</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041611.png" alt="Img"></p><ol start="2"><li>编辑：在编写代码时，会用上的操作及其对应的快捷键，这里强调<code>高级</code>中的<code>设置文档的格式</code>，当编写完代码后，使用该命令会自动整理程序格式</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041898.png" alt="image-20220118140331266"></p><ol start="3"><li>视图：设置是否显示一些工具或者状态窗口，比如左右侧边栏和底部调试互动区显示哪些工具</li></ol><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041604.png" alt="image-20220118140715613"  /><ol start="4"><li>Git：代码托管，可以使用Github作为远程仓库，也可以使用本地仓库进行版本控制</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041971.png" alt="image-20220118140820971"></p><ol start="5"><li>项目：右击资源管理器里的项目Project也能实现</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041547.png" alt="image-20220118140946494"></p><ol start="6"><li>生成：对程序打包，生成exe等各类文件</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041972.png" alt="image-20220118141045925"></p><ol start="7"><li>调试、测试和分析：对软件进行调试、测试和分析（后续会详解）</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041901.png" alt="image-20220118141115830"></p><ol start="8"><li>工具：负责对VS进行工具管理，获取工具和功能就是跳转Vs installer，选项可以对VS进行设置等</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041940.png" alt="image-20220118141256967"></p><ol start="9"><li><p>扩展：VS给使用提供可玩性极高的扩展插件，让VS更加好用，比如我代码区的二次元背景就是安装了ClaudiaIDE插件（VScode用户应该不陌生）<img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041924.png" alt="image-20220118141729486"></p></li><li><p>窗口：对窗口显示进行管理，主要是窗口布局</p></li><li><p>帮助：最有用的功能之一，可以实时查看文档，并使用<code>F1</code>键完成搜索</p></li></ol><p>比如我在代码区，光标悬浮在String上就能看到简介，进一步点击F1键，唤起帮助，搜索该类或者该符号意义</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041021.gif" alt="VeryCapture_20220118142141"></p><hr><h2 id="center-学习方法"><center>学习方法</h2><p>介绍到这里，完全算是对C#语言和Visual Studio的入门，借这里对C#学习方法的讨论，想强调如何学习一门计算机语言或者说一类计算机知识</p><blockquote><p>回到最原汁原味的环境</p></blockquote><p>学习知识时候，应该找到最官方的书籍和资料，而不是选择那些拼凑的资料，书在于精而不在于多。学习C#则需要翻看微软文档，或常按F1，可在VS的帮助里查看，或者在官网中查看，这里提供官网链接：</p><ol><li><p><a href="https://docs.microsoft.com/zh-cn/dotnet/fundamentals/">Net 文档</a>：介绍Net的思想和模型，概念性东西比较多</p></li><li><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/">微软 C#文档</a>：将C#的一些概念讲得很透彻，并且提供C#编程指南和语法参考</p><p>编程指南：把C#学习分为两个部分，语言部分和Net平台部分，符合语言-&gt;类库-&gt;平台的学习路线</p><p>语法参考：编程工具书，可以查阅一些语法的用法，并配有可运行实例</p></li><li><p><a href="https://docs.microsoft.com/zh-cn/visualstudio/ide/default-keyboard-shortcuts-in-visual-studio?view=vs-2022">快捷键使用</a>：常用的一些快捷键可以在编程时候学习，提升自己的代码速度还防止键盘手</p></li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121041734.png" alt="image-20220118143148073"></p><blockquote><p>注意知识的衔接性</p></blockquote><p>这一点我很赞同刘铁猛老师的观点，他在讲解时，没有按照所谓的路线，先讲解一些语言枯燥的东西，然后再去使用，而是不断地武装自己。类似于，小学教乘法时，会先将加法，把加法练会了，我们自然而然就会乘法，实现知识的衔接。这一点，我们学习中应该进行借鉴，上手速度会有很大提升，而且没在使用中成长，是无法知道你的程序会出现什么bug</p><blockquote><p>多敲代码</p></blockquote><p>刘老师的很多例程真的很经典，能够让你在不断改进某一个程序的时候，对理论知识进行不断地探索，并且能让你有所思考，自己主动想着能不能再进一步。我反正在学习其代码的时候，学习其风格，思考问题的全面性，受益匪浅！</p><blockquote><p>持续进步</p></blockquote><p>刘老师很谦虚的表示看完视频并不代表学完了C#还应该继续使用一些搜索引擎和官方文档，进行进一步地学习，持续进步才能成为这方面的大牛！这里也希望大家能成为该语言方面的大牛！</p>]]></content>
      
      
      <categories>
          
          <category> Net开发 </category>
          
          <category> Csharp基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSharp学习记录</title>
      <link href="/2021/12/3.0C#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/12/3.0C#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>C#学习（刘铁猛）</p><p>前5章主要是讲解一些基础，后续的讲解方法体。当讲解完方法后，理解完写代码就是写方法体的，而接下来就是对方法体的讲解：分为操作符、表达式、语句等。<strong>var 和.GetType().FullName</strong></p><h1>第二章 类与对象、类成员简介</h1><blockquote><p>主要讲解类是什么，类与对象的关系，类的三大成员，类的静态成员与实例成员</p></blockquote><h3 id="一、类的理解">一、类的理解</h3><p>类（class）是对现实世界事物的模型，将现实事物进行抽象，事物包括“物质”（实体）与“运动”（逻辑）。</p><h3 id="二、类与对象的关系">二、类与对象的关系</h3><h5 id="1-类与对象的理解">1.类与对象的理解</h5><p>对象也叫实例，现实中称为对象，程序世界称为实例，是类经过实例化后得到的内存中的实体。通过类，我们可以创建对象，这就是实例化。使用<strong>New操作符</strong>创建类的实例</p><p>个人理解：类，比如汽车，我们将汽车定义抽取出来，汽车类能实现四个车轮（物质）、前后移动转弯（运动）等，那对象就是将这个类往实际生活处理，是类定义的逆过程，比如我要创建一个大众汽车的对象，那我肯定就是满足首先它是车，所以我就得将这个大众汽车属于汽车类，在程序中就是叫做实例化（新建new一个对象，指明它属于汽车类）</p><h5 id="2-引用变量的概念">2.引用变量的概念</h5><p>引用变量就是将实例给附着到变量上，这就是引用变量。</p><p>如果没有引用变量：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> car()).Text = <span class="string">&quot;My Form&quot;</span>;</span><br><span class="line">(<span class="keyword">new</span> car()).ShowDialog[];</span><br></pre></td></tr></table></figure><p>发现不用引用变量，无法连续地访问和操作同一个实例，因为实例没附着到某个变量上</p><p>更改后：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">car mycar; <span class="comment">//申明引用变量</span></span><br><span class="line">mycar = <span class="keyword">new</span> car();</span><br><span class="line">mycar.Text = <span class="string">&quot;My Form&quot;</span>;</span><br><span class="line">mycar.ShowDialog();</span><br></pre></td></tr></table></figure><p>引用变量与实例的关系可以理解为孩子与气球。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> car();<span class="comment">//有气球（实例）没有孩子（引用变量）</span></span><br><span class="line"></span><br><span class="line">car mycar;<span class="comment">//有孩子（引用变量）没有气球（实例）</span></span><br><span class="line"></span><br><span class="line">car mycar1;</span><br><span class="line">car mycar2;</span><br><span class="line">mycar1 = <span class="keyword">new</span> car();</span><br><span class="line">mycar2 =  mycar1; <span class="comment">//多个孩子（引用变量）牵着同一个气球（实例）</span></span><br><span class="line">mycar1.Text = <span class="string">&quot;mycar&quot;</span>;</span><br><span class="line">mycar2.ShowDialog(); </span><br></pre></td></tr></table></figure><h3 id="三、类的三大成员">三、类的三大成员</h3><p>翻看MSDN文档中某个Class时，发现三大成员占了大半部分。</p><h5 id="1-属性（Property）">1.属性（Property）</h5><p>存储数据，组合起来表示类或者对象当前的<strong>状态</strong></p><p>比如之前的car类，有价格Price属性（car.Price），牌子Brand属性（car.Brand）等等</p><h5 id="2-方法（Method）">2.方法（Method）</h5><p>方法</p><p>由C语言的函数（function）进化而来，表示类或者对象能做什么**（动作）**</p><h5 id="3-事件（Event）">3.事件（Event）</h5><p>类或者对象通知其他类或者对象的机制（<strong>不同类或对象的通信</strong>），为C#所特有（Java是通过其他方法实现），记住不能滥用</p><p>而一些某些特殊类或对象在这三个成员的侧重点不同：</p><ul><li>模型类或对象重在属性：如Entity Framework</li><li>工具类或对象重在方法：如Math、Console</li><li>通知类或对象重在事件：如各种Timer</li></ul><h3 id="四、静态成员和实例成员">四、静态成员和实例成员</h3><pre><code>静态（static）成员，也叫类成员，在语义上表示它是“类的成员”，实例（非静态）成员，也叫对象成员，在语义上表示它是“对象的成员”</code></pre><table><thead><tr><th>区分方式</th><th style="text-align:center">静态成员</th><th>非静态成员</th></tr></thead><tbody><tr><td>访问方法</td><td style="text-align:center">静态成员属于类，可以直接通过“<strong>类名.静态成员</strong>”的方式访问；<strong>必须由类名调用，不能使用对象调用</strong>（静态成员隶属于这个类而不是这个实例）</td><td>非静态成员，<strong>必须实例化</strong>后，再通过<strong>对象.实例成员</strong>来访问</td></tr><tr><td>类中的成员</td><td style="text-align:center">静态类中<strong>只能有静态成员，不能有实例成员</strong>，因为静态类不能进行实例化</td><td>在非静态类中<strong>既可以有静态成员，也可以有非静态成员</strong></td></tr><tr><td>类第一次加载时内存分配</td><td style="text-align:center">该类下的所有的静态成员都会被加载；静态成员只分配一次，有且只有一份存储空间；无论new出多少个实例，它也只是有那一个空间静态成员会被加载到静态存储区，直到程序退出时才会被释放；</td><td>实例成员有多少个对象，就会创建多少个对象；每产生一个实例都要重新分配一个存储空间</td></tr></tbody></table><p>拓展：绑定（Binding）指的是编译器如果把一个成员与类或对象关联起来。在WPF中，数据驱动UI时，这个很重要！！</p><hr><h1>第三章 语言基本元素</h1><pre><code>本章主要讲解一些构成C#语言的基本元素（关键词keyword、操作符Operator、标记符Identifier、标点符号、文本、注释与空白）、简要介绍类型、变量与方法，算法的简介。</code></pre><h3 id="一、C-基本元素">一、C#基本元素</h3><p>元素主要包含这几种。这部分主要是查看MSDN文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">    基本元素--&gt;关键字Keyword:从MSDN文档查看</span><br><span class="line">    基本元素--&gt;操作符也叫运算符Operate:MSDN文档查看</span><br><span class="line">    基本元素--&gt;标识符Identifier:掌握一些大小写和命名规范,不能是关键字或操作符等,可读性高</span><br><span class="line">    基本元素--&gt;标点符号</span><br><span class="line">    基本元素--&gt;文本:整数,实数,字符,字符串,布尔,空null</span><br><span class="line">    基本元素--&gt;注释与空白;</span><br></pre></td></tr></table></figure><p>前五种统称为标记（Token），编译器会识别出这个部分。注释与空白对于编译器没有意义，所以不归于这个范畴</p><p>如果要查看C#语言的词汇，因为主要是为了表达人类的逻辑思维，所以关键字的量并不多</p><p><strong>可以打开帮助中的Visual Basic和Visual C#中的C#参考，可以查看C#语言的基本元素</strong></p><h3 id="二、类型、变量、方法简介">二、类型、变量、方法简介</h3><h5 id="1-类型Type（数据类型）">1.类型Type（数据类型）</h5><p>可以通过gettype[]方法去查看数据的类型</p><p>3和3L虽然数值上是相等的，但是在数据类型上是不相同的</p><p>在申明变量和函数会使用到数据类型，下面介绍变量和函数</p><h5 id="2-变量的声明和使用">2.变量的声明和使用</h5><p>变量是存放数据的容器，比如int x就声明了x这个变量，x能用来存放int整型，然后可以用来使用</p><h5 id="3-方法（成员函数）">3.方法（成员函数）</h5><p>方法是代表的是处理数据的逻辑（算法），是数据的加工厂。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明add方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)  <span class="comment">//接受的a，b为int类型，返回值为int值.使用Public主要是为了外部可调用add函数</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> result = a + b;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">         Calculator c = <span class="keyword">new</span> Calculator(); <span class="comment">//实例化Calculator为c</span></span><br><span class="line">         <span class="built_in">int</span> x = c.<span class="keyword">add</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//使用Calculator类中的add方法</span></span><br><span class="line">         Console.WriteLine(x); <span class="comment">//打印x </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试简单算法程序：</p><p>循环、递归分别实现计算i到x（i和x取整数）的和（顺便学习选择和循环结构）</p><p>循环：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//循环方法</span></span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> num = <span class="number">100</span>; <span class="comment">//设置x为100</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= num;i = i +<span class="number">1</span> )<span class="comment">//i取1</span></span><br><span class="line">            &#123;</span><br><span class="line">                 sum = sum + i;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;结果是：&quot;</span>+sum);<span class="comment">//求出1到100的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归：递归的逻辑主要是根据数列的通项公式来决定递归的主体，使用选择结构来决定退出递归的基准条件。（占用内存比较多）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//递归实现i到x的累加</span></span><br><span class="line">            <span class="function"><span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> x</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= x) <span class="comment">//选择if语句是为了防止无限递归</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> Sum(i+<span class="number">1</span>, x) + i; <span class="comment">//注意到Sum(i,x)=Sum(i+1,x)+i,符合递归</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//必须return某个整型值，因为Sum方法返回值为int</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> result = Sum(<span class="number">1</span>, <span class="number">100</span>); </span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学公式简化求解：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> x</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (i + x) * (x - i + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//运用an=(i + x) * (x - i + 1) / 2来求解i到x的值</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> result = Sum(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>第四章 类型、变量</h1><h3 id="一、类型Type概述">一、类型Type概述</h3><h5 id="1-类型简介">1.类型简介</h5><p>又名数据类型（Data Type），是设计者对性质相同的值进行归类而产生的。比如数学中把不小于0的整数叫做自然数，自然数这个称呼就算是一个数据类型，而自然数这一概念的推出的确对我们平时学习有一定作用，而在程序中比如整型，就是int，则也是一种数据类型，能够更好地优化内存，防止使用一些高精度类型造成浪费，影响软件的性能等。</p><ul><li>是数据在内存中存储的“型号”</li><li>小内存容纳大尺寸数据会丢失精确度，发生错误；大内存容纳小尺寸数据会导致浪费</li></ul><p>注意：编程语言的数据类型与数学的数据类型不完全相同（编程中3/4=0）,到操作符学习会进一步讲解</p><h5 id="2-强类型语言与弱类型语言的比较">2.强类型语言与弱类型语言的比较</h5><p>有些编程语言叫强/弱类型语言，<strong>语言编程的时候受数据类型的约束是强类型语言</strong>，C#语言就是强类型编程语言，声明int类型变量后，无法赋浮点数。</p><p>C语言示例：if条件.可以使用<a href="https://c.runoob.com/">菜鸟工具</a>在线编程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> x;</span><br><span class="line">    x= <span class="number">100</span>;</span><br><span class="line">    <span class="type">long</span> =y;</span><br><span class="line">    y=<span class="number">100L</span>;</span><br><span class="line">    x=<span class="number">100L</span>; <span class="comment">//long长整型不能放到int内，保证数据  安全性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x=<span class="number">200</span>) <span class="comment">//C语言中x=200，不为0，则为1，true值，还是会输出；而C#语言x=200是布尔值1</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;it&#x27;s OK&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python或JavaScript示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x =<span class="number">1</span></span><br><span class="line">x=<span class="string">&quot;OK&quot;</span> //变量不受类型控制，仍然可以赋值</span><br></pre></td></tr></table></figure><p>C#语言（强类型）对弱类型/动态类型的模仿（C#在4.0后，模仿了弱类型的灵活性，建立了动态类型dynamic）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dynamic</span> myvar = <span class="number">100</span>; <span class="comment">//myvar赋值为整数100</span></span><br><span class="line">            Console.WriteLine(myvar);</span><br><span class="line">            myvar = <span class="string">&quot;OK&quot;</span>; <span class="comment">//myvar赋值为字符串“OK”</span></span><br><span class="line">            Console.WriteLine(myvar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-数据类型在C-类型中的作用">3.<a href="https://docs.microsoft.com/zh-cn/previous-versions/ms173104(v=vs.110)?redirectedfrom=MSDN">数据类型在C#类型中的作用</a></h5><ul><li><p>存储此类型变量所需的内存空间大小（int占4个字节，long占8个字节）</p></li><li><p>此类型的值可表示的最大、最小值范围</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121114400.png" alt="image-20220102151941135"></p><p>在C# reference中可以查看到各个数据类型的范围，有无符号（必须先知道数据的表示和运算，参考《计算机导论》）</p></li><li><p>此类型所包含的成员（如方法、属性、事件等）以及此类型由什么基类派生而来，知道类的“来龙去脉”</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在引用中引用上System.Windows.Forms，并using</span></span><br><span class="line"><span class="comment">//using System.Reflection;才能使用反射</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Type myType = <span class="keyword">typeof</span>(Form); <span class="comment">//用typeof查看form的类型，把类型值（类型的元数据）赋给mytype</span></span><br><span class="line">            Console.WriteLine(myType.Name); <span class="comment">//输出类型名</span></span><br><span class="line">            Console.WriteLine(myType.FullName); <span class="comment">//输出类型全名</span></span><br><span class="line">            Console.WriteLine(myType.BaseType.FullName); <span class="comment">//输出父类的类型全名</span></span><br><span class="line">            Console.WriteLine(myType.BaseType.BaseType.BaseType.FullName); <span class="comment">//输出父类的父类的父类的类型全名</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得属性和方法值就可以去操作它们，很像DOM操作</span></span><br><span class="line">            PropertyInfo[] pinfos = myType.GetProperties(); <span class="comment">//C#反射，获得某类型的属性值</span></span><br><span class="line">            MethodInfo[] minfos = myType.GetMethods(); <span class="comment">//获得某类型的方法值</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> p <span class="keyword">in</span> pinfos) <span class="comment">//遍历pinfos，并逐一输出</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(p.Name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> m <span class="keyword">in</span> minfos) <span class="comment">//遍历minfos，并逐一输出</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(m.Name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>此类型所允许的操作（运算）：不同类型对应不同的操作，比如浮点数3.0/4.0 =0.75，而整数3/4=0</p></li><li><p>程序运行时，此类型的变量分配在内存的什么位置（可以参考数据结构的书籍，比如《大话数据结构》等）</p><ul><li><p>Stack栈</p><p>Stack overflow（堆栈溢出）：栈比较小，当申请大空间内存或者递归时，可能会出现堆栈溢出</p><p>下面程序需要项目管理器—双击Properties—生成—勾选不安全代码 才能运行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>* p = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[<span class="number">99999999</span>];<span class="comment">//指针类型只能用于unsafe模式：https://docs.microsoft.com/zh-cn/previous-versions/chfa2zb8(v=vs.110)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用unsafe关键字或者unsafe区域</span></span><br><span class="line">        <span class="comment">//static  void Main()</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//  unsafe</span></span><br><span class="line">        <span class="comment">//  &#123;</span></span><br><span class="line">        <span class="comment">//    int* p = stackalloc int[99999999];</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">//  </span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Heap堆</p><p>使用性能监视器Performance Monitor（win+r输入perfmon或者直接搜索<strong>性能监视器</strong>）查看进程的堆内存使用量；而内存忘回收会造成浪费（内存泄漏）</p></li></ul></li></ul><h3 id="二、C-的类型系统">二、C#的类型系统</h3><p>C#有五大数据类型，分别是类类型、接口类型、委托类型、结构体类型和枚举类型。具体派生谱系可以参考<a href="https://docs.microsoft.com/zh-cn/previous-versions/3ewxz6et(v=vs.110)?redirectedfrom=MSDN">MSDN文档</a>，另外指针类型（不推荐使用）和内置引用类型dynamic，object和string未列出。这里的接口和委托属于进阶部分，只简单介绍下</p><p>如何判断类型？在某个类型上按下F1键就能查看MSDN文档判断 &amp; 直接在某个类型上按F12/右键—转到定义，从而进入定义，从而得到它的类型</p><h5 id="1-引用类型—类（class）">1.引用类型—类（class）</h5><p>比如Window、Form、Console、String等</p><p>使用前面的反射PropertyInfo[]，可以获取父类和子类</p><h5 id="2-引用类型—接口（interfaces）">2.引用类型—接口（interfaces）</h5><p>接口只包含 方法、 属性、 事件或 索引器的签名，实现接口的类或结构必须实现接口定义中指定的接口成员。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ISampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SampleMethod</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ImplementationClass</span> : <span class="title">ISampleInterface</span> <span class="comment">//接口自ISampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显示实现接口: </span></span><br><span class="line">    <span class="keyword">void</span> ISampleInterface.SampleMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用接口的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 声明接口实例.</span></span><br><span class="line">        ISampleInterface obj = <span class="keyword">new</span> ImplementationClass();</span><br><span class="line">        obj.SampleMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-引用类型—委托（delegate）">3.引用类型—委托（delegate）</h5><p>可用于封装命名或匿名方法的引用类型。委托类型的声明与方法签名相似， 有一个返回值和任意数目任意类型的参数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">TestDelegate</span>(<span class="params">MyType m, <span class="built_in">long</span> num</span>)</span>;</span><br></pre></td></tr></table></figure><p>类似于 C++ 中的函数指针；但是，委托是类型安全和可靠的</p><p><strong>委托是事件的基础</strong>。通过将<strong>委托</strong>与<strong>命名方法或匿名方法</strong>关联，可以实例化委托，并且必须使用具有兼容返回类型和输入参数的方法或 lambda 表达式实例化委托</p><h5 id="4-值类型—结构体（struct）">4.值类型—结构体（struct）</h5><p>通常用来封装小型相关变量组，特征是用struct关键字，例如，矩形的坐标或库存商品的特征。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Book</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> price;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> title;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-值类型—枚举（enum）">5.值类型—枚举（enum）</h5><p>由一组称为枚举数列表的命名常量组成的独特类型，特征是使用enum关键字。通常情况下，最好是在命名空间内直接定义枚举，以便该命名空间中的所有类都能够同样方便地访问它</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Days &#123;Sat, Sun, Mon, Tue, Wed, Thu, Fri&#125;;</span><br></pre></td></tr></table></figure><h3 id="三、变量与常量">三、变量与常量</h3><h5 id="1-变量定义">1. 变量定义</h5><pre><code>变量表面上用途是**存储数据**，实际上变量还表示存储位置，**每个变量都有一个类型**，以决定什么样的值能够存入变量（变量名的位置就是数据的位置）。变量 = 以变量名所对应的内存地址为起点，以其数据类型所要求的内存空间为长度的一块内存区域。</code></pre><h5 id="2-变量种类">2. 变量种类</h5><p>C#语言的变量共有7种：<strong>静态成员变量</strong>、<strong>实例变量</strong>（字段，成员变量）、<strong>数组元素</strong>、<strong>值参数</strong>、<strong>引用参数</strong>、<strong>输出形参</strong>、<strong>局部变量</strong>。变量一般指的是局部变量，在一个独立的程序块中声明的变量，它只在该范围中有效。</p><ul><li><p>静态变量：<strong>C# 中没有全局变量的概念</strong>，所有变量必须由该类的实例进行操作。在保存一些类的公共信息时，就会使用静态变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student.amount = <span class="number">2</span>; <span class="comment">//2、静态变量隶属于这个类而不是这个实例</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> amount; <span class="comment">//1、声明静态变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字段：直接在类或结构中声明的任何类型的变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu =<span class="keyword">new</span> Student();</span><br><span class="line">            Stu.Name = <span class="string">&quot;XXX&quot;</span>; <span class="comment">//2、字段隶属于实例，必须先实例</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age; <span class="comment">//1、声明字段</span></span><br><span class="line">        <span class="keyword">public</span> String Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组元素：类型加方括号就表示为数组。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">100</span>]; <span class="comment">//类型加方括号就是数组</span></span><br><span class="line">            Console.WriteLine(array[<span class="number">0</span>]); <span class="comment">//类型加方括号和数字i，表示取出数组内的第i+1个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值参数：函数参数中使用类型加变量名</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Main</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>) <span class="comment">//参数a，b都是参数变量中的值参数变量</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用参数：函数参数类型前用ref修饰</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">double</span> a, <span class="built_in">double</span> b</span>) <span class="comment">//a使用ref修饰</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出形参：函数参数类型前用out修饰</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">double</span> a, <span class="built_in">double</span> b</span>) <span class="comment">//a使用out修饰</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>局部变量：在方法体内声明的变量，出了方法的代码块，变量的内存会被回收</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> result = a + b; <span class="comment">//result在方法体内声明，是局部变量</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-变量的声明">3. 变量的声明</h5><p>变量声明的标准格式：有效的修饰符组合opt + **类型 **+ **变量名 **+ 初始化器opt;   其中，类型和变量名是必需的，其他是opt可选的</p><p>举例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Amount = <span class="number">0</span>;</span><br><span class="line">   修饰符组合   类型 变量名 初始化器;</span><br></pre></td></tr></table></figure><h5 id="4-变量在内存中的存储">4. 变量在内存中的存储</h5><p>变量在内存中的存储方式按照值类型和引用类型，可以分为两种，此部分C#是参考C++。强烈推荐新手看下刘铁猛C#教程的这部分以及数据的表示与运算相关内容。</p><p>首先必须知道栈和堆：栈也称为栈内存，是一个具有动态内存区域，存储时从高地址向低地址延伸。堆内存是区别于栈区、全局数据区和代码区的另一个内存区域。堆允许程序在运行时动态地申请某个大小的内存空间，C语言中的malloc函数就是动态分配堆内存</p><ul><li><p>值类型的内存存储</p><p>1Byte字节=8bit比特（位），内存中为每个字节都编号</p><p>值类型会寻找到除了操作系统和已被使用的内存地址，然后从高位开始放入。比如int使用32位（32个bit）存储，比如从10001000开始为闲置空间，则首先空出4个字节，即10001000到10001100给int来存储，赋值int x = 100时候，把100转为二进制110 0100，从10001100开始填入（从高位开始填充），高位没有的话用0填充。有符号signed的时候，负数需要连带符号位一起转为补码+1存储</p><p>显示负数的存储值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">short</span> s = <span class="number">-1000</span>;</span><br><span class="line">            <span class="built_in">string</span> str = Convert.ToString(s,<span class="number">2</span>); <span class="comment">//ToString方法返回表示当前对象的字符串，2代表返回值为二进制</span></span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用类型的内存存储</p><p>以类为例，当创建某个类变量（Students Stu;）时，系统会直接在<strong>栈内存</strong>分配4个字节（32bit），都填入0，准备存储对象的地址；实例化类后，该变量才开始包含类中的字段，内存给字段安排<strong>堆内存</strong>，根据字段的类型按照值类型存储方式存储；并且把字段起始地址存储到系统自动分配的32bit中</p></li></ul><p>注意：局部变量是在stack栈上分配内存，而字段是使用堆内存。与C等语言自带默认值不同，C#变量的初始化需要显式赋值</p><h5 id="5-常量">5. 常量</h5><p>常量表示字段或局部变量的值是常数，<strong>值不能被修改</strong>。使用const  关键字来作为字段或局部变量的声明。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> Amount = <span class="number">0</span>;</span><br><span class="line">修饰符 类型 变量名 初始化器; <span class="comment">//其中，初始化器不能省略</span></span><br></pre></td></tr></table></figure><h5 id="6-装箱和拆箱（Boxing-Unboxing）">6. 装箱和拆箱（Boxing &amp; Unboxing）</h5><p>会造成性能损失，主要考察数据类型在内存中如何作用</p><p>装箱：封装后，从栈往堆上存储。比如计算机发现引用的值是栈上的值类型，会先复制到堆内存中，在将地址取回</p><p>拆箱：封装后，从堆往栈上存储、</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/boxing-and-unboxing#boxing">参考文章</a></p><hr><h1>第五章 方法Method</h1><h3 id="一、方法概述">一、方法概述</h3><pre><code>“方法”是包含一系列语句的代码块，其前身是C/C++语言的函数（fuction）。面向过程称为函数，面向对象里称为方法。在C语言中还没有见到雏形，但是在编写C++中，可以发现，类的定义.h和方法的编写.cpp是两个文件，通过include库来引入类，但是对比下来C#会更舒服一些方法永远是类/结构体的成员，也只有类/结构体中的成员称为方法。这点与C++不同，C++中是可以的，称为全局函数类/结构体最基本成员只有两个：**字段**（成员变量—存储数据）、**方法**（成员函数—实现算法）方法或者函数的**作用**：隐藏算法逻辑或者由小算法组成大算法，达到简化目的；实现复用，避免造轮子</code></pre><h3 id="二、方法的使用">二、方法的使用</h3><h5 id="1-方法的声明-定义">1.方法的声明/定义</h5><p>根据MSDN文档<a href="https://docs.microsoft.com/zh-cn/previous-versions/ms173114(v=vs.110)?redirectedfrom=MSDN">该部分内容</a>。 程序通过“调用”方法并指定所需的任何方法参数来执行语句。 在 C# 中，每个执行指令都是在方法的上下文中执行的。 Main 方法是每个 C# 应用程序的入口点，在启动程序时由公共语言运行时 (CLR) 调用。</p><p>方法的声明语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法头：             <span class="function"><span class="keyword">public</span>                    <span class="built_in">double</span>  <span class="title">GetNum</span>   (<span class="params"><span class="built_in">double</span> r</span>)</span></span><br><span class="line"><span class="function">       特性opt|有效的修饰符组合opt|<span class="keyword">partial</span>关键字|返回值类型|方法名|Argument实参/Parameter形参列表</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">方法体：</span>&#123;</span><br><span class="line">            block程序</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>其中，方法名应该以动词或动词短语为名字，且每个词首字母都得大写而不是驼峰法</p><h5 id="2-方法的调用">2.方法的调用</h5><p>方法调用：用圆括号—方法调用操作符，调用方法的参数列表要与定义的列表相匹配，即类型相同。Argument实参是值，Parameter形参是变量，值与变量需匹配不然会报错。</p><h5 id="3-构造器Constructor">3.构造器Constructor</h5><p>构造器是<strong>特殊的方法</strong>，是类型的成员之一。一般指的是“实例构造器”，各类构造器的声明和调用如下所示，其存储方式可以参考引用类型变量的内存存储。系统自动分配栈的4字节给Students类以及8字节堆空缺作为准备，实例化后，8字节空缺划分为id和name的地址，并都赋值为0，然后再空出堆位置给name存储。</p><blockquote><p>使用默认构造器</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">           Students stu = <span class="keyword">new</span> Students(); <span class="comment">//使用默认实例构造器</span></span><br><span class="line">            Console.WriteLine(stu.Id);<span class="comment">//默认返回值为0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//此处未编写构造器，则声明的是默认实例构造器 </span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建自定义构造器（不带参数，没留参数输入口）</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">           Students stu = <span class="keyword">new</span> Students();<span class="comment">//使用不带参数的实例构造器</span></span><br><span class="line">            Console.WriteLine(stu.Id);</span><br><span class="line">            Console.WriteLine(stu.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Students</span>() <span class="comment">//声明不带参数的实例构造器</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Id = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.Name = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建自定义构造器（带参数的）</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">           Students stu = <span class="keyword">new</span> Students(<span class="number">1</span>,<span class="string">&quot;XXX&quot;</span>);<span class="comment">//使用带参数的实例构造器</span></span><br><span class="line">            Console.WriteLine(stu.Id);</span><br><span class="line">            Console.WriteLine(stu.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Students</span>(<span class="params"><span class="built_in">int</span> initid,<span class="built_in">string</span> initname</span>) <span class="comment">//声明带参数的实例构造器</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Id = initid;</span><br><span class="line">            <span class="keyword">this</span>.Name = initname;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-方法重载Overload">4.方法重载Overload</h5><p>当创建类时，已经有某方法比如Add，能否创建个同名方法？能，使用重载！比如Console.WriteLine()方法中参数可以填入各种类型int、string等，说明该方法使用重载</p><p><strong>定义</strong>：当类创建方法后，方法名（method name）可以一样，但是方法签名（method signature）不能一样。</p><p>其中，方法签名=方法名 + 类型形参个数 + 形参依次（按从左到右）的类型 + 种类（值、引用或输出）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>  <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是，方法签名<strong>不包含返回类型</strong>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>  <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)  <span class="comment">//会报错存在相同成员</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造器（实例构造函数）签名=  形参依次（按从左到右）的类型+ 种类（值、引用或输出）</p><p>那如何判断该使用哪个重载？比如该选择什么类型参数的Console.WriteLine()方法？需要使用重载决策</p><p><strong>重载决策</strong>：在给定参数列表和一组候选函数成员的情况下，选择最佳的函数成员来实施调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">           Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">            <span class="built_in">int</span> x = c.Add(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">//会自动决策出最佳的函数成员</span></span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>  <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b,<span class="built_in">int</span> c</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-Debug方法">5.Debug方法</h5><p>debug能力很重要！这里介绍debug的基本技术（以VS为例）</p><p>示例程序为</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> result = Calculator.GetCylinderVolume(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">GetCircleArea</span>(<span class="params"><span class="built_in">double</span> r</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.PI*r*r; <span class="comment">//这里的Math.PI指的是Π</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">GetCylinderVolume</span>(<span class="params"><span class="built_in">double</span> r,<span class="built_in">double</span> h</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> a =GetCircleArea(r);</span><br><span class="line">            <span class="keyword">return</span> a*h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">GetConeVolume</span>(<span class="params"><span class="built_in">double</span> r, <span class="built_in">double</span> h</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> cv = GetCylinderVolume(r,h);</span><br><span class="line">            <span class="keyword">return</span> cv/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设置断点（breakpoint）</p></blockquote><p><img src="https://s2.loli.net/2022/01/04/wHWBgsjLJAPpTUf.png" alt="image-20220104124205095"></p><p><strong>调试</strong>模式F5（非调试模式下无反应）下，程序运行到断点处会停止，金黄色代表当前的执行语句</p><blockquote><p>观察方法调用时的调用堆栈call stack</p></blockquote><p><img src="https://s2.loli.net/2022/01/04/EP8VxSntUIpDdBw.png" alt="image-20220104124922930"></p><p>调试模式下，会显示调用堆栈的情况，表示目前调用的方法和调用方法的位置（调用栈像引用类型的存储，上面会调用下面，下面可能也会调用其他，一直调用，可能会堆栈溢出），这里采取的是树形结构。</p><blockquote><p>F11逐语句Step-in，F10逐过程Step-over，Shift+F11跳出step-out</p></blockquote><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121114832.png" alt="image-20220104125500757"></p><p>调试的时候，逐过程用来快速定位大范围错误，跳过一些熟悉的过程；逐语句代表一步一步调试，仔细进行调试；跳出代表回到调用的方法，相当于在调用堆栈工具中，点击被调用方法的上层方法。</p><blockquote><p>观察局部变量的值与变化</p></blockquote><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121114952.png" alt="image-20220104130448102"></p><h5 id="6-方法的调用与栈">6.方法的调用与栈*</h5><p>主要讲解的是方法调用时，栈内存是如何分配。</p><p>讲解对栈帧stack frame的分析：每一次函数的调用,都会在调用栈(call stack)上维护一个独立的栈帧(stack frame)。</p><p>每个独立的栈帧一般包括:</p><ul><li>函数的返回地址和参数</li><li>临时变量（包括函数的非静态局部变量以及编译器自动生成的其他临时变量）</li><li>函数调用的上下文</li></ul><p>栈是从高地址向低地址延伸,一个函数的栈帧用ebp（帧指针）和esp（栈指针）这两个寄存器来划定范围.ebp 指向当前的栈帧的底部,esp 始终指向栈帧的顶部;</p><p>那么方法（函数）的调用和返回时，经历哪些栈步骤？<br>调用：</p><ol><li>参数入栈: 将参数列表依次压入栈中（按照调用约定：C是从右向左，C#参考C++采用从左到右）</li><li>返回地址入栈: 将当前代码区调用<strong>目前指令的下一条指令</strong>的<strong>地址</strong>压入栈中，供方法返回时继续执行（调试模式中调用堆栈工具栏里面，选择当前方法的下一个方法，将这个方法的地址压栈-从高地址压入）</li><li>代码跳转: 处理器将代码区跳转到被调用方法的入口处</li><li>栈帧调整：将目前调用者的ebp压栈，保存好ebp的地址（方便函数返回之后的现场恢复），此时esp指向新的栈顶位置；将当前栈帧切换到新栈帧(将esp值装入ebp，更新栈帧底部), 这时ebp指向栈顶，而此时栈顶就是之前的ebp，然后开始给新栈帧分配空间。就是把指向底部的指针ebp的地址存起来，然后让指向顶部的指针esp的值放到ebp中，作为现在的栈底，从这个栈底开始再继续分配空间</li></ol><p>返回：</p><ol><li>保存被调用函数的返回值到寄存器中</li><li>恢复 esp 同时回收局部变量空间</li><li>将上一个栈帧底部位置恢复到ebp</li><li>弹出当前栈顶元素,从栈中取到返回地址,并跳转到该位置</li></ol><hr><h1>第六章 操作符（Operator）</h1><h3 id="一、操作符概述">一、操作符概述</h3><p>操作符也译为运算符，是用来操作数据的，被操作的数据称为操作数（Operand）</p><p>操作符的本质是与固定数据类型相关联的数学里计算方法/算式的“简记”。</p><h3 id="二、操作符优先级和运算顺序">二、操作符优先级和运算顺序</h3><h5 id="1-优先级">1.优先级</h5><p>优先级这个概念在数学中其实就已经存在，先乘除再加减就是最简单的计算优先级。</p><p>优先级规则：</p><ul><li>圆括号可以提高被括表达式的优先级，并且还可以嵌套</li></ul><p>注意：不像数学里的方括号和花括号，C#语言中这两个都有其他用途</p><h5 id="2-同优先级时的运算顺序">2.同优先级时的运算顺序</h5><p>运算顺序在数学中也是存在的，简单的都是从左往右，比如3x4/5x6</p><p>而对于C#语言，运算顺序规则</p><ul><li><p>赋值操作符、null合并运算符和条件运算符?:是右结合运算符，按从右往左计算；除了右结合运算符，同优先级操作符都是<strong>从左往右</strong>运算的</p></li><li><p>与数学运算不同，计算机语言的同优先级运算<strong>没有“结合律”</strong></p><p>3+4+5只能理解为Add(Add(3,4),5)，不能理解为Add(3,Add(4,5))</p></li></ul><h3 id="三、操作符示例">三、操作符示例</h3><p>下面示例是按最高优先级到最低优先级的顺序列出的C#运算符，并配合一些示例讲解运算符基础的功能，具体可参考的是MSDN文档中<a href="https://docs.microsoft.com/zh-cn/previous-versions/6a71f45d(v=vs.110)">操作符 旧版</a>以及<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/">操作符优先级和结合性</a></p><h5 id="1-基本（主要）运算符">1.基本（主要）运算符</h5><blockquote><p><code>x.y</code>：点运算符</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*成员访问*/</span></span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;hello,World&quot;</span>);</span><br><span class="line"><span class="comment">//这里访问名称空间System、类型Console、静态成员WriteLine的成员</span></span><br></pre></td></tr></table></figure><blockquote><p><code>f(x)</code>：圆括号运算符</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*指定表达式中运算符的顺序*/</span></span><br><span class="line"><span class="built_in">double</span> i = <span class="number">1.0</span>;</span><br><span class="line"><span class="built_in">double</span> x = (<span class="number">3</span> * i) * i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定强制转换或类型转换*/</span></span><br><span class="line"><span class="built_in">int</span> a;</span><br><span class="line">a = (<span class="built_in">int</span>)x;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用方法*/</span></span><br><span class="line">System.Console.WriteLine(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用委托*/</span></span><br><span class="line">Other o = <span class="keyword">new</span> Other();</span><br><span class="line">Action myAction = <span class="keyword">new</span> Action(o.PrintHello); <span class="comment">//PrintHello这里不用圆括号，只想获得名字到委托</span></span><br><span class="line">myAction();<span class="comment">//上面并未调用，但是这里加圆括号进行了调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Other</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintHello</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">   Console.WriteLine(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>a[i]</code>：方括号(元素访问)运算符</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明数组*/</span></span><br><span class="line"><span class="built_in">int</span>[] lib = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">//int[]对象lib，并且默认值改成1到5，其中&#123;&#125;为初始化器（可选）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*索引器*/</span></span><br><span class="line"><span class="comment">//数组索引器（索引为数字）</span></span><br><span class="line">lib[<span class="number">0</span>] = lib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">Console.WriteLine(lib[lib.Length<span class="number">-1</span>]);<span class="comment">//如果数组索引超出数组相应维度的边界，将引发 IndexOutOfRangeException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字典索引器（索引为字符串）</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Dictionary&lt;<span class="built_in">string</span>,Student&gt; stuDic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,Student&gt;();</span><br><span class="line">            <span class="comment">//泛型类，不是完整的类，必须和别的类组成在一起</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">                stu.Name = <span class="string">&quot;s&quot;</span>+i.ToString();</span><br><span class="line">                stu.Score = <span class="number">100</span>;</span><br><span class="line">                stuDic.Add(stu.Name, stu);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Student number6 = stuDic[<span class="string">&quot;s_6&quot;</span>];</span><br><span class="line">            Console.WriteLine(number6.Score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>x++</code>：后置自增运算符；<code>x--</code> 后置自减运算符</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">Console.WriteLine(++i);<span class="comment">//前缀增量操作，结果为操作数加1之后的值</span></span><br><span class="line">Console.WriteLine(--i);<span class="comment">//前缀减量操作，结果为操作数减1之后的值</span></span><br></pre></td></tr></table></figure><blockquote><p><code>typeof()</code>运算符</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取某个类型的 System.Type 实例，取出类型值（类型的MetaData元数据）*/</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Type t = <span class="keyword">typeof</span>(<span class="built_in">int</span>);<span class="comment">//typeof查看int类型，把类型值赋给t</span></span><br><span class="line">            Console.WriteLine(t.Namespace);</span><br><span class="line">            Console.WriteLine(t.FullName);</span><br><span class="line">            Console.WriteLine(t.Name);</span><br><span class="line">            <span class="built_in">int</span> c = t.GetMethods().Length;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> method <span class="keyword">in</span> t.GetMethods())<span class="comment">//遍历t的方法</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(method.Name);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(c); <span class="comment">//共有17种方法</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>default</code>运算符</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*生成类型的默认值*/</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值类型内存块全为0时，默认值为0</span></span><br><span class="line"><span class="built_in">int</span> x = <span class="literal">default</span>(<span class="built_in">int</span>);<span class="comment">//default()实参必须是类型或类型形参的名称，内存块会全部默认值为0</span></span><br><span class="line">Console.WriteLine(x); </span><br><span class="line"></span><br><span class="line"><span class="comment">//引用类型的内存块全为0时，默认值为null</span></span><br><span class="line">Form myForm = <span class="literal">default</span>(Form);</span><br><span class="line">Console.WriteLine(myForm);</span><br><span class="line"></span><br><span class="line"><span class="comment">//要注意枚举类型的默认值</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            level x = <span class="literal">default</span>(level);</span><br><span class="line">            Console.WriteLine(x); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">enum</span> level</span><br><span class="line">        &#123;</span><br><span class="line">            Low,<span class="comment">//输出为Low，但是当Low=1,Mid=0,High=2时，会输出Mid；当三个赋值里面没有0时，会输出0</span></span><br><span class="line">            Mid,</span><br><span class="line">            High,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>new </code>运算符</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建类型实例，并调用实例构造器*/</span></span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Form();<span class="comment">//不赋值时，会创建实例但是会收回，所以无反应</span></span><br><span class="line">            Form myform = <span class="keyword">new</span> Form();<span class="comment">//赋值后，能得到实例的内存地址，并交给访问实例的变量，从而通过访问变量而访问实例</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//new还能调用之前学习的初始化器</span></span><br><span class="line">            Form myForm = <span class="keyword">new</span> Form() &#123; Text = <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">            myForm.ShowDialog();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//new和点操作符一起使用，是没问题的，但是使用完就会被垃圾回收器回收，一次性使用</span></span><br><span class="line">            <span class="keyword">new</span> Form() &#123; Text = <span class="string">&quot;Hello&quot;</span> &#125;.ShowDialog();</span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要创建类型和实例，不一定需要new操作符，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> b = <span class="keyword">new</span> <span class="built_in">int</span>();   <span class="comment">//调用值类型的默认构造函数，b初始化为0,可以简化为int b= 0</span></span><br><span class="line">                     <span class="comment">//这部分的语法是语法糖衣，是系统为了带来更简便的写法</span></span><br></pre></td></tr></table></figure><p>当然，new还有其它用法</p><p>首先介绍主要关键字<strong>Var</strong>（Variable）：声明隐式变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x；<span class="comment">//显式声明变量</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>；<span class="comment">//隐式声明变量，通过100，系统推断出var等同于int</span></span><br><span class="line">            <span class="comment">//如果把100改成&quot;&quot;，则var等同于string</span></span><br><span class="line">Console.WriteLine(x.GetType().Name);</span><br></pre></td></tr></table></figure><p>但是像纸牌里的大小王一样，大小王var为一次性产品，变完其他牌之后没法再变其他牌</p><p>接下来将new的下一个用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*匿名类型的实例化（创建对象）*/</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Form myForm = <span class="keyword">new</span> Form() &#123; Text = <span class="string">&quot;Hello&quot;</span> &#125;;<span class="comment">//new后面不是一定像这样跟上Form这样 的数据类型</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> person = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;XXX&quot;</span>, Age = <span class="number">34</span> &#125;;</span><br><span class="line">            <span class="comment">//匿名类型Anonymous Types：使用var声明隐式类型变量和对象初始值设定项语法，是很好的“偷懒”方法</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;person.Name&#125;</span>, <span class="subst">&#123;person.Age&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(person.GetType());<span class="comment">//输出&lt;&gt;f__AnonymousType0`2[System.String,System.Int32]</span></span><br><span class="line">                                                <span class="comment">//约定前缀&lt;&gt;f__AnonymousType，0代表程序创建的第一个匿名类型</span></span><br><span class="line">                                                <span class="comment">//^2为泛型类，并且使用了两个类型</span></span><br><span class="line">                                                <span class="comment">//[System.String,System.Int32]表示类型的路径</span></span><br><span class="line">            Console.WriteLine(person.GetType().Name);<span class="comment">//输出&lt;&gt;f__AnonymousType0^2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new操作符的功能强大，所以得防止滥用。使用new后，编写的类型和创建实例的类型可能会构成高耦合，需要设计模式——依赖注入模式去弥补。</p><p>附：new关键字，此时不是操作符，而是用作声明<strong>修饰符</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedC</span> : <span class="title">BaseC</span> <span class="comment">//继承自BaseC,就能包含基类的那些方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>()</span> &#123; &#125; <span class="comment">//new后，显式隐藏从基类继承的成员函数Invoke()，该成员派生版会替换基类原来版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>checked</code> 显式启用溢出检查；<code>unchecked</code> 阻止溢出检查（C#默认情况）</p></blockquote><p>溢出是指假如一个类型只允许4bit，则1111+1=10000，产生进位，输出0000，即0，产生溢出异常，导致编译器错误，但如果表达式包含一个或多个非常量值，则编译器不检测溢出</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">uint</span> x = <span class="built_in">uint</span>.MaxValue;<span class="comment">//x赋uint所能取的最大值</span></span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">            <span class="built_in">string</span> binStr = Convert.ToString(x, <span class="number">2</span>);</span><br><span class="line">            Console.WriteLine(binStr);</span><br><span class="line">            <span class="built_in">uint</span> y = x + <span class="number">1</span>;<span class="comment">//默认情况是使用unchecked</span></span><br><span class="line">            Console.WriteLine(y);<span class="comment">//产生溢出，输出0，但未抛出异常，因为上面是unchecked</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用checked启用溢出检查</span></span><br><span class="line">            checked</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(y - <span class="number">1</span> + <span class="number">1</span>);<span class="comment">//采用上下文用法，抛出溢出异常（需要注释/删除这部分，才能继续运行）</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用try去catch抓获异常，并异常处理</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">uint</span> z = checked(x + <span class="number">1</span>);<span class="comment">//此处本来会抛出异常，try语句能catch这个OverflowException溢出异常，进行操作</span></span><br><span class="line">                Console.WriteLine(z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (System.OverflowException ex)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;有溢出产生&quot;</span>);<span class="comment">//当溢出产生后，进行输出操作</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//checked上下文用法 + try-catch异常处理语句</span></span><br><span class="line">             checked</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">uint</span> z = x + <span class="number">1</span>;</span><br><span class="line">                    Console.WriteLine(z);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (System.OverflowException e)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;有溢出产生&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121114233.png" alt="image-20220105204359168"></p><blockquote><p><code>delegate</code>操作符</p></blockquote><p>匿名方法：逻辑永远不会reuse（一次性产品），可以使用匿名方法</p><p>delegate关键字用于操作符时，可以创建一个可以转换为委托类型的匿名方法。但是这属于过时技术，从C# 3 开始lambda表达式提供了一种更简洁和富有表现力的方式来创建匿名函数。</p><p>使用 delegate 运算符时，可以省略参数列表。 这样可以将创建的匿名方法转换为具有任何参数列表的委托类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Greet</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">Greet(<span class="number">42</span>, <span class="number">2.7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//delegate声明匿名方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//有Action&lt;T&gt; 和 Func&lt;T&gt;委托</span></span><br><span class="line"><span class="comment">//泛型 Action&lt;T&gt;委托表示引用一个 void 返回类型的方法，Func&lt;T&gt;允许调用带返回类型的方法</span></span><br><span class="line"><span class="comment">//比如Action&lt;in T1，in T2，in T3，in T4，in T5，in T6，in T7，in T8&gt;调用带 8 个参数的方法</span></span><br><span class="line"><span class="comment">//Func&lt;in T1，in T2，in T3，in T4，out TResult&gt;调用带 4 个参数的方法</span></span><br><span class="line">  Action&lt;<span class="built_in">int</span>, <span class="built_in">double</span>&gt; Greet = <span class="built_in">delegate</span> &#123; Console.WriteLine(<span class="string">&quot;hello!&quot;</span>); &#125;;</span><br><span class="line"><span class="comment">//把方法头移到等式左边，加上delegate和Action</span></span><br><span class="line"><span class="comment">//&lt;int, double&gt;可删除，这里只是为了演示</span></span><br><span class="line">  Greet(<span class="number">42</span>, <span class="number">2.7</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式声明匿名方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  Action&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; Greet = (a,b) =&gt; &#123; Console.WriteLine(a+b); &#125;;</span><br><span class="line"><span class="comment">//第一处&lt;string,string&gt;是(a,b)的参数列表中参数类型，Greet为匿名方法名</span></span><br><span class="line"><span class="comment">//第二处(a,b)是方法的参数列表中参数名</span></span><br><span class="line"><span class="comment">//第三处(a,b)是方法体</span></span><br><span class="line">  Greet(<span class="string">&quot;hello!&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>delegate关键字较常见的是声明委托类型，这个在后面讲解</p><blockquote><p><code>sizeof</code>返回给定类型的变量所占用的字节数</p></blockquote><p>sizeof参数只能参数必须是一个非托管类型的名称，或限定为非托管类型的类型参数</p><ul><li>非托管类型：sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal 或 bool；枚举类型；指针类型；用户定义的struct（结构体）类型，只包含非托管类型的字段，并且在 C# 7.3 及更早版本中，不是构造类型（包含至少一个类型参数的类型）</li><li>string、operator不是结构体类型</li></ul><p>sizeof 运算符需要不安全上下文</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> <span class="comment">//需要不安全上下文，使用unsafe代码块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> x = <span class="keyword">sizeof</span>(Students);</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Students &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>x—&gt;y</code>指针成员访问运算符</p></blockquote><p>该操作符将<strong>指针间接</strong>和<strong>成员访问</strong>合并，<code>x-&gt;y</code>等价于 <code>(*x).y</code>(因为取地址操作符*属于下节内容，低优先级得打括号)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsafe</span></span><br><span class="line">            &#123;</span><br><span class="line">                Students Stu;</span><br><span class="line">                Stu.ID = <span class="number">1</span>;</span><br><span class="line">                Stu.score = <span class="number">99</span>;</span><br><span class="line">                Students* pstu = &amp;Stu;</span><br><span class="line">                pstu-&gt;score = <span class="number">100</span>;</span><br><span class="line">                (*pstu).score = <span class="number">120</span>;</span><br><span class="line">                Console.WriteLine(Stu.score);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> Students &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">int</span> ID;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> score;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不能将-&gt;运算符应用于类型void*的表达式</p><blockquote><p>以下四种暂时不做讲解</p><p><code>x?.y</code>、<code>x?[y]</code> Null 条件运算符</p><p><code>x!</code> null 包容(抑制)运算符</p><p><code>nameof</code> 表达式可生成变量、类型或成员的名称作为字符串常量</p><p><code>stackalloc</code> 表达式在堆栈上分配内存块</p><p><code>x++</code>与 <code>x--</code>：后缀/置递增（减）运算符（与前置++和–一起讲）</p></blockquote><h5 id="2-一元运算符">2.一元运算符</h5><blockquote><p><code>await</code>运算符 比较复杂放到后续讲解</p></blockquote><blockquote><p><code>*p</code>：指针间接运算符; <code>&amp;x</code>：Address-of 运算符（取地址运算符）</p></blockquote><p><code>*x</code>运算符用于获取其操作数p指向的变量，所以也叫取消引用运算符。该运算符的操作数必须是指针类型</p><p><code>&amp;x</code>运算符返回其操作数x的地址</p><p>示例同指针成员访问运算符</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsafe</span></span><br><span class="line">            &#123;</span><br><span class="line">                Students Stu;</span><br><span class="line">                Stu.ID = <span class="number">1</span>;</span><br><span class="line">                Stu.score = <span class="number">99</span>;</span><br><span class="line">                Students* pstu = &amp;Stu;</span><br><span class="line">                pstu-&gt;score = <span class="number">100</span>;</span><br><span class="line">                (*pstu).score = <span class="number">120</span>;</span><br><span class="line">                Console.WriteLine(Stu.score);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> Students &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">int</span> ID;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>true</code>与 <code>false</code>： true 和 false运算符</p></blockquote><p>该运算符不用过多介绍，<code>true</code> 运算符返回bool布尔值true，以指明其操作数一定为 true。 <code>false</code> 运算符返回 <code>bool</code> 值true，以指明其操作数一定为 false。用来判断bool值，常用来重载 <code>&amp;&amp;</code> 和 <code>||</code>，并在<strong>逻辑运算符的短路运算</strong>中会使用</p><blockquote><p><code>+x</code> 与 <code>-x</code> ：正负运算符（注意与加减法区分）</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">按位求补<span class="comment">//与加减法相似的地方</span></span><br><span class="line">Console.WriteLine(+<span class="number">4</span>); <span class="comment">//+ 运算符返回其操作数的值</span></span><br><span class="line">Console.WriteLine(<span class="number">-4</span>); <span class="comment">//- 运算符对其操作数的数值取负，但ulong类型不支持-运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与加减法不相似的地方</span></span><br><span class="line">计算机中使用正负操作符容易溢出，因为带有符号的数据类型最大值和最小值在绝对值上是不对称的</span><br><span class="line">Console.WriteLine(<span class="built_in">int</span>.MaxValue);</span><br><span class="line">Console.WriteLine(<span class="built_in">int</span>.MinValue);<span class="comment">//输出的是2147483647和-2147483648，发现打印值不同</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> x = <span class="built_in">int</span>.MinValue;</span><br><span class="line"><span class="built_in">int</span> y = -x;</span><br><span class="line">Console.WriteLine(x);</span><br><span class="line">Console.WriteLine(y);</span><br><span class="line"><span class="comment">//输出的x与y值相等，使用checked关键字int y = checked(-x);再尝试一次</span></span><br><span class="line"><span class="comment">//原来在这过程中发生溢出，而造成的原因就是按位求补过程，于是引出按位求补运算符</span></span><br></pre></td></tr></table></figure><blockquote><p><code>~x</code>：按位求补（<strong>取反</strong>）运算符</p></blockquote><p>按位求补：反转每个位bit进而产生其操作数，这里用二进制格式作为输出</p><p>补充知识：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string.padleft?view=net-6.0">String.PadLeft</a>或<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string.padright?view=net-6.0">String.PadRight</a>方法（给字符串实现补位）</p><p>PadLeft——固定长度输出，右对齐；PadRight——固定长度输出，左对齐</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">12345</span>;</span><br><span class="line">Console.WriteLine(Convert.ToString(a, <span class="number">2</span>).PadLeft(<span class="number">32</span>, <span class="string">&#x27;0&#x27;</span>));<span class="comment">//共32位并右对齐，没有值用0补齐</span></span><br><span class="line"><span class="built_in">int</span> b = ~a;</span><br><span class="line">Console.WriteLine(Convert.ToString(b,<span class="number">2</span>).PadLeft(<span class="number">32</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="comment">//输出：00000000000000000011000000111001</span></span><br><span class="line"><span class="comment">//     11111111111111111100111111000110</span></span><br><span class="line"><span class="comment">//这里解答上面的答案</span></span><br><span class="line"><span class="built_in">int</span> x = <span class="built_in">int</span>.MinValue;</span><br><span class="line"><span class="built_in">int</span> y = ~x;</span><br><span class="line"><span class="built_in">int</span> z = -x;</span><br><span class="line">Console.WriteLine(Convert.ToString(x, <span class="number">2</span>).PadLeft(<span class="number">32</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">Console.WriteLine(Convert.ToString(y, <span class="number">2</span>).PadLeft(<span class="number">32</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">Console.WriteLine(Convert.ToString(z, <span class="number">2</span>).PadLeft(<span class="number">32</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="comment">//输出： 10000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//      01111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//   此处10000000000000000000000000000000是由01111111111111111111111111111111+1得到的</span></span><br><span class="line"><span class="comment">//说明负运算符是将操作数取反后加1，于是容易产生溢出异常</span></span><br></pre></td></tr></table></figure><blockquote><p><code>!x</code>：逻辑<strong>非</strong>操作符</p></blockquote><p>!x:计算操作数x的逻辑非,x必须是Bool布尔值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> passed = <span class="literal">false</span>;</span><br><span class="line">Console.WriteLine(!passed);  <span class="comment">// 输出 True</span></span><br><span class="line">Console.WriteLine(!<span class="literal">true</span>);    <span class="comment">// 输出 False</span></span><br></pre></td></tr></table></figure><p>实际场景中，常用来实现判断</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> initName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(initName))<span class="comment">//string.IsNullOrEmpty()用来判断字符串是否为null值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = initName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;initname cannot be null or empty&quot;</span>);</span><br><span class="line">        <span class="comment">//ArgumentException类：当向方法提供的参数之一无效时引发的异常，使用throw 关键字引发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.argumentexception?view=net-6.0">ArgumentException类</a>、<a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/creating-and-throwing-exceptions">throw new ArgumentException</a></p><p>为了对null值进行拾取（包容有Null值），所以在 C# 8.0 及更高版本中，一元后缀 <code>!</code> 运算符使得更改表达式的 null 状态来完成对它的包容</p><blockquote><p><code>x！</code>：null包容运算符 或 null抑制运算符</p></blockquote><p>null 包容运算符在运行时不起作用。 它仅通过更改表达式的 null 状态来影响编译器的静态流分析。 在运行时，表达式x!的计算结果为基础表达式x的结果。</p><blockquote><p><code>++ </code>：增量运算符 ；<code>--</code>：减量运算符</p></blockquote><p>该类操作符分为前置和后置，值得注意的是后置优先级更高</p><p>前后置都会修改操作数的值，区别就是返回值中，后置操作符返回修改前的值，前置操作符返回修改后的值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后缀递增运算符与前缀增量运算符</span></span><br><span class="line"><span class="built_in">int</span> i = <span class="number">3</span>;</span><br><span class="line">Console.WriteLine(i);   <span class="comment">//输出 3</span></span><br><span class="line">Console.WriteLine(i++); <span class="comment">//输出 3 后置++，返回值为原来的i值</span></span><br><span class="line">Console.WriteLine(i);   <span class="comment">//输出 4 </span></span><br><span class="line">Console.WriteLine(++i); <span class="comment">//输出 5 前置++，返回值为修改后的i值</span></span><br></pre></td></tr></table></figure><p>类似的，减量运算符也有这样特点</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后缀递减运算符与前缀减量运算符</span></span><br><span class="line"><span class="built_in">int</span> i = <span class="number">3</span>;</span><br><span class="line">Console.WriteLine(i);   <span class="comment">//输出 3</span></span><br><span class="line">Console.WriteLine(i--); <span class="comment">//输出 3 后置--，返回值为原来的i值</span></span><br><span class="line">Console.WriteLine(i);   <span class="comment">//输出 2 </span></span><br><span class="line">Console.WriteLine(--i); <span class="comment">//输出 1 前置--，返回值为修改后的i值</span></span><br></pre></td></tr></table></figure><blockquote><p><code>(T)E</code>:强制转换表达式/强制类型转换操作符</p></blockquote><p>其中，T表示Type目标数据类型，E表示Expression表达式，A cast expression of the form <code>(T)E</code> performs an explicit conversion of the result of expression <code>E</code> to type <code>T</code>：形式为 <code>(T)E</code> 的强制转换表达式将表达式 <code>E</code> 的结果<strong>显式</strong>转换为类型 <code>T</code></p><p>但是，因为该过程为显式强制性转换， 在运行时，显式转换可能不会成功，强制转换表达式可能会引发异常。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> x = <span class="number">1234.7</span>;</span><br><span class="line"><span class="built_in">int</span> a = (<span class="built_in">int</span>)x;</span><br><span class="line">Console.WriteLine(a); <span class="comment">// 输出1234</span></span><br></pre></td></tr></table></figure><p>再比如</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = Console.ReadLine();</span><br><span class="line"><span class="built_in">string</span> str2 = Console.ReadLine();</span><br><span class="line">Console.WriteLine(str1+str2); <span class="comment">//加号左右两边是字符串，使用的是字符串拼接,而不是算术运算</span></span><br></pre></td></tr></table></figure><p>这时候需要怎么转换呢？于是引出下节的转换专题（可以使用Convert类）</p><h5 id="3-范围运算符">3.范围运算符</h5><h5 id="4-switch和-with表达式">4.<code>switch</code>和 <code>with</code>表达式</h5><h5 id="5-算术运算符">5.算术运算符</h5><p>需要注意的是类型提升和<a href="https://docs.microsoft.com/zh-cn/previous-versions/6a71f45d(v=vs.110)">算术溢出</a>，乘除取余比加减优先级高</p><p>以乘法为例讲解类型提升</p><p>当计算int和double类型的乘法，会默认提升至double类，以确保精度</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3.0</span> * <span class="number">4</span>;</span><br><span class="line">Console.WriteLine(x.GetType().FullName);</span><br></pre></td></tr></table></figure><blockquote><p><code>x*y</code>：乘法运算符</p></blockquote><p>乘法运算符 <code>*</code> 计算其操作数的乘积</p><ul><li>整数乘法：左右两边是整数int、uint、long、ulong等，如果超出范围，则引发system.OverflowException超出范围异常</li><li>浮点乘法：左右两边是浮点数float和double，需要注意的是非零有值、零、无穷大（分为正负无穷大）和NaN（not a number，不是数字）的乘法组合结果</li><li>小数乘法：左右两边是小数decimal，精确度比浮点数高</li></ul><p>可以采用下面的程序去验证乘法是什么类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3.0</span> * <span class="number">4.0</span>;</span><br><span class="line">Console.WriteLine(x.GetType().FullName);</span><br></pre></td></tr></table></figure><blockquote><p><code>x/y</code>：除法运算符</p></blockquote><p>除法运算符 <code>/</code> 用它的左侧操作数<strong>除以</strong>右侧操作数</p><ul><li><p>整数除法：整数类型的操作数，<code>/</code> 运算符的结果为整数类型，并且等于两个操作数之商<strong>向零</strong>舍入后的结果（将商代入向下取整函数）。不能除以0，不然将会出现DivideByZeroException除0异常</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">int</span> y = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> z = x/y;</span><br><span class="line">Console.WriteLine(z);<span class="comment">//输出为1</span></span><br></pre></td></tr></table></figure></li><li><p>浮点除法：获取float、double或 decimal 类型的商，如果操作数之一为 <code>decimal</code>，那么另一个操作数不得为 <code>float</code> 和 <code>double</code>，因为 <code>float</code> 和 <code>double</code> 都无法隐式转换为 <code>decimal</code>。必须将 <code>float</code> 或 <code>double</code> 操作数显式转换为 <code>decimal</code> 类型</p><p>没有DivideByZeroException除0异常，反而是有无穷和NAN值，正/0=+∞，负/0=-∞，如何使用呢？</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> x = <span class="built_in">double</span>.PositiveInfinity;<span class="comment">//正无穷</span></span><br><span class="line"><span class="built_in">double</span> y = <span class="built_in">double</span>.NegativeInfinity;<span class="comment">//负无穷</span></span><br><span class="line"><span class="built_in">double</span> z = <span class="built_in">double</span>.NaN; <span class="comment">//N</span></span><br></pre></td></tr></table></figure><p>注意除法和强制类型转换的优先级</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> x = (<span class="built_in">double</span>)<span class="number">5</span>/<span class="number">4</span>;<span class="comment">//等价于double(5/4)</span></span><br></pre></td></tr></table></figure><blockquote><p><code>x%y</code>：余数运算符</p></blockquote><p>取余运算符 <code>%</code>是，不是<a href="https://www.w3cschool.cn/moderncryptography/moderncryptography-ns2m38un.html#:~:text=%E2%80%9C%E5%8F%96%E6%A8%A1%E2%80%9D%E5%AE%9E%E8%B4%A8%E4%B8%8A%E6%98%AF%E8%AE%A1%E9%87%8F%E5%99%A8%E4%BA%A7%E7%94%9F%E2%80%9C%E6%BA%A2%E5%87%BA%E2%80%9D%E7%9A%84%E9%87%8F%EF%BC%8C%E5%AE%83%E7%9A%84%E5%80%BC%E5%9C%A8%E8%AE%A1%E9%87%8F%E5%99%A8%E4%B8%8A%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%87%BA%E6%9D%A5%EF%BC%8C%E8%AE%A1%E9%87%8F%E5%99%A8%E4%B8%8A%E5%8F%AA%E8%83%BD%E8%A1%A8%E7%A4%BA%E5%87%BA%E6%A8%A1%E7%9A%84%E4%BD%99%E6%95%B0%20%28%E5%8F%96%E6%A8%A1%29%EF%BC%9B%E4%BB%BB%E4%BD%95%E6%9C%89%E6%A8%A1%E7%9A%84%E8%AE%A1%E9%87%8F%E5%99%A8%EF%BC%8C%E5%9D%87%E5%8F%AF%E5%8C%96%E4%B8%BA%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%205%20mod%203,%3D%202%20%E4%BE%8B%E5%AD%90%E4%B8%AD%EF%BC%9B%E6%A8%A1%20%E4%B8%BA%203%EF%BC%9B2%20%E4%B8%BA%E5%8F%96%E6%A8%A1%E7%9A%84%E5%80%BC">取模运算符</a>，java有取余，而python有取模</p><p>也涉及类型提升，需要注意</p><blockquote><p><code>x+y</code>：加法运算符；<code>x-y</code>：减法运算符</p></blockquote><p><code>+</code>运算符用来计算其操作数的和（包括字符串串联）和委托组合；<code>-</code>运算符用于从其左侧操作数中减去其右侧操作数和删除委托</p><p>这两个运算符可以操作委托，这里不记录</p><h5 id="6-移位运算符">6.移位运算符</h5><p>二进制左移就是操作数乘2，二进制右移就是操作数除以2</p><blockquote><p><code>x&lt;&lt;y</code>：左移位运算符</p></blockquote><p><code>&lt;&lt;</code>运算符将其左侧操作数向左移动右侧操作数定义的位数</p><p>左移运算会放弃超出结果类型范围的高阶位，并将低阶空位位置设置为零</p><p>左移位运算与左侧操作数 <code>x</code>的数据类型：</p><ul><li><p>移位运算符仅针对 <code>int</code>、<code>uint</code>、<code>long</code> 和 <code>ulong</code> 类型定义，所以运算的结果始终包含<strong>至少 32 位</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">int</span> y = x &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="built_in">string</span> strX = Convert.ToString(x,<span class="number">2</span>).PadLeft(<span class="number">32</span>, <span class="string">&#x27;0&#x27;</span>);<span class="comment">//显示32位，并右对齐</span></span><br><span class="line"><span class="built_in">string</span> strY = Convert.ToString(y, <span class="number">2</span>).PadLeft(<span class="number">32</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">Console.WriteLine(strX);</span><br><span class="line">Console.WriteLine(strY);</span><br><span class="line">Console.WriteLine(y);</span><br></pre></td></tr></table></figure></li><li><p>如果左侧操作数是其他整数类型（<code>sbyte</code>、<code>byte</code>、<code>short</code>、<code>ushort</code> 或 <code>char</code>），则其值将转换为 <code>int</code> 类型</p></li></ul><blockquote><p><code>x&gt;&gt;y</code>：右移位运算符</p></blockquote><p><code>&gt;&gt;</code>运算符将其左侧操作数向右移动右侧操作数定义的位数，右移位运算会放弃低阶位</p><p>左侧操作数为非负，高顺序空位位置设置为零，如果为负，则将该位置设置为 1</p><p>右移位运算与左侧操作数 <code>x</code>的数据类型：</p><ul><li>左侧操作数的类型是 <code>int</code> 或 <code>long</code>，则右移运算符执行算术移位：左侧操作数的最高有效位（符号位）的值将传播到高顺序空位位置，即左侧操作数为非负，高顺序空位位置设置为零，如果为负，则将该位置设置为 1</li><li>左侧操作数是 <code>uint</code> 或 <code>ulong</code>类型，则右移运算符执行逻辑移位：高顺序空位位置始终设置为零</li></ul><h5 id="7-关系和类型测试运算符">7.关系和类型测试运算符</h5><p>关系运算符的返回值是布尔值</p><ul><li><p>对于<strong>数值类型</strong>，通过关系运算符就能检查</p><blockquote><p><code>&lt;</code> ：小于运算符</p></blockquote><p>如果左侧操作数小于右侧操作数，<code>&lt;</code> 运算符返回 <code>true</code>，否则返回 <code>false</code></p><blockquote><p><code>&gt;</code> ：大于运算符</p></blockquote><p>如果左侧操作数大于右侧操作数，<code>&gt;</code> 运算符返回 <code>true</code>，否则返回 <code>false</code></p><blockquote><p><code>&lt;=</code>：小于或等于运算符</p></blockquote><p>如果左侧操作数小于或等于右侧操作数，<code>&lt;=</code> 运算符返回 <code>true</code>，否则返回 <code>false</code></p><blockquote><p><code>&gt;=</code> ：大于或等于运算符</p></blockquote><p>如果左侧操作数大于或等于右侧操作数，<code>&gt;=</code> 运算符返回 <code>true</code>，否则返回 <code>false</code></p></li></ul><p>例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">double</span> y = <span class="number">8.0</span>;</span><br><span class="line"><span class="keyword">var</span> res = x &gt; y;<span class="comment">//可以注意到赋值的优先级最低</span></span><br><span class="line">Console.WriteLine(res.GetType().FullName);</span><br><span class="line">Console.WriteLine(res);</span><br></pre></td></tr></table></figure><ul><li>对于<strong>字符类char</strong>，会比较字符对应的ASCii码值</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> char1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">char</span> char2 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> res = char1&gt;char2;</span><br><span class="line">Console.WriteLine(res); <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">ushort</span> u1 = (<span class="built_in">ushort</span>)char1;</span><br><span class="line"><span class="built_in">ushort</span> u2 = (<span class="built_in">ushort</span>)char2;</span><br><span class="line">Console.WriteLine(u1); <span class="comment">//输出97</span></span><br><span class="line">Console.WriteLine(u2);  <span class="comment">// 输出65</span></span><br><span class="line">Console.WriteLine(u1&gt;u2); <span class="comment">//输出True</span></span><br></pre></td></tr></table></figure><ul><li>对于<strong>字符串类string</strong>，可以通过**ToLower()<strong>方法全部转为小写再进行比较，或者使用</strong>string.Compare()**方法（后续学习）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;Abc&quot;</span>;</span><br><span class="line">Console.WriteLine(str1.ToLower()==str2.ToLower());</span><br></pre></td></tr></table></figure><blockquote><p><code>is</code> ：类型测试运算符</p></blockquote><p><code>is</code>运算符检验对象是否为某类型</p><p>使用方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E（expression） <span class="keyword">is</span> T（type）</span><br></pre></td></tr></table></figure><p>E表达式是否为T类型？E不能为匿名方法或Lambda表达式</p><p>如果表达式结果为非null并且满足以下任一条件，则 <code>is</code>运算符将返回 <code>true</code>：</p><ul><li>表达式结果的运行时类型为T</li><li>表达式结果的运行时类型派生自类型T、实现接口T，或者存在从其到 T的另一种T(比如所有类都是派生自Object类)</li><li>表达式结果的运行时类型是基础类型为 且Nullable.HasValue为 <code>true</code>的可为空值类型</li><li>存在从表达式结果的运行时类型到类型的装箱或取消装箱转换</li></ul><p><code>is</code>运算符不会考虑用户定义的转换</p><blockquote><p><code>as</code>：运算符</p></blockquote><p><code>as</code> 运算符将表达式结果<strong>显式转换</strong>为给定的引用或可以为null值类型，如果无法进行转换，则 <code>as</code>运算符返回null，将 <code>as</code> 表达式的结果与null进行比较（!= null），可检查转换是否成功。从 C# 7.0 开始，你可以使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#type-testing-with-pattern-matching">is 运算符</a>测试转换是否成功，如果成功，则将其结果分配给新变量。</p><p>与<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression">强制转换表达式</a>不同，运算符永远不会引发异常</p><p>使用方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E（返回值表达式expression） <span class="keyword">as</span>  T（类型type）</span><br></pre></td></tr></table></figure><h5 id="8-相等运算符">8.相等运算符</h5><p>=运算符，！=运算符</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/equality-operators#equality-operator-">文档</a></p><h5 id="9-逻辑运算符">9.逻辑运算符</h5><p>用于操作二进制：优先级 位与&gt;位异或&gt;位或</p><blockquote><p><code>x &amp; y</code>：逻辑与（位逻辑AND）运算符</p><p><code>x ^ y</code>：逻辑异或（位逻辑XOR）运算符</p><p><code>x | y</code>：逻辑或（位逻辑OR）运算符</p></blockquote><p>示例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">int</span> y = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">int</span> z = x &amp; y;<span class="comment">//这里可以改成其他运算符</span></span><br><span class="line"><span class="built_in">string</span> strX = Convert.ToString(x,<span class="number">2</span>).PadLeft(<span class="number">32</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="built_in">string</span> strY = Convert.ToString(y, <span class="number">2</span>).PadLeft(<span class="number">32</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="built_in">string</span> strZ = Convert.ToString(z, <span class="number">2</span>).PadLeft(<span class="number">32</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">Console.WriteLine(strX);</span><br><span class="line">Console.WriteLine(strY);</span><br><span class="line">Console.WriteLine(strZ);</span><br></pre></td></tr></table></figure><p>分析输出结果</p><pre><code>00000000000000000000000000000111</code></pre><p>AND 00000000000000000000000000011100</p><pre><code>00000000000000000000000000000100</code></pre><p>AND：必须1&amp;1=1才输出true/1</p><p>XOR：计算结果与不等运算符！=相同，只要不相等就输出False/0</p><p>OR：有一个1就能输出true/1</p><h5 id="10-条件逻辑操作符">10.条件逻辑操作符</h5><p>条件与&gt;条件或</p><blockquote><p><code>x&amp;&amp;y</code>：条件逻辑与（“短路”逻辑与）运算符</p><p><code>x||y</code>：条件逻辑或（“短路”逻辑或）运算符</p></blockquote><p>区别：</p><p>&amp;：不管前面的条件是否正确，后面都执行，两方不是bool类型，会执行位操作。</p><p>&amp;&amp;：前面条件正确时，才执行后面；不正确时，就直接不执行后面**（短路效应）**</p><p>而||：当前面出现true，就直接成立，不计算后面</p><p>这一点和Java类似</p><h5 id="11-Null合并运算符">11.Null合并运算符</h5><p>需求1：某学生成绩目前因为某原因并未录入，需要先用null值填充，后续再进行赋值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Nullable&lt;<span class="built_in">int</span>&gt; x = <span class="literal">null</span>;<span class="comment">//声明x为可空的int类型</span></span><br><span class="line">Console.WriteLine(x.HasValue);<span class="comment">//输出false，代表没有值</span></span><br><span class="line">x = <span class="number">100</span>;<span class="comment">//学生该科成绩x赋值为100</span></span><br><span class="line">Console.WriteLine(x);<span class="comment">//输出x值100</span></span><br><span class="line">Console.WriteLine(x.HasValue);<span class="comment">//输出true，代表有值</span></span><br></pre></td></tr></table></figure><p>这里的可空类型比较常用，所以微软就把Nullable<code>&lt;int&gt;</code>改成int?,即</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nullable&lt;<span class="built_in">int</span>&gt; 等价于 <span class="built_in">int</span>?</span><br><span class="line">那么Nullable&lt;<span class="built_in">int</span>&gt; x = <span class="literal">null</span>; 与 <span class="built_in">int</span>? x = <span class="literal">null</span>; 等价</span><br></pre></td></tr></table></figure><p>需求2：假如该生成绩是因为缺考，那需要给他0分</p><p>这时候使用这里的Null合并运算符</p><blockquote><p><code>x??y</code>：Null合并运算符</p></blockquote><p>如果左操作数的值不为 <code>null</code>，则 null 合并运算符 <code>??</code> 返回该值；否则，它会计算右操作数并返回其结果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? x = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> y = x ?? <span class="number">0</span>;<span class="comment">//x是否为null值，那把y赋值为0</span></span><br><span class="line">Console.WriteLine(y);</span><br></pre></td></tr></table></figure><h5 id="12-条件运算符">12.条件运算符</h5><blockquote><p><code>c?t:f</code>：（三元）条件运算符</p></blockquote><p>该运算符用于计算布尔表达式，并根据布尔表达式的计算结果为 <code>true</code>还是 <code>false</code>来返回两个表达式中的一个结果（本质上是ifelse的简写）</p><p>使用方法</p><blockquote><p>condition ? consequent(正确时) : alternative（错误时）</p></blockquote><p>并且为<strong>右联运算符</strong></p><blockquote><p>a ? b : c ? d : e == a ? b : (c ? d : e)</p></blockquote><h5 id="13-赋值和lambda声明">13.赋值和lambda声明</h5><p>赋值</p><blockquote><p>x=y</p></blockquote><p>这个很简单，就是把y赋值给x。</p><p>复合赋值</p><p>对于一些赋值，微软提供了简写，把运算和赋值放在了一起</p><p>对于二元运算符 <code>op</code>，窗体的复合赋值表达式</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x op= y 等价于 x = x op y</span><br></pre></td></tr></table></figure><blockquote><p>x+=y：x = x + y</p><p>x-=y</p><p>x*=y</p><p>x/=y</p><p>x%=y</p><p>x&amp;=y</p><p>x|=y</p><p>x^=y</p><p>x&lt;&lt;=y</p><p>x&gt;&gt;=y</p><p>x??=y</p></blockquote><p>lambda声明</p><blockquote><p>=&gt;：lambda运算符（delegate中讲解过）</p></blockquote><h3 id="四、数据类型转换">四、数据类型转换</h3><blockquote><p>参考微软<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/conversions#explicit-conversions">转换专题</a>，这里主要讲解的是隐式类型转换(Implicit conversions)、显式类型转换(explicit conversions)和自定义类型转换(User-defined conversions) <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/numeric-conversions">其他参考</a></p></blockquote><p>某些转换是由语言定义的，比如一些预定义的隐式转换：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="built_in">int</span>.MaxValue; </span><br><span class="line"><span class="built_in">long</span> b = a; <span class="comment">// 语言自动将int转换为long</span></span><br><span class="line">Console.WriteLine(b);</span><br></pre></td></tr></table></figure><p>程序还可以定义自己的转换，也就是后面我们讲的自定义类型转换</p><h5 id="1-隐式转换">1.隐式转换</h5><ul><li><p>不丢失精度的转换——<strong>隐式数值转换</strong></p><p>隐式转换可能会在多种情况下发生，包括函数成员调用;强制转换表达式,并赋值运算符</p><p>预定义的隐式转换始终会成功，并且永远不会引发异常</p><p>比如本节开始的从Int到Long，再比如从float到double：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> a = <span class="built_in">float</span>.MaxValue; </span><br><span class="line"><span class="built_in">double</span> b = a;</span><br><span class="line">Console.WriteLine(b);</span><br></pre></td></tr></table></figure></li><li><p>子类向父类的转换：多态（算是隐式转换的一种），其中还包含继承，建议放后面学习</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">          Human h = t;</span><br><span class="line">          <span class="comment">//将t赋给h是可行的，t所存的地址交给变量h，包含子类向父类的转换</span></span><br><span class="line">          <span class="comment">//h可以访问Human类方法，但无法访问Teacher类的方法</span></span><br><span class="line">          Animal a = h;</span><br><span class="line">          <span class="comment">//h可以访问Animal类方法，但无法访问Human类的方法</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Eating..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title">Human</span> : <span class="title">Animal</span>  <span class="comment">//Human继承自Animal</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Think</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;Who i am ?&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Teacher</span> : <span class="title">Human</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Teach</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;I teach the course&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>装箱转换：参考之前学习的装箱</li></ul><h5 id="2-显式转换">2.显式转换</h5><ul><li><p>有可能失去精度（甚至引发异常）的转换——<strong>显式数值转换</strong></p><p>也叫cast转换，cast是造型、模子的意思，C++中也有cast转换，隐式数值转换中尚不存在的形式，使用该形式转换，可能会丢失信息，或可能导致引发异常。</p><p>显式数值转换的处理方式可以参考微软文档中的显式数值转换，比如checked上下文</p></li><li><p>拆箱转换（取消装箱转换）：参考之前学习的拆箱</p></li><li><p>使用Convert类</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121115313.png" alt="image-20220120162903985"></p><p>可以看到Convert类用来将一个基本数据类型转换为另一个基本数据类型。继续按 <code>F1</code>键可以看到它属于命名空间System以及各种示例，基本可以把任何数据类型随意转换。里面还有Convert.ToSomeType()方法</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121115869.png" alt="image-20220120164709893"></p></li><li><p>ToString方法（不是Convert的方法）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121115013.png" alt="image-20220120163551828"></p><p>可以看到<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.object.tostring?view=net-6.0">Object.ToString方法</a>是将Object对象转换为其字符串表示形式以显示。继续按 <code>F1</code>键可以看到它属于命名空间System以及各种示例。</p></li><li><p>各种数据类型的Parse/TryParse方法</p><p>数据类型会自带一些方法或者属性，而其中的Parse/TryParse方法用于字符串类型转换成目标格式</p><p>使用方法： <code>目标类型.Parse(需要转换的字符串)</code>   比如 int.Parse(“12”)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;12&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;13&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> num1 = <span class="built_in">int</span>.Parse(str1);<span class="comment">//目标数据类型为int，待转换的数据为str1</span></span><br><span class="line"><span class="built_in">double</span> num2 = <span class="built_in">double</span>.Parse(str2);<span class="comment">//目标数据类型为double，待转换的数据为str2</span></span><br><span class="line">Console.WriteLine(num1+num2);</span><br></pre></td></tr></table></figure><p>但是Parse方法只能解析格式正确的字符串类型，即要求格式对应，比如字符串为“1ab”，转换int格式，将出现 FormatException异常，如下图</p><p>比如将string str2 = “13”;改成 string str2 = “13a”;</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121115221.png" alt="image-20220120211512368"></p><p>而<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32.tryparse?view=net-6.0">tryParse方法</a>返回的是布尔值，转换成功返回true，失败返回false而不是异常，并且还有输出参数，会将解析值返回</p></li></ul><h5 id="3-自定义转换">3.自定义转换</h5><p>操作符本质是方法的简记法，而类型转换也应该是某方法的简记法。那如何去定义自己的呢？</p><p>示例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含关键字的转换运算符声明 explicit引入了用户定义的显式转换</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Stone stone = <span class="keyword">new</span> Stone();</span><br><span class="line">            stone.Age = <span class="number">5000</span>;</span><br><span class="line">            Monkey wukongSun = (Monkey)stone;</span><br><span class="line">            Console.WriteLine(wukongSun.Age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Stone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Monkey</span>(<span class="params">Stone stone</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Monkey m = <span class="keyword">new</span> Monkey();</span><br><span class="line">            m.Age = stone.Age / <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Monkey</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//implicit的用法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stone stone = <span class="keyword">new</span> Stone();</span><br><span class="line">    stone.Age = <span class="number">5000</span>;</span><br><span class="line">    Monkey wukongSun = stone; <span class="comment">//这里删除(Monkey)，因为是隐式的，会自动转换</span></span><br><span class="line">    Console.WriteLine(wukongSun.Age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Stone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Monkey</span>(<span class="params">Stone stone</span>) <span class="comment">//改成implicit</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Monkey m = <span class="keyword">new</span> Monkey();</span><br><span class="line">        m.Age = stone.Age/<span class="number">500</span>;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Monkey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>第七章 表达式、语句</h1><p>构成应用程序的 C# 代码由关键字、表达式和运算符组成的语句所组成。<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/">参考</a></p><p>我们前面已经讲解了运算符，这里讲解表达式=运算符（+操作数）</p><h2 id="一、表达式">一、表达式</h2><h5 id="1-表达式expression定义">1.表达式expression定义</h5><p>表达式是任何一门语言的基本组件之一（表达式、命令和声明），但是每门语言对表达式的实现是不同的。<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/expressions">参考</a></p><p>表达式是运算符和操作数构成的序列。</p><p>C#中的表达式：至少有操作数，可以有操作符。表达式是为了求值，而</p><p>**求值后的的结果（也对应程序的常见输出）**可以为</p><ul><li><p>single  value 单一的值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">x = <span class="number">100</span>;<span class="comment">//赋值表达式</span></span><br></pre></td></tr></table></figure></li><li><p>object</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> form();<span class="comment">//new是操作符，form()是操作数</span></span><br><span class="line">(<span class="keyword">new</span> form()).ShowDialog();</span><br></pre></td></tr></table></figure></li><li><p>method</p><p>委托模仿C的函数指针，可以管理某些方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action myAction = <span class="keyword">new</span> Action(Console.Writeline);<span class="comment">//可以得到语法实体但是不调用</span></span><br></pre></td></tr></table></figure></li><li><p>namespace</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Window.Forms.Form myForm = <span class="keyword">new</span> Form();<span class="comment">//点操作符取名称空间</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>C#语言表达式的样式（组成）</strong></p><ul><li><p>a literal value 字面值（与数据类型有关）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">x = <span class="number">100</span>;<span class="comment">//100就是整型的字面值</span></span><br><span class="line"><span class="built_in">string</span> y;</span><br><span class="line">y = <span class="string">&quot;ok&quot;</span>;<span class="comment">//ok就是字符串的字面值</span></span><br></pre></td></tr></table></figure></li><li><p>method invocation 方法调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> x = Math.Pow(<span class="number">2</span>,<span class="number">10</span>);<span class="comment">//调用math类的pow函数，并使用赋值表达式交给x</span></span><br></pre></td></tr></table></figure></li><li><p>an operator and operands 操作符和操作数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">2</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>a simple name</p><ul><li><p>the name of a variable 变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">int</span> y;</span><br><span class="line">y = x;</span><br></pre></td></tr></table></figure></li><li><p>type memeber 类型成员</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type myType = <span class="keyword">typeof</span>(Int64);</span><br><span class="line">Console.WriteLine(myType.FullName);</span><br></pre></td></tr></table></figure></li><li><p>method parameter 方法参数</p></li><li><p>namespace 命名空间</p></li><li><p>type 类型</p></li></ul></li></ul><h5 id="3-表达式优先级">3.表达式优先级</h5><p>和操作符类似，也是有优先级</p><h5 id="4-表达式类型">4.表达式类型</h5><p>表达式类型和操作符相对应，操作符就是为了组成表达式！（数据类型）</p><ul><li><p>a value ：表达式产生的值都有具体的数据类型，与操作符相对应（可以把前面例程再试试）。比如x&lt;&lt;2，<strong>整个表达式</strong>输出的值和右边的int整型的2有关，再比如y = x，这个表达式的值和类型与赋值符号左边的式子一样</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检验方法</span></span><br><span class="line"><span class="keyword">var</span> x = (待论证的表达式);</span><br><span class="line">Console.WriteLine(x.FullName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line">Console.WriteLine(x++);<span class="comment">//输出表达式的值100，先输出x的值，再把x加上1</span></span><br><span class="line">Console.WriteLine(x);<span class="comment">//输出操作数的值101</span></span><br></pre></td></tr></table></figure></li><li><p>a variable 变量(可以很常见，存储值的变量)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>; </span><br><span class="line"><span class="built_in">int</span> y;</span><br><span class="line"><span class="built_in">int</span> y = x;</span><br></pre></td></tr></table></figure></li><li><p>a namespace 命名空间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Windows.Forms.Form myform;<span class="comment">//System.Windows.Forms三个都是命名空间，每个都是算是一个表达式</span></span><br></pre></td></tr></table></figure></li><li><p>a type 类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">typeof</span>[int32];<span class="comment">//取出的是int32的类型</span></span><br></pre></td></tr></table></figure></li><li><p>a method group 方法组</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WirteLine(<span class="string">&quot;Hello,World!&quot;</span>);<span class="comment">//WirteLine实际是一组方法，根据方法接受的参数判断使用哪个方法（重载）</span></span><br></pre></td></tr></table></figure><p>光标放到上面会发现有18多个重载</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203052126981.png" alt="image-20220305212649800"></p><p>点击（或者F12）后知道具体有哪些，重载决策会决定最后使用哪个方法</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205121115262.png" alt="image-20220305212831776"></p></li><li><p>a null literal</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Form myForm = <span class="literal">null</span>;<span class="comment">//可以把null当作一个特殊值</span></span><br></pre></td></tr></table></figure></li><li><p>an anonymous function 匿名方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action a = <span class="built_in">delegate</span> () &#123;Console.WriteLine(<span class="string">&quot;Hello，World！&quot;</span>);&#125;; <span class="comment">//可以和数组、列表的初始化相对比</span></span><br><span class="line">a();</span><br></pre></td></tr></table></figure></li><li><p>a property access 属性访问</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Form myForm = <span class="keyword">new</span> Form();</span><br><span class="line">myForm.Text = <span class="string">&quot;Hello&quot;</span>;<span class="comment">//成员访问符来访问属性</span></span><br><span class="line">myForm.ShowDialog();</span><br></pre></td></tr></table></figure></li><li><p>an event access 事件访问</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Form myForm = <span class="keyword">new</span> Form();</span><br><span class="line">    myForm.Text = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    myForm.Load += MyForm_Load;<span class="comment">//点运算符访问myForm的事件</span></span><br><span class="line">    <span class="comment">//myForm.Load+=加两下tab键，就能呼出下面的load事件</span></span><br><span class="line">    myForm.ShowDialog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyForm_Load</span>(<span class="params"><span class="built_in">object</span> sender, System.EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Form form = sender <span class="keyword">as</span> Form;<span class="comment">//将输入的object类型sender转换为form类型</span></span><br><span class="line">    <span class="keyword">if</span> (form == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    form.Text = <span class="string">&quot;New Title&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>an indexer access 索引访问</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            <span class="built_in">int</span> x = list[<span class="number">2</span>];<span class="comment">//通过索引器，访问第三个元素</span></span><br><span class="line">            System.Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Nothing 对返回值为void的方法的调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;Hello,World!&quot;</span>);<span class="comment">//按F12后发现方法没有返回值</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="5-复合表达式的求值">5.复合表达式的求值</h5><p>复合表达式是非正式的称呼，指的是平时使用时，使用的表达式经常是由基本表达式复合在一起的，此时复合的优先级和执行顺序很重要，这里和操作符的优先级和同优先级操作符的执行顺序相同</p><h2 id="二、语句">二、语句</h2><h3 id="1-语句的定义">1.语句的定义</h3><p>参考维普对语句的定义：</p><p>广义定义（维普）：语句是命令式编程语言的最小的独立元素，也是一种语法实体，功能是为了表达一些将要执行的动作。高级语言所写出的程序就是由一系列语句构成的（编程就是使用语句编写程序）。语句还具有自己的内部组件：表达式。</p><p>语句是高级语言的语法——汇编语言和机器语言只有指令。（严格的讲，高级语言的代码由语句组成，低级语言的代码由指令组成）语句等价于一个或一组有明显逻辑关联的指令。高级语言的作用就是把语句翻译成机器指令(验证方法可以查看视频)，“照顾人类”</p><p>C#中的<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/statements">编程指南</a>和<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/statements#labeled-statements">编程规范</a>：可以试着在文档中搜索语句</p><p>程序执行的动作就是以语句来表达的</p><p>语句的功能：声明变量，变量赋值，调用函数，集合中迭代（迭代语句），分支中进行跳转（选择语句）</p><p>根据所输入的数据不同，数据的流动过程是不一定一样的（如果有了选择语句，不同的数据值可能有不同的流向），也就是控制流（<strong>程序的逻辑方向</strong>）发生变化</p><p>常见操作包括声明变量、赋值、调用方法、循环访问集合，以及根据给定条件分支到一个或另一个代码块。语句在程序中的执行顺序称为“控制流”或“执行流”。 根据程序对运行时所收到的输入的响应，在程序每次运行时控制流可能有所不同。</p><p>语句可以是以分号结尾的单行代码，也可以是语句块中的一系列单行语句。 语句块括在括号 {} 中，并且可以包含嵌套块。</p><p>知识点</p><ul><li><p>语句除了能够让顺序性表达算法思想，实现条件判断、跳转和循环等方法控制程序逻辑的走向</p></li><li><p>语句的意义：陈述算法思想、控制逻辑走向，完成有意义的“动作”（Action）</p></li><li><p>C#的语句由分号；结尾，但是由分号结尾的不一定是语句</p><p>比如using指令后面的分号，再比如类中但是在类的方法体外的字段声明</p></li><li><p>那如何判断？语句一定是出现在方法体内（using后面和类中方法体外都不算）</p></li></ul><h3 id="2-语句的类型">2.语句的类型</h3><p>语句有三种类型：标签语句labeled_statement、声明语句declaration_statement和嵌入式语句embedded_statement</p><h4 id="标签语句">标签语句</h4><blockquote><p>以标签为前缀，为语句指定一个标签，然后可使用goto关键字跳转到该带标签的语句</p><p>格式为：<strong>标识符</strong> + <code>冒号:</code> + <strong>语句</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">F</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) <span class="keyword">goto</span> x;</span><br><span class="line">    x = -x;</span><br><span class="line">    x: <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明语句">声明语句</h4><p>用来声明变量、常量等。它分为两类：<strong>局部变量声明</strong>和<strong>局部常量声明</strong></p><ol><li>局部（本地）变量声明</li></ol><blockquote><p>用于声明一个或多个局部变量</p><p>格式为<strong>变量类型</strong> + <strong>局部变量声明器列表</strong></p></blockquote><p>变量类型可取type或者var，直接<strong>指定</strong>声明引入的变量类型。特别的，<code>var</code>应基于初始值设定项推断类型，后续将和type等同，需要前面提到的类型转换才能实现</p><p>声明器列表可由一个或多个本地变量声明器组成，多个本地变量声明器需要由<strong>逗号</strong>隔开。本地变量声明器可以是<strong>标识符</strong>或<strong>标识符=本地变量初始化器</strong>，本地变量初始化器可取表达式、数组初始化器和本地不安全初始化器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x;<span class="comment">//类型int 加上 标识符x</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">&quot;ok&quot;</span>;<span class="comment">//var 加上 标识符 = 本地变量初始化器</span></span><br><span class="line"><span class="built_in">int</span> x,y,z;<span class="comment">//类型int 加上用逗号隔开的本地变量声明</span></span><br><span class="line"><span class="built_in">int</span> x=<span class="number">100</span>,y=<span class="number">100</span>,z=<span class="number">100</span>;<span class="comment">//同样，可以加上标识符等于本地变量初始化器</span></span><br><span class="line"><span class="built_in">double</span>[] myArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一维数组类型double[] 加上 标识符myArray = 本地初始化器</span></span><br></pre></td></tr></table></figure><ol start="2"><li>局部（本地）常量声明</li></ol><blockquote><p>用于声明一个或多个本地变量</p><p>格式为**const **+ <strong>type</strong> + <strong>常量声明器列表</strong></p></blockquote><p>常量声明器列表和变量声明器列表格式相同，但是本地变量初始化器变成了常数表达式</p><h4 id="嵌入式语句">嵌入式语句</h4><p>某些语句（如迭代语句）后面始终跟有一条嵌入式语句。 此嵌入式语句可以是单个语句，也可以是语句块中括在括号 {} 内的多个语句， 甚至可以在括号 {} 内包含单行嵌入式语句。比如if语句中嵌套了Console.WriteLine(“Hello,World!”);，再比如if语句嵌套到if语句中，那么就能形成筛选功能的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">embedded_statement//嵌入式语句包含下列语句</span><br><span class="line">    : block 块语句</span><br><span class="line">    | empty_statement 空语句</span><br><span class="line">    | expression_statement 表达式语句</span><br><span class="line">    | selection_statement 选择语句</span><br><span class="line">    | iteration_statement 迭代语句</span><br><span class="line">    | jump_statement 跳转语句</span><br><span class="line">    | try_statement try语句</span><br><span class="line">    | checked_statement checked语句</span><br><span class="line">    | unchecked_statement unchecked语句</span><br><span class="line">    | lock_statement lock语句</span><br><span class="line">    | using_statement using语句</span><br><span class="line">    | yield_statement yield语句</span><br><span class="line">    | embedded_statement_unsafe 不安全嵌入式语句</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><h5 id="表达式语句">表达式语句</h5><blockquote><p>用来计算给定表达式的值，由表达式计算的值（如果有）<strong>将被丢弃</strong></p><p>格式为<strong>表达式</strong> + <strong>分号;</strong></p></blockquote><p>但是并非所有表达式都允许作为语句。诸如表达式 <code>x + y</code>和 <code>x == 1</code> 仅计算一个值（此值将被放弃)，则不允许作为语句。</p><p>比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">int</span> y = <span class="number">100</span>;</span><br><span class="line">x + y;<span class="comment">//但是C语言中语句是可以是编译成功的，C#会更严格</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203081646623.png" alt="image-20220308164618271"></p><p>表达式语句有下面类型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（方法）调用表达式invocation_expression</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象创建表达式object_creation_expression：new操作符构成的表达式，new能创建对象并调用对象的构造器</span></span><br><span class="line"><span class="keyword">new</span> Form();<span class="comment">//创建后会被回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值表达式assignment</span></span><br><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">x + = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置自增、减表达式，后置自增、减表达式</span></span><br><span class="line"><span class="comment">//st_increment_expression</span></span><br><span class="line"><span class="comment">//st_decrement_expression</span></span><br><span class="line"><span class="comment">//e_increment_expression</span></span><br><span class="line"><span class="comment">//e_decrement_expression</span></span><br><span class="line"><span class="built_in">int</span> y = <span class="number">50</span>;</span><br><span class="line">y++;</span><br><span class="line">y--;</span><br><span class="line">++y;</span><br><span class="line">--y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//await表达式await_expression（等讲异步再说）</span></span><br><span class="line"><span class="comment">//null_conditional_invocation_expression新内容未涉及</span></span><br></pre></td></tr></table></figure><p>“表达式的值被丢弃”的理解</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Add(<span class="number">3.0</span>, <span class="number">4.0</span>);<span class="comment">//此时值被丢弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那为何允许这样的情况存在呢，对上述的代码进行更改</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Add(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> result = a + b;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Result is &#123;0&#125;.&quot;</span>,result);<span class="comment">//打印这个值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改后是希望打印这个值，但是值不存储。此时虽然方法调用有了用处，但是违背了单一职责原则，一个方法做了两个事情，肯定有主副两个功能，方法要修改的话，需要更改这两处，会反而麻烦，也就是方法设计错误。</p><h5 id="块语句（块）">块语句（块）</h5><blockquote><p>用于在只允许使用单个语句的情况下，编写多个语句</p><p>格式为**{可选的语句列表}**</p></blockquote><p>块可以想象是代码的容器，格式中的语句列表statement_list由一个或多个按顺序写入的语句组成。</p><p>那我们平时看到空程序中的大括号是不是块语句呢？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;<span class="comment">//表示ConsoleApp名称空间的名称空间体</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;<span class="comment">//Program类的类体</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;<span class="comment">//Main方法的方法体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如何判断是否为块语句？块语句也是语句，<strong>必须在方法体内</strong>，所以方法体内的带花括号语句才是块语句</p><p>演示在块语句中编写其他类型代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>;<span class="comment">//声明语句</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">80</span>) <span class="keyword">goto</span> hello;<span class="comment">//嵌入式语句</span></span><br><span class="line">hello: Console.WriteLine(x);<span class="comment">//标签语句</span></span><br><span class="line"><span class="comment">//输出100</span></span><br></pre></td></tr></table></figure><p><strong>小技巧</strong>：开始和结束方括号不在一个屏幕，需要进行来回跳转时，可以光标放置结尾方括号，就能看到前面光标在哪，而且光标放置在方括号前后，按 <code>Ctrl</code>+<code>&#125;</code>键就能实现快速跳转</p><p>注意：块语句一般是和别的语句（if语句，for语句等）一起写的，很少分开</p><blockquote><p>有了块语句，就需要讨论变量的作用域：变量能够存在的区域，全局变量会全局存在，而局部（本地）变量会在块语句后回收</p></blockquote><p>示例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(x);</span><br><span class="line">    <span class="built_in">int</span> y = <span class="number">200</span>;</span><br><span class="line">    Console.WriteLine(y);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(y);<span class="comment">//error，出了作用域无法访问</span></span><br></pre></td></tr></table></figure><p>块语句内部声明为声明局部变量，只能在该块中存活</p><h5 id="选择-判断、分支-语句">选择(判断、分支)语句</h5><blockquote><p>根据某个表达式的值,选择执行多个可能的语句之一</p><p>分为if语句和switch语句</p></blockquote><ol><li>if语句</li></ol><blockquote><p>基于布尔表达式的值来选择要执行的语句</p><p>格式为<strong>if(布尔表达式)</strong> + <strong>单个嵌入式语句</strong></p><pre><code>**if(布尔表达式)** + **单个嵌入式语句（true分支）**+ **else** + **单个嵌入式语句（false分支）**</code></pre></blockquote><p>布尔表达式指的是能返回布尔值的语句</p><p>单个嵌入式语句需要放入很复杂的语句，可以使用块语句来嵌套</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">int</span> y = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">if</span>(x &gt; y)</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面示例会输出World，因为if语句只会包含后续的单个嵌入式语句。为了避免发生这类错误，所以编辑器在你键入if后，会直接插入块语句（<code>if</code>+两下 <code>Tab</code>），这也是编程规范的建议，即使所需语句只有一行也需要使用块语句。</p><p>if-else语句也需要在false分支时使用块语句</p><p>示例（分数甄选）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> score = <span class="number">85</span>;</span><br><span class="line"><span class="keyword">if</span>(score&gt;=<span class="number">0</span> &amp;&amp; score &lt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (score&gt;=<span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果逻辑一复杂，比如按照分数段分为ABCD等，用if语句会掉入思维定式，导致逻辑更复杂</p><p>elseif语句又是什么呢？其实质就是代码经过重构（逻辑简化），将else后面的块语句的块去掉，if语句也是单个嵌入式语句</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> score = <span class="number">85</span>;</span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line">&#123; </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;A&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">40</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Switch语句</li></ol><blockquote><p>执行时，会选一个语句列表，包含与switch表达式的值相对应的关联switch标签</p><p>格式为<strong>switch</strong> + <strong>(表达式)</strong> +<strong>switch块</strong></p></blockquote><p>switch语句其实可以理解为水管，哪个开关打开就去哪家。</p><p>其中，表达式类型需要是sbyte、byte、short、ushort、int、uint、long、ulong、bool、char、string或enum_type</p><p>switch块可以由一个或者多个switch部分组成，每一部分由标签和语句列表组成。标签格式有两种：<code>case</code>+<code>常数表达式</code>+<code>冒号:</code>或者 <code>default</code>+<code>冒号:</code></p><p>这里示例实现上面的分数分ABCD等</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> score = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">switch</span> (score / <span class="number">10</span>)<span class="comment">//除以10，进行简化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:<span class="comment">//case后常数表达式需与score类型对应</span></span><br><span class="line">        <span class="keyword">if</span> (score == <span class="number">100</span>)<span class="comment">//拾取score等于100的值，防止101-109的数引发bug</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="keyword">case</span> <span class="number">8</span>;<span class="comment">//跳转case 8或者9</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="literal">default</span>;<span class="comment">//跳转default</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//需要显式地写break（可以对break和continue进行对比）</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:<span class="comment">//默认跳转</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>再以枚举类型enum_type举例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Level myLevel = Level.High;</span><br><span class="line">    <span class="keyword">switch</span> (myLevel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> Level.High:</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;High&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Level.Mid:</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Mid&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Level.Low:</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Low&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> Level</span><br><span class="line">&#123;</span><br><span class="line">    High,</span><br><span class="line">    Mid,</span><br><span class="line">    Low,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Try语句">Try语句</h5><blockquote><p>提供了一种机制，用于<strong>捕获</strong>在执行块期间发生的<strong>异常</strong></p><p>格式：try块 + catch子句</p><pre><code>try块 + finally子句try块 + catch子句 + finally子句</code></pre></blockquote><p>catch子句可由一个或多个catch块组成，catch块的格式为<strong>catch <strong>+ 可选的(<strong>异常类型</strong> + <strong>异常标识符</strong>) + 可选的</strong>when(表达式)</strong> + <strong>块语句</strong></p><p>finally子句<strong>只能由一个</strong>finally块组成，finally块的格式为<strong>finally</strong> + <strong>块语句</strong>。finally永远都会执行，主要用于申请系统资源（打开一些系统连接时，finally用于释放资源/关闭连接，防止出错）或者用于写log日志</p><p>以<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32.parse?view=net-6.0#system-int32-parse(system-string)">int32.Parse(String)方法</a>为例来演示捕获异常的操作</p><p>查询发现有三种异常</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Parse</span> (<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.argumentnullexception?view=net-6.0">ArgumentNullException</a>：s为null</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.formatexception?view=net-6.0">FormatException</a>：s的格式不正确</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.overflowexception?view=net-6.0">OverflowException</a>：s表示一个小于MinValue或大于MaxValue的数字</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calcular c = <span class="keyword">new</span> Calcular();</span><br><span class="line">        <span class="built_in">int</span> r = c.Add(<span class="string">&quot;100&quot;</span>, <span class="string">&quot;200&quot;</span>);</span><br><span class="line">        Console.WriteLine(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calcular</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params">String arg1,<span class="built_in">string</span> arg2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="built_in">int</span>.Parse(arg1);</span><br><span class="line">        <span class="built_in">int</span> b = <span class="built_in">int</span>.Parse(arg2);</span><br><span class="line">        <span class="built_in">int</span> result = a + b;</span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常程序如上，但是没有捕获异常的设置，当一些异常发生时，程序会崩溃。这时候，需要在出现异常时候，给用户进行提示。</p><p>第一种异常：ArgumentException</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calcular c = <span class="keyword">new</span> Calcular();</span><br><span class="line">        <span class="built_in">int</span> r = c.Add(<span class="literal">null</span>, <span class="string">&quot;200&quot;</span>);</span><br><span class="line">        Console.WriteLine(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calcular</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params">String arg1,<span class="built_in">string</span> arg2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="built_in">int</span>.Parse(arg1);</span><br><span class="line">        <span class="built_in">int</span> b = <span class="built_in">int</span>.Parse(arg2);</span><br><span class="line">        <span class="built_in">int</span> result = a + b;</span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：System.ArgumentNullException: 值不能为null</p><p>第二种异常：FormatException</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calcular c = <span class="keyword">new</span> Calcular();</span><br><span class="line">        <span class="built_in">int</span> r = c.Add(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;200&quot;</span>);</span><br><span class="line">        Console.WriteLine(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calcular</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params">String arg1,<span class="built_in">string</span> arg2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="built_in">int</span>.Parse(arg1);</span><br><span class="line">        <span class="built_in">int</span> b = <span class="built_in">int</span>.Parse(arg2);</span><br><span class="line">        <span class="built_in">int</span> result = a + b;</span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：System.FormatException: 输入字符串的格式不正确</p><p>第三种异常：OverflowException</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calcular c = <span class="keyword">new</span> Calcular();</span><br><span class="line">        <span class="built_in">int</span> r = c.Add(<span class="string">&quot;999999999999999&quot;</span>, <span class="string">&quot;200&quot;</span>);</span><br><span class="line">        Console.WriteLine(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calcular</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params">String arg1,<span class="built_in">string</span> arg2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="built_in">int</span>.Parse(arg1);</span><br><span class="line">        <span class="built_in">int</span> b = <span class="built_in">int</span>.Parse(arg2);</span><br><span class="line">        <span class="built_in">int</span> result = a + b;</span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：System.OverflowException: 值对于 Int32 太大或太小</p><p>针对这几个异常，我们进行更改</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calcular c = <span class="keyword">new</span> Calcular();</span><br><span class="line">        <span class="built_in">int</span> r = c.Add(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;200&quot;</span>);</span><br><span class="line">        Console.WriteLine(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calcular</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params">String arg1, <span class="built_in">string</span> arg2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">0</span>;<span class="comment">//需要ab在外面的作用域</span></span><br><span class="line">        <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="built_in">int</span>.Parse(arg1);</span><br><span class="line">            b = <span class="built_in">int</span>.Parse(arg2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArgumentNullException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Argument(s) are not number&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FormatException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Your argument(s) have error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OverflowException) </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = a + b;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为Your argument(s) have error和0</p><p>使用异常标识符后，并加上finally语句用于写log，来判断最后得到r的值不是默认值0，而是我们计算的值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calcular c = <span class="keyword">new</span> Calcular();</span><br><span class="line">        <span class="built_in">int</span> r = c.Add(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        Console.WriteLine(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calcular</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params">String arg1, <span class="built_in">string</span> arg2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">0</span>;<span class="comment">//需要ab在外面的作用域</span></span><br><span class="line">        <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bool</span> hasError = <span class="literal">false</span>;<span class="comment">//haserror作为标记</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="built_in">int</span>.Parse(arg1);</span><br><span class="line">            b = <span class="built_in">int</span>.Parse(arg2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArgumentNullException ane)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(ane.Message);</span><br><span class="line">            hasError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FormatException fe)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(fe.Message);</span><br><span class="line">            hasError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OverflowException oe) </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(oe.Message);</span><br><span class="line">            hasError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasError)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Execution has error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = a + b;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出Done和0，我们可以知道，此时输出的0是程序成功执行后所得的结果，而不是原来的默认值；若int r = c.Add(“0”, “0”);改为int r = c.Add(“abc”, “0”);，输出 <code>输入字符串的格式不正确</code>、<code>Execution has error</code>、<code>0</code>，此时的0为默认值<br>这里将所有的异常都处理了，那我们更换需求：其他异常处理了，但是OverflowException不处理，而是让参数被调用的地方进行处理（此处是c.add）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calcular c = <span class="keyword">new</span> Calcular();</span><br><span class="line">        <span class="built_in">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = c.Add(<span class="string">&quot;9999999999999999&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(OverflowException oe)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(oe.Message);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calcular</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params">String arg1, <span class="built_in">string</span> arg2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">0</span>;<span class="comment">//需要ab在外面的作用域</span></span><br><span class="line">        <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bool</span> hasError = <span class="literal">false</span>;<span class="comment">//haserror作为标记</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="built_in">int</span>.Parse(arg1);</span><br><span class="line">            b = <span class="built_in">int</span>.Parse(arg2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArgumentNullException ane)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(ane.Message);</span><br><span class="line">            hasError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FormatException fe)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(fe.Message);</span><br><span class="line">            hasError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OverflowException oe) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> oe;<span class="comment">//这里我们不进行处理，而是交由调用地方进行处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasError)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Execution has error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = a + b;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 <code>Done</code>、<code>值对于 Int32 太大或太小</code>、<code>0</code>，并且其他的异常也可以被捕获</p><h5 id="迭代-循环-语句-跳转语句">迭代(循环)语句+跳转语句</h5><p>常与跳转语句一起使用，所以一起讲</p><h6 id="简单概念">简单概念</h6><p>迭代语句分为While语句、do语句、for语句和foreach语句</p><blockquote><p>用于重复执行嵌入语句，这种嵌入语句叫循环体</p></blockquote><p>跳转语句分为break语句、continue语句、goto语句、return语句、throw语句</p><blockquote><p>无条件地转移控制</p></blockquote><p>break语句可用于将控制转移到<strong>语句的结束点</strong>，而continue语句用于将控制转移到<strong>嵌入式语句的结束点</strong></p><p>goto语句将控制转移到由<strong>标签标记的语句</strong>，return语句将控制权返回给出现该语句的函数的<strong>当前调用方</strong></p><p>throw语句将引发一个异常，该异常的值为通过计算语句中表达式产生的值。特别地，catch块中可不带表达式</p><h6 id="while循环">while循环</h6><blockquote><p>用于有条件地执行<strong>零次或多次</strong>嵌入语句</p><p>格式为<strong>while</strong> + <strong>(布尔表达式)</strong> + <strong>嵌入式语句</strong></p></blockquote><p>当布尔表达式输出false时，程序中循环体运行零次</p><p>示例：要求先后输入两个数，使得最终值为100</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bool</span> canContinue = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (canContinue)<span class="comment">//使用canConinue作为程序运行的标识</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Please input first number&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> str1 = Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> x = <span class="built_in">int</span>.Parse(str1);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Please input second number&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> str2 = Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> y = <span class="built_in">int</span>.Parse(str2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">if</span>(sum  == <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        score++;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Correct!&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>,x,y,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Error!&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, x, y, sum);</span><br><span class="line">        canContinue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Your score is &#123;0&#125;&quot;</span>,score);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Game Over&quot;</span>);</span><br></pre></td></tr></table></figure><h6 id="do循环">do循环</h6><blockquote><p>有条件地执行<strong>一次或多次</strong>嵌入式语句</p><p>格式：<strong>do</strong> + <strong>嵌入式语句</strong> + <strong>while</strong> + <strong>(布尔表达式)</strong> + <strong>;</strong></p></blockquote><p>当布尔表达式输出false时，嵌入式语句已经先执行一次，所以do语句最少运行一次</p><p>针对上面的示例，发现是更合适do语句的，进行更改</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Please input first number&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> str1 = Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> x = <span class="built_in">int</span>.Parse(str1);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Please input second number&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> str2 = Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> y = <span class="built_in">int</span>.Parse(str2);</span><br><span class="line"></span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        score++;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Correct!&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, x, y, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Error!&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, x, y, sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span>(sum == <span class="number">100</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Your score is &#123;0&#125;&quot;</span>, score);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Game Over&quot;</span>);</span><br></pre></td></tr></table></figure><p>发现该程序，输入值如果无法通过Prase进行转换，则会报错,那么此时得使用try-catch语句，而如果出错后，则需要放弃本次循环，而进行下一次循环。那么我们需要什么跳转语句？</p><h6 id="continue跳转">continue跳转</h6><blockquote><p>直接封闭最近的 <code>while</code>、<code>do</code> 、<code>for </code>或 <code>foreach</code>语句的一次新迭代</p></blockquote><p>注意是封闭嵌入式语句的结束点，常见的是退出一次某块语句</p><p>只是放弃本次循环，continue循环是比较合理的</p><p>更改后的代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Please input first number&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> str1 = Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">int</span>.Parse(str1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;First number isn&#x27;t right! Restart.&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Please input second number&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> str2 = Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="built_in">int</span>.Parse(str2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Second number isn&#x27;t right! Restart.&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;<span class="comment">//能够跳出本次循环并继续运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        score++;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Correct!&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, x, y, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Error!&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, x, y, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (sum == <span class="number">100</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Your score is &#123;0&#125;&quot;</span>, score);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Game Over&quot;</span>);</span><br></pre></td></tr></table></figure><p>不想通过错误值来停止程序，而是输入end来停止程序，那需要什么跳转方法？</p><h6 id="break跳转">break跳转</h6><blockquote><p>退出最近的包含 <code>switch</code> 、 <code>while</code> <code>do</code> 、 <code>for</code> 或 <code>foreach</code> 语句</p></blockquote><p>添加需求：检查该次输入是否为字符串end，如果为end则停止程序</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Please input first number&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> str1 = Console.ReadLine();</span><br><span class="line">    <span class="keyword">if</span>(str1 == <span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">int</span>.Parse(str1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;First number isn&#x27;t right! Restart.&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Please input second number&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> str2 = Console.ReadLine();</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="built_in">int</span>.Parse(str2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Second number isn&#x27;t right! Restart.&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        score++;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Correct!&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, x, y, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Error!&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, x, y, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (sum == <span class="number">100</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Your score is &#123;0&#125;&quot;</span>, score);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Game Over&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：continue和break在多重循环内部，只会影响当前外部一层的循环。想象他们是住在白菜里的虫子，他首先咬的是内部第一层。</p></blockquote><h6 id="for循环">for循环</h6><blockquote><p>计算一系列的初始化表达式，当条件为 true 时，重复执行嵌入语句并计算迭代表达式的序列</p><p>格式：<strong>for(局部变量声明 + 表达式列表;布尔表达式;表达式列表)</strong> + <strong>嵌入式语句</strong></p></blockquote><p>该格式对应着<strong>for(变量初始条件，循环的运行条件，循环变量的变化)</strong> + 嵌入式语句，常见代码为</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//输入if，按两下tab键</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//i变成length时，退出循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>for循环更容易实现计数循环</p></blockquote><p>可以从下面例程看出：实现打印10行Hello，World</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> counter = <span class="number">0</span>;  <span class="comment">//循环变量声明</span></span><br><span class="line"><span class="keyword">while</span> (counter &lt; <span class="number">10</span>)<span class="comment">//循环的运行条件</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    counter++; <span class="comment">//循环变量的变化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span>; <span class="comment">//循环变量声明</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    counter++;<span class="comment">//循环变量的变化</span></span><br><span class="line">&#125; <span class="keyword">while</span> (counter &lt; <span class="number">10</span>);  <span class="comment">//循环的运行条件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">//循环变量声明、循环的运行条件、循环变量的变化是一起的</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小试牛刀：实现九九乘法表</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;x&#123;1&#125;=&#123;2&#125;\t&quot;</span>,i,j,i*j);<span class="comment">//\t为制表位，用于对齐</span></span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();<span class="comment">//什么都不写就是回车符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="foreach（遍历）循环">foreach（遍历）循环</h6><blockquote><p>用于遍历集合：枚举集合中的元素，并对集合中的每个元素执行嵌入语句</p><p>格式：<strong>foreach(本地变量类型 标识符 in 表达式)</strong> + <strong>嵌入式语句</strong></p></blockquote><p>示例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> intArray)<span class="comment">//一般为了防止出错，本地变量类型选择var，当然此处可填入int</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(intArray.GetType().FullName);<span class="comment">//输出system.int32</span></span><br><span class="line">Console.WriteLine(intArray <span class="keyword">is</span> Array);<span class="comment">//输出true</span></span><br></pre></td></tr></table></figure><p>相关知识：</p><blockquote><p>那什么样的集合可以被遍历？</p></blockquote><p>进入Array的定义，Array类后面接的是接口（I指的是interface），其中带IEnumerable类就是支持遍历的</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203110910975.png" alt="image-20220311090943798"></p><p>查看IEnumerable类的细节</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203110914998.png" alt="image-20220311091403882"></p><p>转向其定义，IEnumerable类功能是获得该类的迭代器对象</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203110915984.png" alt="image-20220311091509886"></p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/iterators">迭代器</a>是什么？</p></blockquote><p>迭代器是遍历容器的对象，尤其是列表。可以用于对集合中的每个项执行操作、枚举自定义集合等等</p><p><a href="http://xn--foreach-sr4k60a14cp28hfqau12s175cjff.NET">我们所讲的foreach依赖于.NET</a> Core库中定义的2个泛型接口，才能生成循环访问集合所需的代码：<code>IEnumerable&lt;T&gt;</code> 和 <code>IEnumerator&lt;T&gt;</code>。这2种接口还具备相应的非泛型接口：<code>IEnumerable</code> 和 <code>IEnumerator</code>。</p><p>目前还没讲接口，但是可以对照手机充电接口，接口的核心是协议，支持协议就能实现快充，按照某些协议才能相互连接，至于如何实现我们不关心，我们只需要知道充电时候需要找到对应充电头+充电线。有了接口，大家协作就成了可能，想想手机厂商可不会生产充电器（代工居多），那么他们怎么知道充电器能支持自家手机呢？还是协议！因为行业规定了协议，大家就能实现互通</p><p>进入迭代器的定义</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203111010600.png" alt="image-20220311101049230"></p><p>分析其代码</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203111016241.png" alt="image-20220311101533419"></p><p>对上述内容进行验证</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">//将intArray的迭代器赋给enumerator</span></span><br><span class="line">IEnumerator enumberator = intArray.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span> (enumberator.MoveNext())<span class="comment">//MoveNext方法判断当前是否到达集合末尾</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(enumberator.Current);<span class="comment">//输出当前元素，输出值为1 2 3 4 5 6</span></span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(enumberator.MoveNext());<span class="comment">//输出false，说明已经到集合的末尾</span></span><br><span class="line">enumberator.Reset();<span class="comment">//重新回到集合的开端</span></span><br><span class="line">Console.WriteLine(enumberator.MoveNext());<span class="comment">//输出true，其实已经到了集合的开端</span></span><br></pre></td></tr></table></figure><p>验证成功，发现使用这三个方法就能实现使用迭代器直接遍历集合</p><h6 id="return跳转">return跳转</h6><blockquote><p>将控制权返回给出现该语句的函数的当前调用方</p><p>格式：<strong>return</strong> + <strong>表达式</strong>;</p></blockquote><p><strong>尽早return原则：</strong></p><p>对比两段代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Greeting(<span class="string">&quot;myfriend!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Greeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(name))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello,&#123;0&#125;&quot;</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Greeting(<span class="string">&quot;myfriend!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Greeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(name))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello,&#123;0&#125;&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两类输出值一样，但是第二段的好处是可读性更强，避免了这个方法头重脚轻，避免了if语句内包含太多参数或者语句，假如if后的块语句是100行代码将使得读代码成为困难。</p><h6 id="goto跳转">goto跳转</h6><blockquote><p>将控制转移到由标签标记的语句（标签语句、switch，catch语句中有一些讲解）</p><p>格式：<strong>goto 标识符;</strong>               //标签语句的标签</p><pre><code>**goto case 常数表达式;**       //switch的某个case**goto default;**             //switch语句中default</code></pre></blockquote><p>不是主流的语句，不进行讲解。具体可参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/statements#the-goto-statement">goto语句</a></p><h6 id="throw跳转">throw跳转</h6><blockquote><p>用于引发异常</p><p>格式：<strong>throw</strong> + <strong>可选的表达式;</strong></p></blockquote><p>在try语句中已经讲解，后面可以选择性跟异常类型的变量</p><h5 id="checked语句和unchecked语句">checked语句和unchecked语句</h5><blockquote><p>控制整型算术运算和转换的溢出检查上下文(判断是否发生溢出)</p><p>格式：<strong>checked/unchecked</strong> + <strong>块</strong></p></blockquote><p>前面checked关键字已经讲解，这里不赘述</p><h5 id="低频语句">低频语句</h5><blockquote><p>空语句:不执行任何操作,格式为;</p><p>标签语句</p></blockquote><h5 id="高阶语句">高阶语句</h5><blockquote><p>using语句：与接口有关</p><p>yield语句：与集合有关</p><p>lock语句：与多线程有关</p></blockquote><hr><h1>第八章 类的成员：字段、属性、索引器、常量</h1><p>翻文档，我们要查某个类的时候，我们是需要找到类的成员！我们之前是从基本的方法和运算符入手，进行语言的入门，让大家实现简单的算法，甚至可以去编写一定的demo，完成简单的代码逻辑，并且去实现其他功能，比如WPF，ASP等</p><p>C#所有可以在类、结构或记录中声明有<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/members">哪些成员？</a><strong>字段</strong>、<strong>常量</strong>、<strong>属性</strong>、<strong>方法</strong>、事件、<strong>运算符</strong>、<strong>索引器</strong>、<strong>构造函数</strong>、嵌套类型、析构函数。其中方法、运算符、构造函数已经学习。还是剩下字段、属性、索引器、常量和后续的事件、嵌套类型、析构函数</p><p>这四种成员都是用于表达数据，所以单独列出来</p><h2 id="一、字段">一、字段</h2><h3 id="字段的定义">字段的定义</h3><blockquote><p>字段(field)是在类或结构中直接声明的任意类型的<strong>变量</strong></p></blockquote><p>字段field是变量，代表存储数据的某个空间。需要注意的是，字段是为了一个对象或者类型存储数据，而局部变量是为某个方法暂时存储数据</p><p>字段是变量，又是类型的成员，旧称“成员变量”</p><h3 id="字段的类型">字段的类型</h3><blockquote><p>与对象关联的字段称为“实例字段”，与类型关联的字段称为“静态字段”，用static修饰</p></blockquote><p>举例：</p><p>实例字段</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu1.Age = <span class="number">40</span>;</span><br><span class="line">        stu1.Score = <span class="number">90</span>；<span class="comment">//表示了当前stu1对象的当前状态</span></span><br><span class="line"></span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu2.Age = <span class="number">24</span>;</span><br><span class="line">        stu2.Score = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;<span class="comment">//表示了对象的当前状态，比如年龄状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态字段</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;Student&gt; stuList = <span class="keyword">new</span> List&lt;Student&gt; &#123; &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) <span class="comment">//创建100个 Student 对象</span></span><br><span class="line">            &#123;</span><br><span class="line">                Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">                stu.Age = <span class="number">24</span>;</span><br><span class="line">                stu.Score = i;</span><br><span class="line">                stuList.Add(stu);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> totalAge = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> totalScore = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> stu <span class="keyword">in</span> stuList)</span><br><span class="line">            &#123;</span><br><span class="line">                totalAge += stu.Age;</span><br><span class="line">                totalScore += stu.Score;</span><br><span class="line">            &#125;</span><br><span class="line">            Student.AverageAge = totalAge / Student.Amount;</span><br><span class="line">            Student.AverageScore = totalScore / Student.Amount;</span><br><span class="line">            Student.ReportAmount();</span><br><span class="line">            Student.ReportAverageAge();</span><br><span class="line">            Student.ReportAverageScore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age;   <span class="comment">//此类对象的年龄状态</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Score; <span class="comment">//此类对象的分数状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> AverageAge;<span class="comment">//该类的平均年龄</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> AverageScore;<span class="comment">//该类的平均分数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Amount;<span class="comment">//该类实例化的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span>() <span class="comment">//类的实例构造函数，使得每次创建实例时，个数加1</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Student.Amount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReportAmount</span>()<span class="comment">//输出当前的实例化个数</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(Student.Amount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReportAverageAge</span>()<span class="comment">//输出隶属于该类的平均年龄</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(Student.AverageAge);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReportAverageScore</span>()<span class="comment">//输出隶属于该类的平均分数</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(Student.AverageScore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面程序很容易看出，实例字段表示的是对象（类实例后）的状态，静态字段表示的是该类的状态，理解起来就像班级某学生的学习状态（学习刻苦，态度认真）和整个班的学生状态（尖子班，学习氛围浓郁）</p><p>扩展：类有实例构造器，也有静态构造器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Student</span>() <span class="comment">//类的静态构造函数</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Student.Amount = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段的声明">字段的声明</h3><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/classes#fields">C#语言规范</a></p><p>字段的名字必须是一个名词（代表状态），而不是动词或者动词短语（代表行为）</p><p>出现的位置是在类体内方法（函数）外</p><blockquote><p>格式：可选的<strong>特性</strong> + 可选的若干个<strong>字段修饰符</strong> + 数据类型 + 变量声明器;</p></blockquote><p>字段修饰符有new、public、protected、internal、private、static、readonly、volatile、不安全字段修饰符。必须选择有效的组合，常用的组合很固定</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">int</span> ID;<span class="comment">//每个学生的学号无法更改，则设置成readonly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> YearOfStudy = <span class="number">4</span>;<span class="comment">//本科生的学习年限都设置为4年</span></span><br></pre></td></tr></table></figure><h3 id="字段的初始值">字段的初始值</h3><p>变量声明器是标识符 + 可选的（ = 变量初始化器）;</p><blockquote><p>实例字段初始化的时刻：对象创建时；静态字段初始化的时刻：类型被加载load时</p></blockquote><p>变量声明中赋初始值，等价于构造函数中赋初始值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age1 = <span class="number">10</span>;<span class="comment">//虽然两种声明方法完全等价，但是还是更推荐第一种，更直观</span></span><br><span class="line">                     <span class="comment">//而且构造函数更改对其不影响</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age2;<span class="comment">//未显式声明初始值，字段会获得默认值（字段永远不会未被初始化）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.Age2 = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、属性">二、属性</h2><h3 id="属性的定义">属性的定义</h3><blockquote><p>属性（property）是一种用于访问对象或类型的特征的成员（特征反映出状态）</p></blockquote><p>属性是字段的自然扩展（由字段发展而来）</p><ul><li>命名上看，field更偏向于实例对象在内存的布局，property更偏向于反映现实世界对象的特征</li><li>属性提供了一种机制，用于将操作与对象的属性的读取和写入操作相关联，比字段是更优越的<ul><li>对外：属性对外暴露数据，数据可以是存储在字段里的，也可以是<strong>动态计算</strong>出来的</li><li>对内：属性可以保护字段不被非法值”污染“</li></ul></li></ul><blockquote><p>属性是由<strong>get/set方法对</strong>进化而来的</p></blockquote><p>示例：按照下面方法，发现对于非法值的污染，没法直接地检查出来</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu1.Age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu2.Age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        Student stu3 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu3.Age = <span class="number">200</span>; <span class="comment">//200对于年龄来说，是非法值，并且从平均值80也无法发现这类污染</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> avgAge = (stu1.Age + stu2.Age + stu3.Age) / <span class="number">3</span>;</span><br><span class="line">        Console.WriteLine(avgAge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对程序进行更改，通过使用setAge/getAge方法封装对字段的读取和写入（C++和Java中使用，它们是没有属性的概念）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">            stu1.SetAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student();</span><br><span class="line">            stu2.SetAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student();</span><br><span class="line">            stu3.SetAge(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> avgAge = (stu1.GetAge() + stu2.GetAge() + stu3.GetAge());</span><br><span class="line">            Console.WriteLine(avgAge);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;<span class="comment">//私有的字段，作为后面方法的内部变量，改成小写</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetAge</span>()<span class="comment">//编写setAge/getAge方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAge</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">value</span> &lt;= <span class="number">120</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Age value has error.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述方法有点冗长，所以微软发明出属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">            stu1.Age = <span class="number">20</span>;<span class="comment">//被赋值时不再需要setAge，而是直接赋值，后台调用set方法</span></span><br><span class="line"></span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student();</span><br><span class="line">            stu2.Age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student();</span><br><span class="line">            stu3.Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> avgAge = (stu1.Age + stu2.Age + stu3.Age)/<span class="number">3</span>; <span class="comment">//后台调用get方法</span></span><br><span class="line">            Console.WriteLine(avgAge);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;<span class="comment">//私有的字段，作为属性的内部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age<span class="comment">//公有的属性，下面的块语句也叫属性的访问器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> <span class="comment">//set范围内隐式包含value作为上下文关键字,代表用户传入的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">value</span> &lt;= <span class="number">120</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.age = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Age value has error.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察代码，可以看到其实get和set方法是对之前getAge和setAge方法的进一步封装（改进），该<strong>语法糖</strong>极大地提高了代码的可读性和便利性（语法糖封装的细节可以查看视频）。这里推荐<a href="https://github.com/icsharpcode/ILSpy/releases">ILspy</a>、<a href="https://www.jetbrains.com/decompiler/">dotpeek</a>、<a href="https://github.com/dnSpy/dnSpy/releases">dnspy</a></p><h3 id="属性的声明">属性的声明</h3><h4 id="1-属性的完整声明">1.属性的完整声明</h4><blockquote><p>格式：可选的<strong>特性</strong> + 可选的<strong>属性修饰符</strong> + 数据类型 + 属性名 + {访问器}</p></blockquote><p>属性修饰符有new、public、protected、internal、private、static、virtual、sealed、override、abstract、extern和不安全的属性修饰符。当然，常见的还是public和public static</p><p>访问器是get和set访问器，是可以单独有get（只读）和set（只写），但是只写属性基本不用（属性的主要目的就是通过对外暴露数据而表示对象/类型的状态）。但是对于set方法可以添加private特性，这样可以在类的内部还是能够修改，与删除set方法的情况要进行区分</p><blockquote><p>键入 <code>propfull</code>＋<code>两下tab键</code>，可以直接键入实例属性声明的完整模板，填写完成后按回车</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> myVar;<span class="comment">//私有字段，作为属性内部变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MyProperty<span class="comment">//公有属性</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> myVar; &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; myVar = <span class="keyword">value</span>; &#125;<span class="comment">//get和set访问器，内部代码按需更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果需要静态属性呢？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> myVar;<span class="comment">//加入static</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> MyProperty<span class="comment">//加入static</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> myVar; &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; myVar = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-属性的简略声明">2.属性的简略声明</h4><blockquote><p>键入 <code>prop</code>＋<code>两下tab键</code>，可以键入简略模板</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MyProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><p>这里的简略声明只是为了属性的读取和写入，没有安全保护措施，但是精简</p><h4 id="3-属性的快速声明（重构）">3.属性的快速声明（重构）</h4><p>假设开始时只设置了字段，但是后续想将它重构为属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br></pre></td></tr></table></figure><p>首先改成</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> age;</span><br></pre></td></tr></table></figure><p>然后光标悬停在变量age上，选择重构</p><p>这里提供两种方法：</p><ol><li><p>进入标题栏，点击 <code>编辑</code>——<code>重构</code>——<code>封装字段</code>（或者直接使用快捷键 <code>Ctrl+R,E</code>）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203121701919.png" alt="image-20220312170159435"></p></li><li><p>右键选择 <code>快速操作和重构</code></p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203121704776.png" alt="image-20220312170418502"></p><p>然后就可以选择 <code>封装字段</code>，并且使用属性</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203121704384.png" alt="image-20220312170449073"></p></li></ol><h3 id="理解动态计算值的属性">理解动态计算值的属性</h3><blockquote><p>比字段优越的地方是，能够实时地把值计算出来</p></blockquote><p>在属性内部的get访问器中，完成值的计算</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        stu.Age = <span class="number">15</span>;</span><br><span class="line">        Console.WriteLine(stu.CanWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; age = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> CanWork <span class="comment">//学生是否能工作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> <span class="comment">//CanWork没有封装字段，其值是实时动态计算出来的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt;= <span class="number">16</span>)<span class="comment">//使用字段</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再更换设计方法（canwork如果更经常访问）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        stu.Age = <span class="number">15</span>;</span><br><span class="line">        Console.WriteLine(stu.CanWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            age = <span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">this</span>.CalculateCanWork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canWork;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> CanWork</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> canWork; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CalculateCanWork</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt;=<span class="number">16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.canWork = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.canWork = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性与字段的关系">属性与字段的关系</h3><ol><li>一般情况下，它们都是用于表示实体（对象或者类型）的状态</li><li>属性大多数情况下是字段的包装器（wrapper）</li></ol><blockquote><p>建议：永远使用属性（而不是字段）来暴露数据，即字段永远都是private或者protected</p></blockquote><h2 id="三、索引器">三、索引器</h2><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/classes#indexers">索引器</a></p><blockquote><p>索引器indexer是一个能使对象以与数组相同的方式**（使用下标）**进行索引的成员</p></blockquote><p>根据定义，索引器常用来检索集合，拥有索引器成员一般都是集合类型，但是也是有例外，这里以字典为例</p><p>示例：输入键值可查询该同学的成绩</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Students stu = <span class="keyword">new</span> Students();</span><br><span class="line">            stu[<span class="string">&quot;Math&quot;</span>] = <span class="number">90</span>;</span><br><span class="line">            stu[<span class="string">&quot;English&quot;</span>] = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">var</span> mathScore = stu[<span class="string">&quot;Math&quot;</span>];</span><br><span class="line">            <span class="keyword">var</span> EnglishScore = stu[<span class="string">&quot;English&quot;</span>];</span><br><span class="line">            Console.WriteLine(mathScore);</span><br><span class="line">            Console.WriteLine(EnglishScore);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//索引器检索学习成绩</span></span><br><span class="line">        <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; scoreDictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;(); <span class="comment">//字典由键和值组成</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span>? <span class="keyword">this</span>[<span class="built_in">string</span> subject] <span class="comment">//输入为键值subject，输出为可空的int类型</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.scoreDictionary.ContainsKey(subject))</span><br><span class="line">                    <span class="comment">//ContainsKey方法检查是否存在该键值</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.scoreDictionary[subject];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">value</span>.HasValue == <span class="literal">false</span>) </span><br><span class="line">                    <span class="comment">//HasValue是判断该值是否有值的属性，可查看定义了解</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Score can&#x27;t be null&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//单独使用value会报错是因为private声明字典的值应该为int类型</span></span><br><span class="line">                <span class="comment">//但是public索引器声明的返回值为可空int类型</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.scoreDictionary.ContainsKey(subject)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.scoreDictionary[subject] = <span class="keyword">value</span>.Value;</span><br><span class="line">                    <span class="comment">//可空类型加上.Value才是它真正的值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.scoreDictionary.Add(subject, <span class="keyword">value</span>.Value);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，可空类型加上.Value才是它的值，是需要掌握的</p><h2 id="四、常量">四、常量</h2><h3 id="概述">概述</h3><blockquote><p>表示常量值(在编译时可计算的值)的类成员</p><p>格式:<strong>可选的特性</strong> + <strong>常量修饰符</strong> + <strong>const</strong> + <strong>数据类型</strong> + <strong>常量声明器</strong></p></blockquote><p>格式看上去和字段是很类似的，其中常量修饰符只有new、public、protected、internal、private；常量声明器为若干个声明器组成。</p><p>前面其实见过常量</p><p>示例：计算圆的面积</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">GetArea</span>(<span class="params"><span class="built_in">double</span> r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> area = Math.PI * r * r;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按F12跳转定义处</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203140929881.png" alt="image-20220314092820456"></p><blockquote><p>常量的声明实例</p></blockquote><p>示例：输出个人博客的网址</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Visen.WebsiteURL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Visen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> WebsiteURL = <span class="string">&quot;wwww.supervisen.cn&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常量隶属于类型而不是对象，即没有“实例常量”，而是用只读实例才担当</p></blockquote><p>但是使用实例实际上是变量，性能对比常量是有所下降的(常量编译时，会直接用常量值代替常量标识符)</p><h2 id="五、“只读”的应用场景">五、“只读”的应用场景</h2><blockquote><p>为了提高程序可读性和执行效率——常量</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Visen.WebsiteURL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Visen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> WebsiteURL = <span class="string">&quot;wwww.supervisen.cn&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止对象的值被更改——只读字段</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">int</span> ID;</span><br></pre></td></tr></table></figure><blockquote><p>向外暴露不允许修改的数据——只读属性（静态或非静态），功能与常量有一定重叠</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当希望设置为常量的值，其类型<strong>不能被常量声明接受</strong>时（<strong>类/自定义结构体</strong>）——静态只读字段</p></blockquote><p>类无法作为常量的值</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203140959091.png" alt="image-20220314095910994"></p><p>自定义构造器也无法运行</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203140959409.png" alt="image-20220314095953316"></p><p>静态只读字段</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203140954649.png" alt="image-20220314095435554"></p><hr><h1>第九章 方法参数</h1><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/classes#method-parameters">方法参数</a></p><p>其实就是方法的讲解</p><p>方法的组成这里不讲，里面有个形参列表，突出讲形参列表，后面几个参数在链接中并没有介绍，因为后面是参数的使用方法。这章就是把方法参数讲完</p><p>形参列表包含一个或多个以逗号分隔的参数，其中只有最后一个参数可以是参数数组</p><p>存在四种<strong>形参</strong></p><p>注意外部变量和内部参数对比，编程的时候，取名为outterXX和innerXXX</p><h2 id="传值参数">传值参数</h2><blockquote><p>值参数是使用不带修饰符声明的参数。值参数对应于一个局部变量，该局部变量从方法调用中提供的相应参数获取其初始值，相对于传入的实参“副本”</p></blockquote><p>按照参数变量是什么类型，可以进行分类</p><p>当变量是值类型时，变量就存储了一个初始值；而当变量是引用类型时，变量存储了一个地址，执行一处存储数据的控件</p><h3 id="值类型的值参数">值类型的值参数</h3><p>图示：</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203141505500.png" alt="image-20220314150545014"></p><p>注意值类型和值参数（传值参数）的定义，值参数是<strong>值类型</strong>的传值参数</p><p>示例：值参数不改变其参数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="built_in">int</span> y = <span class="number">12</span>;</span><br><span class="line">        stu.AddOne(y); <span class="comment">//输出13</span></span><br><span class="line">        Console.WriteLine(y); <span class="comment">//输出12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddOne</span>(<span class="params"><span class="built_in">int</span> x</span>)<span class="comment">//x就是值参数，值类型的传值参数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        x = x + <span class="number">1</span>;</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用类型的值参数">引用类型的值参数</h3><h4 id="1-方法体内新创建对象并引用">1.方法体内新创建对象并引用</h4><blockquote><p>该情况下，只是将初始值引用的对象改变了，但是不影响原来的引用。方法参数存储的地址和外部变量指向不同的对象（地址）</p></blockquote><p>图解：指向的是调用对象的地址</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203141528365.png" alt="image-20220314152827060"></p><p>示例：通过对象的Name属性判断变量引用的实例有没有改变</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student() &#123; Name =<span class="string">&quot;Tim&quot;</span>&#125;;</span><br><span class="line">        SomeMethod(stu);<span class="comment">//输出Tom</span></span><br><span class="line">        Console.WriteLine(stu.Name);<span class="comment">//输出Tim</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params">Student stu</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stu = <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Tom&quot;</span>&#125;;<span class="comment">//参数传入后，方法内部赋了新对象（Tom）</span></span><br><span class="line">        Console.WriteLine(stu.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如都取为Tim，就无法判断了，那有什么方法直接获取地址</p><blockquote><p>GetHashCode继承自Object，每个对象都有这个方法，通过哈希值判断变量是否一样</p></blockquote><p>更改后：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student() &#123; Name =<span class="string">&quot;Tim&quot;</span>&#125;;</span><br><span class="line">        SomeMethod(stu);<span class="comment">//输出12289376,Tim</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, stu.GetHashCode(), stu.Name);<span class="comment">//输出46104728,Tom</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params">Student stu</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stu = <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Tom&quot;</span>&#125;;<span class="comment">//参数传入后，方法内部赋了新对象（Tom）</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>,stu.GetHashCode(),stu.Name); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重构的小技巧：更改变量名后，点击左边小灯泡（快速操作/alt+.），把所有的该块语句中改变</p></blockquote><h4 id="2-方法体内不创建新对象只是操作旧对象">2.方法体内不创建新对象只是操作旧对象</h4><blockquote><p>这里方法引用的是旧对象，方法参数存储的地址和外部变量指向同一个对象（地址）</p></blockquote><p>图解：通过传入参数，修改原有参数（绿色变成黄色代表值已经改变）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203141545771.png" alt="image-20220314154520449"></p><p>示例：更新对象，而不是创建新对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student stu= <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Tim&quot;</span>&#125;;</span><br><span class="line">        UpdateObject(stu);<span class="comment">//输出HashCode = 46104728,Name = Tom</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;HashCode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, stu.GetHashCode(), stu.Name);<span class="comment">//输出HashCode = 46104728,Name = Tom</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UpdateObject</span>(<span class="params">Student stu</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stu.Name = <span class="string">&quot;Tom&quot;</span>; <span class="comment">//强耦合性的副作用，会影响原来的变量</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;HashCode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>,stu.GetHashCode(),stu.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用参数">引用参数</h2><blockquote><p>引用参数是使用修饰符 <code>ref</code>声明的参数。 与值参数不同，引用参数<strong>不会创建新的存储位置</strong>。相反，引用参数表示作为方法调用中的自变量提供的变量所在的存储位置（引用参数只是使用变量的地址）</p></blockquote><blockquote><p>在将变量作为引用参数传递之前，必须对其进行明确赋值</p></blockquote><p>按照参数变量是什么类型，可以进行分类</p><h3 id="值类型的引用参数">值类型的引用参数</h3><blockquote><p>使用变量的地址，显式地表示变量和参数的耦合性（用于提醒编程人员）</p></blockquote><p>图解：</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203141625837.png" alt="image-20220314162515539"></p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> y = <span class="number">1</span>;</span><br><span class="line">    IWantSideEffect(<span class="keyword">ref</span> y);<span class="comment">//输出101，方法体内的值</span></span><br><span class="line">    Console.WriteLine(y);<span class="comment">//输出101，目前参数的值，对比后发现了两处的强耦合性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IWantSideEffect</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x</span>)<span class="comment">//ref显式地表示自己接受副作用</span></span></span><br><span class="line">&#123;</span><br><span class="line">    x += <span class="number">100</span>;</span><br><span class="line">    Console.WriteLine(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用类型的引用参数">引用类型的引用参数</h3><blockquote><p>和值类型的类似，引用参数突出的还是强耦合性的副作用</p></blockquote><h4 id="1-方法体内创建新对象并引用">1.方法体内创建新对象并引用</h4><p>图解：方法体内更改的是<strong>输入的引用类型变量</strong>的对象</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203141634760.png" alt="image-20220314163405438"></p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student outterstu = <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Tim&quot;</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hashcode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, outterstu.GetHashCode(), outterstu.Name);<span class="comment">//Hashcode = 46104728,Name = Tim</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-----------------------&quot;</span>);<span class="comment">//分割线</span></span><br><span class="line">        IWantSideEffect(<span class="keyword">ref</span> outterstu);<span class="comment">//输出Hashcode = 12289376,Name = Tom</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hashcode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, outterstu.GetHashCode(), outterstu.Name);<span class="comment">//输出Hashcode = 12289376,Name = Tom</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IWantSideEffect</span>(<span class="params"><span class="keyword">ref</span> Student stu</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stu = <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Tom&quot;</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hashcode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, stu.GetHashCode(), stu.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-方法体内不创建新对象只是操作旧对象-2">2.方法体内不创建新对象只是操作旧对象</h4><p>图解：</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203141646835.png" alt="image-20220314164657465"></p><p>示例：只改变引用的对象，而不改变地址</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student outterstu = <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Tim&quot;</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hashcode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, outterstu.GetHashCode(), outterstu.Name);<span class="comment">//输出Hashcode = 46104728,Name = Tim</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-----------------------&quot;</span>);<span class="comment">//分割线</span></span><br><span class="line">        SomeSideEffect(<span class="keyword">ref</span> outterstu);<span class="comment">//输出Hashcode = 46104728,Name = Tom</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hashcode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, outterstu.GetHashCode(), outterstu.Name);<span class="comment">//输出Hashcode = 46104728,Name = Tom</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SomeSideEffect</span>(<span class="params"><span class="keyword">ref</span> Student stu</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stu.Name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hashcode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, stu.GetHashCode(), stu.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与值参数做对比，只需要把ref去掉，发现效果是一样的，但是内存机理是不同的</p></blockquote><p>值参数是创建了变量的副本，变量outterstu和参数stu所在的内存地址不同，但是内部储存的地址是一样的</p><p>但是引用参数不同，变量outterstu和参数stu所指向的内存地址是一样的，那处地址的内存存储的地址是同一个对象的地址</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student outterstu = <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Tim&quot;</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hashcode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, outterstu.GetHashCode(), outterstu.Name);<span class="comment">//输出Hashcode = 46104728,Name = Tim</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;-----------------------&quot;</span>);<span class="comment">//分割线</span></span><br><span class="line">        SomeSideEffect(outterstu);<span class="comment">//输出Hashcode = 46104728,Name = Tom</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hashcode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, outterstu.GetHashCode(), outterstu.Name);<span class="comment">//输出Hashcode = 46104728,Name = Tom</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SomeSideEffect</span>(<span class="params">Student stu</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stu.Name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hashcode = &#123;0&#125;,Name = &#123;1&#125;&quot;</span>, stu.GetHashCode(), stu.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出参数">输出参数</h2><blockquote><p>输出参数是使用修饰符 <code>out</code>声明的参数。与引用参数类似，output参数不会创建新的存储位置。相反，output参数表示作为方法调用中的自变量提供的变量所在的存储位置</p><p>out的意义就是显式表示通过参数向外输出值（ref是为了改变，out是为了输出）</p></blockquote><ol><li>在将变量作为output参数传递之前，不需要明确赋值。但在将变量作为output参数传递的调用之后，该变量被视为明确赋值</li><li>方法返回之前，必须为方法的每个输出参数进行明确赋值(<strong>方法体内需要有明确赋值</strong>)</li><li>输出参数并不创建变量的副本</li></ol><h3 id="值类型的输出参数">值类型的输出参数</h3><blockquote><p>输出参数在方法体内被更改，并且赋值后，变量也进行了更改</p></blockquote><p>图解：</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203141855070.png" alt="image-20220314185548719"></p><p>示例：之前有讲int的parse方法是将数字的字符串表示形式转换为它的等效32位有符号整数，这里使用double的[tryparse方法](<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.double.tryparse?view=net-7.0#system-double-tryparse(system-readonlyspan((system-char)-system-globalization-numberstyles-system-iformatprovider-system-double@">https://docs.microsoft.com/zh-cn/dotnet/api/system.double.tryparse?view=net-7.0#system-double-tryparse(system-readonlyspan((system-char)-system-globalization-numberstyles-system-iformatprovider-system-double@</a>):将数字的字符串表示形式转换为它的等效双精度浮点数，并且返回判断是否转换成功的布尔值</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203142118836.png" alt="image-20220314211848528"></p><p>该方法是有输出参数的，输出值为bool类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;Please input first number&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> arg1 = Console.ReadLine();</span><br><span class="line"><span class="built_in">double</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bool</span> b1 = <span class="built_in">double</span>.TryParse(arg1, <span class="keyword">out</span> x);</span><br><span class="line"><span class="keyword">if</span> (b1 == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Input,error!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Please input second number&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> arg2 = Console.ReadLine();</span><br><span class="line"><span class="built_in">double</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bool</span> b2 = <span class="built_in">double</span>.TryParse(arg2, <span class="keyword">out</span> y);</span><br><span class="line"><span class="keyword">if</span> (b2 == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Input,error!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">double</span> z = x + y;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure><blockquote><p>已经学会调用的方法，下面讲解输出参数如何声明这类方法</p></blockquote><p>写一个类似tryparse方法的自定义方法，发现报错，原因是<strong>输出参数在方法体内必须赋值</strong></p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203142125488.png" alt="image-20220314212559175"></p><p>进行更改在异常发生时，将result在catch的块语句中赋值</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203142128097.png" alt="image-20220314212801800"></p><p>最终代码：模拟tryparse的DoubleParser方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> x = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">bool</span> b = DoubleParser.TryParse(<span class="string">&quot;154&quot;</span>, <span class="keyword">out</span> x);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">DoubleParser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryParse</span>(<span class="params"><span class="built_in">string</span> input, <span class="keyword">out</span> <span class="built_in">double</span> result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = Double.Parse(input);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用类型的输出参数">引用类型的输出参数</h3><blockquote><p>输出参数更改后，变量和输出参数指向同一个地址，那个地址都储存着同一个对象</p></blockquote><p>图解：</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203142133992.png" alt="image-20220314213340553"></p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student stu = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">bool</span> b = StudentFactory.Create(<span class="string">&quot;Tim&quot;</span>, <span class="number">34</span>, <span class="keyword">out</span> stu);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Student &#123;0&#125; ,Age is &#123;1&#125;&quot;</span>, stu.Name, stu.Age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">StudentFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Create</span>(<span class="params"><span class="built_in">string</span> stuName, <span class="built_in">int</span> stuAge, <span class="keyword">out</span> Student result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(stuName))<span class="comment">//如果stuName为空，则创建失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stuAge &lt; <span class="number">20</span> || stuAge &gt; <span class="number">80</span>)<span class="comment">//如果年龄超出范围，则创建失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">new</span> Student() &#123; Age = stuAge, Name = stuName &#125;;<span class="comment">//创建学生实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//输出创建成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组参数">数组参数</h2><blockquote><p>数组参数是使用修饰符 <code>params</code>声明的参数</p></blockquote><p>示例1：CalculateSum方法计算数组元素的和</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] myIntArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">int</span> result = CalculateSum(myIntArray);</span><br><span class="line">    Console.WriteLine(result);<span class="comment">//输出6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalculateSum</span>(<span class="params"><span class="built_in">int</span>[] intArray</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> intArray)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还是不够简洁，尤其int[] myIntArray = new int[] {1,2, 3};这样的提前声明显得太麻烦</p><p>使用数组参数完成改进：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = CalculateSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//直接输入数组元素作为数组参数</span></span><br><span class="line">    Console.WriteLine(result);<span class="comment">//输出6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalculateSum</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] intArray</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> intArray)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们早就认识数组参数</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203142201258.png" alt="image-20220314220126095"></p><p>WriteLine的重载里有这类数组参数，允许我们对应输入任意个数参数，进行赋值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">int</span> y = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">int</span> z = x + y;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, x, y, z);<span class="comment">//后面的xyz就是数组参数</span></span><br></pre></td></tr></table></figure><p>示例2：字符串切分，并存入数组</p><p>这里用到string的split方法，将这里使用三种分隔方法的字符串拆分，方法参数为字符数组</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203151016408.png" alt="image-20220315101639303"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;Tim;Tom,Amy.Lisa&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[] result = str.Split(<span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);<span class="comment">//输出字符数组</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> res <span class="keyword">in</span> result)<span class="comment">//遍历数组</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具名参数">具名参数</h2><blockquote><p>参数的位置不受约束，调用方法时不需要一一对应进行赋值</p></blockquote><p>之前我们学习的都是不具名调用，具名调用就是通过类似键值组的形式，对应赋值</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PrintInfo(<span class="string">&quot;Tim&quot;</span>, <span class="number">34</span>);</span><br><span class="line">    PrintInfo(name: <span class="string">&quot;Tim&quot;</span>, age: <span class="number">34</span>);</span><br><span class="line">    PrintInfo(age: <span class="number">34</span>, name: <span class="string">&quot;Tim&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello &#123;0&#125;,you are &#123;1&#125;&quot;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个方法的调用结果相同，可以发现具名参数有一定好处</p><ul><li>提高代码可读性</li><li>填入参数的顺序不受约束</li></ul><h2 id="可选参数">可选参数</h2><blockquote><p>参数因为具有默认值而变得可选（但是不推荐）</p></blockquote><p>示例：可选参数位置处，不赋值也是可以的，有默认值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PrintInfo();<span class="comment">//输出Hello im,you are 34</span></span><br><span class="line">    PrintInfo(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>);<span class="comment">//输出Hello Tom,you are 23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params"><span class="built_in">string</span> name=<span class="string">&quot;Tim&quot;</span>, <span class="built_in">int</span> age = <span class="number">34</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello &#123;0&#125;,you are &#123;1&#125;&quot;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展方法（别名this参数）">扩展方法（别名this参数）</h2><p>示例：使得x四舍五入到第4位</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> x = <span class="number">3.14159</span>;</span><br><span class="line"><span class="built_in">double</span> y = Math.Round(x,<span class="number">4</span>);<span class="comment">//Round(x,y)方法是四舍五入到第y位</span></span><br><span class="line">Console.WriteLine(y);</span><br></pre></td></tr></table></figure><p>但是发现double类没有Round方法，而修改double类型的源码是无法做到的，并且编译后无法放入C#类库</p><p>如何实现呢？采用我们这里的扩展方法（扩展的含义就在这）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> x = <span class="number">3.14159</span>;</span><br><span class="line">        <span class="built_in">double</span> y = x.Round(<span class="number">4</span>);<span class="comment">//加了this之后，只要填入digits就行</span></span><br><span class="line">        Console.WriteLine(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoubleExtension</span> <span class="comment">//首先创建静态类，而且约定俗成写某数据类型Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Round</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">double</span> input,<span class="built_in">int</span> digits</span>)<span class="comment">//this必须是第一个</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> result = Math.Round(input,digits);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p><ul><li>方法必须是公有的、静态的，即被public static修饰（static类public方法）</li><li>this参数必须是参数列表的第一个，由this修饰</li><li>必须由一个静态类（约定某typeExtension）来统一收纳该type的扩展方法</li></ul></blockquote><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/">LINQ方法</a>就是基于扩展方法的</p><p>示例：接收集合类型的参数，判断集合内的元素都大于10</p><p>不使用LiNQ方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; mylist = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;;</span><br><span class="line">    <span class="built_in">bool</span> result = AllGreaterThanTen(mylist);</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">AllGreaterThanTen</span>(<span class="params">List&lt;<span class="built_in">int</span>&gt; intlist</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> intlist)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (item &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用LINQ方法：先引用LINQ，再使用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">           List&lt;<span class="built_in">int</span>&gt; mylist = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;;</span><br><span class="line">           <span class="built_in">bool</span> result = mylist.All(i =&gt; i &gt; <span class="number">10</span>);<span class="comment">//判断mylist的所有值是否都大于10</span></span><br><span class="line">           Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的All就是扩展方法，list里是没有all这个方法的，转到all的定义查看</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203151114041.png" alt="image-20220315111428905"></p><p>发现是对Enumerable的扩展方法，隶属于LINQ命名空间</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203151116902.png" alt="image-20220315111643764"></p><p>LINQ的使用在后续会有专题</p><hr><h1>第十章 委托</h1><p>本篇参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/delegates">委托</a>,这章难度很大</p><h2 id="委托的定义">委托的定义</h2><blockquote><p>委托(delegate)是函数指针（指向函数的指针）的“升级版”</p></blockquote><p>与c++函数指针不同，委托是完全面向对象的，与成员函数的c++指针不同的是，委托封装对象实例和方法</p><p>示例：C语言程序，去<a href="https://c.runoob.com/compile/11/">菜鸟工具</a>在线编程（还没跑通）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*Calc)(<span class="built_in">int</span> a,<span class="built_in">int</span> b);<span class="comment">//声明函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x ,<span class="built_in">int</span> y </span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> result = x +y;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">int</span> x ,<span class="built_in">int</span> y </span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> result = x -y;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span>  x = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">int</span> y = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">int</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Calc funcPoint1 = &amp;Add;<span class="comment">//取Add函数的地址</span></span><br><span class="line">    Calc funcPoint2 = undefined<span class="comment">//取Sub函数的地址</span></span><br><span class="line"></span><br><span class="line">    z = funcPoint1(x,y);<span class="comment">//通过函数指针进行调用</span></span><br><span class="line">    printf(<span class="string">&quot;%d+%d=%d\n&quot;</span>,x,y,z);</span><br><span class="line"></span><br><span class="line">    z = funcPoint2(x,y);</span><br><span class="line">    printf(<span class="string">&quot;%d+%d=%d\n&quot;</span>,x,y,z);</span><br><span class="line"></span><br><span class="line">    z = Add(x,y);</span><br><span class="line">    printf(<span class="string">&quot;%d+%d=%d\n&quot;</span>,x,y,z);</span><br><span class="line"></span><br><span class="line">    z =Sub(x,y);</span><br><span class="line">    printf(<span class="string">&quot;%d+%d=%d\n&quot;</span>,x,y,z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果跳得太快，使用system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲指针前需要了解的东西</p><blockquote><p>一切皆地址</p></blockquote><p>变量（数据）是以某个地址为起点的一段内存中所存储的值（每段内存的长度和数据类型相关）</p><p>函数（算法）是以某个地址为起点的一段内存中所存储的一组机器语言指令</p><blockquote><p>直接调用与间接调用</p></blockquote><p>直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行，再返回</p><p>间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行，再返回</p><p><strong>JAVA中没有与委托相对应的功能实体</strong>（这里有待商榷，因为视频的年份老了）</p><blockquote><p>委托的简单使用</p></blockquote><p>这里使用Action和Func委托，完成对方法的间接调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//action方法的参数必须是某个方法，该方法不能有参数和返回值</span></span><br><span class="line">        Action action = <span class="keyword">new</span> Action(calculator.Report);</span><br><span class="line">        <span class="comment">//Action悬停鼠标，有皮包的图案，代表封装了一些方法</span></span><br><span class="line">        calculator.Report();<span class="comment">//直接调用，输出I have 3 methods.</span></span><br><span class="line">        action.Invoke();<span class="comment">//间接调用,使用.invoke，输出I have 3 methods.</span></span><br><span class="line">        action();<span class="comment">//间接调用，输出I have 3 methods.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Func方法有很多类重载，按需选择，这里参数列表为两个整数类型，返回值为整数类型</span></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func1 = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;(calculator.Add);</span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func2 = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;(calculator.Sub);</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">int</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        z = func1(x, y);</span><br><span class="line">        Console.WriteLine(z);<span class="comment">//输出300</span></span><br><span class="line">        z = func2(x, y);</span><br><span class="line">        Console.WriteLine(z);<span class="comment">//输出100</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Report</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I have 3 methods.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> result = a + b;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> result = a - b;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="委托的声明（自定义委托）">委托的声明（自定义委托）</h2><blockquote><p>委托是一种类（class），类是数据类型，于是委托也是一种数据类型</p></blockquote><p>如何证明委托是一种类？</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(Action);</span><br><span class="line">Console.WriteLine(t.IsClass);</span><br></pre></td></tr></table></figure><blockquote><p>它的声明方式与一般的类不同，主要是为了照顾可读性和C/C++传统</p></blockquote><p>示例：委托封装Calculator类里的四个方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//委托delegate是一种类，需要和class并列，写在类里容易产生嵌套类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span>;</span><br><span class="line"><span class="comment">//自定义委托,委托参数为两个double类型，返回值为double</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line">        Calc calc1 = <span class="keyword">new</span> Calc(calculator.Add);</span><br><span class="line">        Calc calc2 = <span class="keyword">new</span> Calc(calculator.Sub);</span><br><span class="line">        Calc calc3 = <span class="keyword">new</span> Calc(calculator.Mul);</span><br><span class="line">        Calc calc4 = <span class="keyword">new</span> Calc(calculator.Div);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">double</span> a = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">double</span> b = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">double</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        c = calc1(a,b);</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line"></span><br><span class="line">        c = calc2(a,b);</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line"></span><br><span class="line">        c= calc3(a,b);</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line"></span><br><span class="line">        c = calc4(a,b);</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Mul</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Div</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x / y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：</strong></p><blockquote><p>委托与所封装的方法必须“类型兼容”</p></blockquote><p>委托和想封装起来的方法，在一些类型上需要对应</p><ul><li>返回值的数据类型一致</li><li>参数列表在个数和数据类型上一致（参数名不需要一样）</li></ul><blockquote><p>委托得和class并列，如果在类里面，会成为嵌套类型</p></blockquote><p>上面的calc就变成了Program.calc</p><h2 id="委托的简单使用">委托的简单使用</h2><blockquote><p>一般，把方法A当作方法参数传给另一个方法B，间接调用外部A方法</p></blockquote><p>这类使用方法分为两种：</p><h3 id="模板方法">模板方法</h3><blockquote><p>“借用”指定的外部方法来产生结果</p></blockquote><p>相当于“<strong>填空题</strong>”：方法体的逻辑已经完善，就缺少外部方法的一些逻辑，这时候填入外部方法的委托就行。</p><p>于是，这类委托<strong>常位于代码中部</strong>，而且需要产生结果，则需要<strong>有返回值</strong>。</p><p>（这里的代码还是不够直观，取名应该改进）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ProductFactory productFactory  = <span class="keyword">new</span> ProductFactory();  </span><br><span class="line">        WrapFactory wrapFactory = <span class="keyword">new</span> WrapFactory();</span><br><span class="line"></span><br><span class="line">        Func&lt;Product&gt; func1 = <span class="keyword">new</span> Func&lt;Product&gt;(productFactory.MakePizza);</span><br><span class="line">        Func&lt;Product&gt; func2 = <span class="keyword">new</span> Func&lt;Product&gt;(productFactory.MakeToyCar);</span><br><span class="line"></span><br><span class="line">        Box box1 = wrapFactory.WrapProduct(func1);</span><br><span class="line">        Box box2 = wrapFactory.WrapProduct(func2);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(box1.Product.Name);<span class="comment">//输出Pizza</span></span><br><span class="line">        Console.WriteLine(box2.Product.Name);<span class="comment">//输出ToyCar</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Product</span> <span class="comment">//包装内产品</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Box</span>  <span class="comment">//包装</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Product Product &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//包装内有产品，产品有名字</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">WrapFactory</span>  <span class="comment">//包装工厂，该类实现了对产品的包装过程复用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Box <span class="title">WrapProduct</span>(<span class="params">Func&lt;Product&gt; getProduct</span>) </span></span><br><span class="line"><span class="function">        <span class="comment">//接收委托类型参数，返回Product类型对象（模板方法）</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box();<span class="comment">//准备包装</span></span><br><span class="line">        Product product = getProduct.Invoke();<span class="comment">//产品等于Product的调用</span></span><br><span class="line">        box.Product = product; <span class="comment">//包装内产品为product</span></span><br><span class="line">        <span class="keyword">return</span> box;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductFactory</span> <span class="comment">//产品工厂</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">MakePizza</span>() <span class="comment">//产品为pizza</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.Name = <span class="string">&quot;Pizza&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">MakeToyCar</span>() <span class="comment">//产品为ToyCar</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.Name = <span class="string">&quot;ToyCar&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WrapFactory是模板方法，实现包装产品</p><h3 id="回调-callback-方法">回调(callback)方法</h3><blockquote><p>调用指定的外部方法</p></blockquote><p>相当于“流水线”：主要逻辑实现后，主调方法可以选择后续调用的方法。一般是为了执行后续的工作，所以常位于代码末尾，并且无返回值。</p><p>这里使用了<strong>DataTime.UtcNow</strong>方法，来获取当前时间（DataTime.Now是带时区的）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203161016991.png" alt="image-20220316091548580"></p><p>示例：添加log日志功能，以回调方法的形式传回模板方法中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ProductFactory productFactory = <span class="keyword">new</span> ProductFactory();</span><br><span class="line">        WrapFactory wrapFactory = <span class="keyword">new</span> WrapFactory();</span><br><span class="line"></span><br><span class="line">        Func&lt;Product&gt; func1 = <span class="keyword">new</span> Func&lt;Product&gt;(productFactory.MakePizza);</span><br><span class="line">        Func&lt;Product&gt; func2 = <span class="keyword">new</span> Func&lt;Product&gt;(productFactory.MakeToyCar);</span><br><span class="line"></span><br><span class="line">        Logger logger = <span class="keyword">new</span> Logger();</span><br><span class="line">        Action&lt;Product&gt; log  = <span class="keyword">new</span> Action&lt;Product&gt;(logger.Log);</span><br><span class="line">        <span class="comment">//输出Product &#x27;ToyCar&#x27; created at 2022/3/16 2:14:25. Price is 100</span></span><br><span class="line"></span><br><span class="line">        Box box1 = wrapFactory.WrapProduct(func1,log);</span><br><span class="line">        Box box2 = wrapFactory.WrapProduct(func2,log);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(box1.Product.Name);<span class="comment">//输出Pizza</span></span><br><span class="line">        Console.WriteLine(box2.Product.Name);<span class="comment">//输出ToyCar</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Logger</span> <span class="comment">//日志类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params">Product product</span>) </span></span><br><span class="line"><span class="function">        <span class="comment">//记录程序的运行状态，一般没有返回值（这里记录创建时间）</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Product &#x27;&#123;0&#125;&#x27; created at &#123;1&#125;. Price is &#123;2&#125;&quot;</span>, product.Name, DateTime.UtcNow,product.Price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Box</span>  <span class="comment">//包装</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Product Product &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//包装内有产品，产品有名字</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">WrapFactory</span>  <span class="comment">//包装工厂，该类实现了对产品的包装过程复用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Box <span class="title">WrapProduct</span>(<span class="params">Func&lt;Product&gt; getProduct, Action&lt;Product&gt; logCallBack</span>)</span></span><br><span class="line"><span class="function">        <span class="comment">//接收委托类型参数，返回Product类型对象（模板方法）</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box();<span class="comment">//准备包装</span></span><br><span class="line">        Product product = getProduct.Invoke();<span class="comment">//获取产品产品等于Product的调用</span></span><br><span class="line">        <span class="keyword">if</span> (product.Price &gt;= <span class="number">50</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            logCallBack(product);</span><br><span class="line">        &#125;</span><br><span class="line">        box.Product = product; <span class="comment">//包装内产品为product</span></span><br><span class="line">        <span class="keyword">return</span> box;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductFactory</span> <span class="comment">//产品工厂</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">MakePizza</span>() <span class="comment">//产品为pizza</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.Name = <span class="string">&quot;Pizza&quot;</span>;</span><br><span class="line">        product.Price = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">MakeToyCar</span>() <span class="comment">//产品为ToyCar</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.Name = <span class="string">&quot;ToyCar&quot;</span>;</span><br><span class="line">        product.Price = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：难精通+易使用+功能强大，一旦滥用会产生严重的后果</p></blockquote><p>缺点：</p><ul><li><p>这是方法级别的紧耦合，现实工作中要慎之又慎</p></li><li><p>使可读性下降，debug难度增加</p></li><li><p>把委托回调、异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护(灾难性)</p><p>视频中示例：</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203161037850.png" alt="image-20220316103756511"></p><p>调用的代码</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203161051442.png" alt="image-20220316105114249"></p></li><li><p>委托使用不当有可能造成内存泄漏和程序性能下降（委托会引用其他方法）</p></li></ul><h2 id="委托的高级使用">委托的高级使用</h2><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/">异步编程模式</a></p><h3 id="多播（mulicast）委托">多播（mulicast）委托</h3><p>示例：模拟学生在写作业（不同学生用输出颜色区分）</p><p>普通的委托</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">1</span>, Pencolor = ConsoleColor.Yellow &#125;;</span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">2</span>, Pencolor = ConsoleColor.Green &#125;;</span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">3</span>, Pencolor = ConsoleColor.Red &#125;;</span><br><span class="line"></span><br><span class="line">            Action action1 = <span class="keyword">new</span> Action(stu1.DoHomeWork);</span><br><span class="line">            Action action2 = <span class="keyword">new</span> Action(stu2.DoHomeWork);</span><br><span class="line">            Action action3 = <span class="keyword">new</span> Action(stu3.DoHomeWork);</span><br><span class="line"></span><br><span class="line">            action1.Invoke();</span><br><span class="line">            action2.Invoke();</span><br><span class="line">            action3.Invoke();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> ConsoleColor Pencolor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//ConsoleColor为命令行的输出颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoHomeWork</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = <span class="keyword">this</span>.Pencolor;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;</span>, <span class="keyword">this</span>.Id, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);<span class="comment">//该线程睡眠1000ms</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多播委托：主要是将多个委托封装到一个委托中，有点像命令行输入 <code>程序1，程序2，程序3</code>和 <code>程序1&amp;&amp;程序2&amp;&amp;程序3</code>的感觉</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">1</span>, Pencolor = ConsoleColor.Yellow &#125;;</span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">2</span>, Pencolor = ConsoleColor.Green &#125;;</span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">3</span>, Pencolor = ConsoleColor.Red &#125;;</span><br><span class="line"></span><br><span class="line">            Action action1 = <span class="keyword">new</span> Action(stu1.DoHomeWork);</span><br><span class="line">            Action action2 = <span class="keyword">new</span> Action(stu2.DoHomeWork);</span><br><span class="line">            Action action3 = <span class="keyword">new</span> Action(stu3.DoHomeWork);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一个委托封装多个委托，运行顺序为封装顺序</span></span><br><span class="line">            action1 += action2;</span><br><span class="line">            action1 += action3;</span><br><span class="line"></span><br><span class="line">            action1.Invoke();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> ConsoleColor Pencolor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//ConsoleColor为命令行的输出颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoHomeWork</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = <span class="keyword">this</span>.Pencolor;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;</span>, <span class="keyword">this</span>.Id, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);<span class="comment">//该线程睡眠1000ms</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐式异步调用">隐式异步调用</h3><h4 id="同步与异步的理解">同步与异步的理解</h4><blockquote><p>注意中英文的语言差异，英文里异步等于中文的同步</p></blockquote><p>同步：你做完了，我在你基础上接着做</p><p>异步：我们两个一起做（等价于汉语中的“同步进行”）</p><h4 id="同步调用与异步调用">同步调用与异步调用</h4><p>例图：</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203161705344.png" alt="image-20220316170537951"></p><blockquote><p>每一个运行的程序是一个进程(process)，而每个进程可以有一个或者多个线程(thread)</p></blockquote><p>可以进入win的任务管理器，查看进程管理器，这里可以看到目前使用的软件进程</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203161658693.png" alt="image-20220316165858518"></p><p>而每个软件进程，当然包含了多个线程，想想浏览器打开多个网页互不干扰，聊天软件打开多个聊天框也互不干扰（这里的互不干扰是逻辑上的，前提是忽略了共同数据的相互调用）</p><blockquote><p>同步调用是同一个线程内，异步调用的底层机理是多线程</p></blockquote><p>由例图可知，同步调用和我们之前的Main函数主体调用其他方法一样，而采取异步调用可以使得我们程序不来回调（后面讲解多线程技术）</p><p>总结：</p><p>串行=同步=单线程</p><p>并行=异步=多线程</p><h4 id="隐式多线程与显式多线程">隐式多线程与显式多线程</h4><h5 id="直接同步调用">直接同步调用</h5><blockquote><p>使用方法名</p></blockquote><p>这里使用上面程序，更改后</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">1</span>, Pencolor = ConsoleColor.Yellow &#125;;</span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">2</span>, Pencolor = ConsoleColor.Green &#125;;</span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">3</span>, Pencolor = ConsoleColor.Red &#125;;</span><br><span class="line"></span><br><span class="line">            stu1.DoHomeWork();</span><br><span class="line">            stu2.DoHomeWork();</span><br><span class="line">            stu3.DoHomeWork();<span class="comment">//主线程逐一调用三个方法，然后走到下面线程</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">//作为主进程的一部分</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = ConsoleColor.Cyan;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Main  thread &#123;0&#125;&quot;</span>,i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> ConsoleColor Pencolor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//ConsoleColor为命令行的输出颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoHomeWork</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = <span class="keyword">this</span>.Pencolor;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;</span>, <span class="keyword">this</span>.Id, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);<span class="comment">//该线程睡眠1000ms</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="间接同步调用">间接同步调用</h5><blockquote><p>使用单播/多播<strong>委托的invoke方法</strong></p></blockquote><p>单播委托</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">1</span>, Pencolor = ConsoleColor.Yellow &#125;;</span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">2</span>, Pencolor = ConsoleColor.Green &#125;;</span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">3</span>, Pencolor = ConsoleColor.Red &#125;;</span><br><span class="line"></span><br><span class="line">            Action action1 = <span class="keyword">new</span> Action(stu1.DoHomeWork);</span><br><span class="line">            Action action2 = <span class="keyword">new</span> Action(stu2.DoHomeWork);</span><br><span class="line">            Action action3 = <span class="keyword">new</span> Action(stu3.DoHomeWork);</span><br><span class="line"></span><br><span class="line">            action1.Invoke();</span><br><span class="line">            action2.Invoke();</span><br><span class="line">            action3.Invoke();<span class="comment">//使用委托间接地调用，而且是一步步调用，为同步调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> ConsoleColor Pencolor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//ConsoleColor为命令行的输出颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoHomeWork</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = <span class="keyword">this</span>.Pencolor;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;</span>, <span class="keyword">this</span>.Id, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);<span class="comment">//该线程睡眠1000ms</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多播委托</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">1</span>, Pencolor = ConsoleColor.Yellow &#125;;</span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">2</span>, Pencolor = ConsoleColor.Green &#125;;</span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">3</span>, Pencolor = ConsoleColor.Red &#125;;</span><br><span class="line"></span><br><span class="line">            Action action1 = <span class="keyword">new</span> Action(stu1.DoHomeWork);</span><br><span class="line">            Action action2 = <span class="keyword">new</span> Action(stu2.DoHomeWork);</span><br><span class="line">            Action action3 = <span class="keyword">new</span> Action(stu3.DoHomeWork);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一个委托封装多个委托，运行顺序为封装顺序</span></span><br><span class="line">            action1 += action2;</span><br><span class="line">            action1 += action3;</span><br><span class="line"></span><br><span class="line">            action1.Invoke();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> ConsoleColor Pencolor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//ConsoleColor为命令行的输出颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoHomeWork</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = <span class="keyword">this</span>.Pencolor;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;</span>, <span class="keyword">this</span>.Id, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);<span class="comment">//该线程睡眠1000ms</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="隐式异步调用-2">隐式异步调用</h5><blockquote><p>使用委托的Begininvoke实现隐式的异步调用（委托的另一方法）</p></blockquote><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">1</span>, Pencolor = ConsoleColor.Yellow &#125;;</span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">2</span>, Pencolor = ConsoleColor.Green &#125;;</span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">3</span>, Pencolor = ConsoleColor.Red &#125;;</span><br><span class="line"></span><br><span class="line">            Action action1 = <span class="keyword">new</span> Action(stu1.DoHomeWork);</span><br><span class="line">            Action action2 = <span class="keyword">new</span> Action(stu2.DoHomeWork);</span><br><span class="line">            Action action3 = <span class="keyword">new</span> Action(stu3.DoHomeWork);</span><br><span class="line"></span><br><span class="line">            action1.BeginInvoke(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            action2.BeginInvoke(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            action3.BeginInvoke(<span class="literal">null</span>, <span class="literal">null</span>);<span class="comment">//异步调用三个方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">//作为主进程</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = ConsoleColor.Cyan;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Main  thread &#123;0&#125;&quot;</span>, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> ConsoleColor Pencolor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line">        <span class="comment">//ConsoleColor为命令行的输出颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoHomeWork</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = <span class="keyword">this</span>.Pencolor;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;</span>, <span class="keyword">this</span>.Id, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);<span class="comment">//该线程睡眠1000ms</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：主线程和其他线程在同步运行；有些线程的颜色相同，发现当多个地方在访问前景色的时候，发现冲突，这时候需要加锁，防止冲突。这里不讲！</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203162023774.png" alt="image-20220316202339529"></p><h5 id="显式异步调用">显式异步调用</h5><blockquote><p>使用Thread（原始）和Task</p></blockquote><p>Thread示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">1</span>, Pencolor = ConsoleColor.Yellow &#125;;</span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">2</span>, Pencolor = ConsoleColor.Green &#125;;</span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">3</span>, Pencolor = ConsoleColor.Red &#125;;</span><br><span class="line"></span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(stu1.DoHomeWork));</span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(stu2.DoHomeWork));</span><br><span class="line">            Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(stu3.DoHomeWork));<span class="comment">//创建三个线程</span></span><br><span class="line"></span><br><span class="line">            thread1.Start();</span><br><span class="line">            thread2.Start();</span><br><span class="line">            thread3.Start();<span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">//作为主进程的一部分</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = ConsoleColor.Cyan;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Main  thread &#123;0&#125;&quot;</span>, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> ConsoleColor Pencolor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//ConsoleColor为命令行的输出颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoHomeWork</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = <span class="keyword">this</span>.Pencolor;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;</span>, <span class="keyword">this</span>.Id, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);<span class="comment">//该线程睡眠1000ms</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果和隐式异步调用类似，也会发生资源争抢的多线程运行</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203162029483.png" alt="image-20220316202955259"></p><p>Task示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student stu1 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">1</span>, Pencolor = ConsoleColor.Yellow &#125;;</span><br><span class="line">            Student stu2 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">2</span>, Pencolor = ConsoleColor.Green &#125;;</span><br><span class="line">            Student stu3 = <span class="keyword">new</span> Student() &#123; Id = <span class="number">3</span>, Pencolor = ConsoleColor.Red &#125;;</span><br><span class="line"></span><br><span class="line">            Task task1 = <span class="keyword">new</span> Task(<span class="keyword">new</span> Action(stu1.DoHomeWork));</span><br><span class="line">            Task task2 = <span class="keyword">new</span> Task(<span class="keyword">new</span> Action(stu2.DoHomeWork));</span><br><span class="line">            Task task3 = <span class="keyword">new</span> Task(<span class="keyword">new</span> Action(stu3.DoHomeWork));</span><br><span class="line"></span><br><span class="line">            task1.Start();</span><br><span class="line">            task2.Start();</span><br><span class="line">            task3.Start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">//作为主进程的一部分</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = ConsoleColor.Cyan;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Main  thread &#123;0&#125;&quot;</span>, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> ConsoleColor Pencolor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//ConsoleColor为命令行的输出颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoHomeWork</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = <span class="keyword">this</span>.Pencolor;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;</span>, <span class="keyword">this</span>.Id, i);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);<span class="comment">//该线程睡眠1000ms</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果和上述一样，仍会资源争抢</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203162035209.png" alt="image-20220316203509050"></p><h3 id="设计模式小知识">设计模式小知识</h3><blockquote><p>应该适时地使用接口取代一些对委托的使用</p></blockquote><p>java完全地使用接口取代了委托的功能，即java没有与C#中委托相对应的功能实体</p><p>示例：重构之前委托的模板方法例子，加入IProductFactory接口</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203162053375.png" alt="image-20220316205347141"></p><p>这里点击快速操作，可以自动生成接口内部程序</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203162054883.png" alt="image-20220316205445733"></p><p>完整程序：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//准备pizza工厂</span></span><br><span class="line">        IProductFactory pizzaFactory = <span class="keyword">new</span> PizzaFactory(); </span><br><span class="line">        <span class="comment">//准备toyCar工厂</span></span><br><span class="line">        IProductFactory toyCarFactory = <span class="keyword">new</span> ToyCarFactory(); </span><br><span class="line">        <span class="comment">//准备wrapFactory总装工厂</span></span><br><span class="line">        WrapFactory wrapFactory = <span class="keyword">new</span> WrapFactory(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//pizza工厂生产的物品，输入到总装工厂，打包成产品</span></span><br><span class="line">        Box box1 = wrapFactory.WrapProduct(pizzaFactory);</span><br><span class="line">        <span class="comment">//toyCar工厂生产的物品，输入到总装工厂，打包成产品</span></span><br><span class="line">        Box box2 = wrapFactory.WrapProduct(toyCarFactory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(box1.Product.Name); <span class="comment">//输出pizza</span></span><br><span class="line">        Console.WriteLine(box2.Product.Name); <span class="comment">//输出toyCar</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IProductFactory</span> <span class="comment">//创建产品工厂接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Product <span class="title">Make</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">PizzaFactory</span> : <span class="title">IProductFactory</span> <span class="comment">//产品工厂生产Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">Make</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.Name = <span class="string">&quot;Pizza&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Product</span> <span class="comment">//内部物品的生产工厂</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Box</span>  <span class="comment">//包装工厂</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Product Product &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//包装内有物品，物品有对应名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ToyCarFactory</span> : <span class="title">IProductFactory</span><span class="comment">//产品工厂生产ToyCar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">Make</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.Name = <span class="string">&quot;ToyCar&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">WrapFactory</span>  <span class="comment">//产品总装工厂</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Box <span class="title">WrapProduct</span>(<span class="params">IProductFactory productFactory</span>) <span class="comment">//工厂的流水线过程</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box();<span class="comment">//准备包装</span></span><br><span class="line">        Product product = productFactory.Make();<span class="comment">//准备内部物品</span></span><br><span class="line">        box.Product = product; <span class="comment">//贴上包装内物品名</span></span><br><span class="line">        <span class="keyword">return</span> box; <span class="comment">//返回产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，后续会讲解接口，所以这里只需要记住接口可以代替委托</p><hr><h1>第十一章 事件</h1><p>本章参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/events/">事件——C#编程指南</a>、<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/classes#events">事件——C#编程规范 </a></p><h2 id="事件的概念">事件的概念</h2><h3 id="事件的定义">事件的定义</h3><blockquote><p>类或对象可以通过事件向其他类或对象通知<strong>发生的相关事情</strong></p></blockquote><p>发送（或引发）事件的类称为“发布者”，接收（或处理）事件的类称为“<strong>订阅</strong>者**（事件处理器）<strong>”，而事件就是两者的“消息</strong>（事件参数）**推送”</p><p>总结：事件的功能=通知＋可选的事件参数（即详细信息)</p><p>事件<strong>用于对象或类间的动作协调与信息传递</strong>，于是<strong>常表现为使对象或类具备通知能力的成员</strong>（事件也是类的成员之一）</p><h3 id="事件的理解">事件的理解</h3><blockquote><p>原理：事件模型（event model）通俗理解中有两个“5”</p></blockquote><p><strong>发生到响应的5个部分：</strong></p><p>比如闹钟响了于是起床（闹钟、响铃、我、起床）、孩子饿了于是做饭（孩子、饿了、我、做饭）。我们明面上只发现四个元素，而第五个元素是订阅关系，比如我关注（订阅）自己闹钟的响铃事件，我关注（订阅）自己孩子的饥饿</p><p>就是：</p><ul><li>发布者</li><li>发布者的状态/动作</li><li>订阅者</li><li>订阅者的状态/动作</li><li>订阅者对发布者状态的关注（订阅）</li></ul><p><strong>发生到响应的5个动作：</strong></p><ul><li>发布者有一些可能的状态变化/动作</li><li>订阅者关注（订阅）发布者</li><li>发布者状态变化/动作发生了</li><li>订阅者关注（观察到）发布者事件</li><li>订阅者根据得到（观察到）的事件参数，对事件进行响应/处理</li></ul><blockquote><p>事件的特点</p></blockquote><p>事件具有以下特点：</p><ul><li>发行者确定何时引发事件；订阅者确定对事件作出何种响应</li><li>一个事件可以有多个订阅者。订阅者可以处理来自多个发行者的多个事件</li><li>没有订阅者的事件永远也不会引发</li><li>事件通常用于表示用户操作，例如单击按钮或图形用户界面中的菜单选项</li><li>当事件具有多个订阅者时，引发该事件时会同步调用事件处理程序</li><li>在.NET类库中，事件基于<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.eventhandler">EventHandler</a>委托和<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.eventargs">EventArgs</a>基类(可以查看它的成员)</li></ul><h3 id="一些提示">一些提示</h3><p>事件多用于桌面、手机等开发的客户端编程，因为这些程序经常事用户通过事件来驱动的</p><p>各种编程语言对这个机制的实现方法并不相同。比如Java语言里没有事件这种成员，也没有委托这种数据类型。Java的“事件”是使用接口来实现</p><p>MVC、MVP、MVVM等模式，是事件模式更高级、更有效的“玩法”</p><h2 id="事件的应用">事件的应用</h2><p>日常开发的时候，使用已有事件的机会比较多，自己声明事件的机会比较少，所以先学习如何使用（事件的完整形式才是我最终领悟的）</p><h3 id="事件模型的组成部分"><strong>事件模型的组成部分</strong></h3><p>事件模型有五个组成部分：</p><ul><li>事件的拥有者（event source，类/对象）<ul><li>事件成员（event，方法成员）</li></ul></li><li>事件的响应者（event subscriber，类/对象）<ul><li>事件处理器（event handler，方法成员；本质上是委托的回调方法，也叫回调函数）</li></ul></li><li>事件订阅（把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的“约定”：约定了事件的可通知消息，约定了事件处理器能够处理的消息，约定信息传递）</li></ul><blockquote><p>事件是被拥有者的内部逻辑所触发</p></blockquote><p>平时看到我们点击按钮时，会触发一些操作，那么是外部逻辑触发？</p><p>并不是，win启动就追踪鼠标位置，发现当前鼠标位置有按钮，并被点击，而win就会通知按钮，告诉其被点击，显示按下状态，并标记状态，而后面被松开也出现一定的图形变化；这时候，按钮是被点击了，按钮会通知外界自己被点击，事件发生后，某对象如果订阅该事件，则会出现相应的反应（还是按钮的内部逻辑触发了事件）</p><blockquote><p>事件处理器对事件的订阅不是随意的，匹配与否由<strong>声明事件时所使用的委托类型</strong>来检测</p></blockquote><h3 id="五个部分的逻辑结构">五个部分的逻辑结构</h3><p>组成部分的逻辑范围可以分为四个级别（刘老师）</p><blockquote><p>零星：普通应用</p></blockquote><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171137071.png" alt="image-20220317113705955"></p><p>示例：简单的时钟间隔事件（<strong>先创建事件订阅，使用快捷操作就能自动创建事件处理器</strong>）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Timers;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Timer timer = <span class="keyword">new</span> Timer(); <span class="comment">//创建事件的拥有者</span></span><br><span class="line">            timer.Interval = <span class="number">1000</span>; <span class="comment">//设置时间间隔为1s，每隔1s就会触发timer事件</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(); <span class="comment">//事件响应者</span></span><br><span class="line">            timer.Elapsed += boy.Action; <span class="comment">//添加对Elapsed事件监听</span></span><br><span class="line">            <span class="comment">//并使用快捷操作自动创建Elapsed间隔事件处理器</span></span><br><span class="line"></span><br><span class="line">            timer.Start(); <span class="comment">//使得事件发生</span></span><br><span class="line">            Console.ReadLine();<span class="comment">//查看运行结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Boy</span> <span class="comment">//事件的响应者类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"><span class="built_in">object</span> sender, ElapsedEventArgs e</span>) </span></span><br><span class="line"><span class="function">            <span class="comment">//由timer.Elapsed += boy.Action;自动生成</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Jump!&quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍加改进：为这个事件再添加一个响应</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Timers;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Timer timer = <span class="keyword">new</span> Timer(); <span class="comment">//创建事件的拥有者</span></span><br><span class="line">            timer.Interval = <span class="number">1000</span>; <span class="comment">//设置时间间隔为1s，每隔1s就会触发timer事件</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(); <span class="comment">//事件响应者</span></span><br><span class="line">            Girl girl = <span class="keyword">new</span> Girl();</span><br><span class="line">            timer.Elapsed += boy.Action; <span class="comment">//添加Elapsed间隔事件监听</span></span><br><span class="line">            timer.Elapsed += girl.Action; <span class="comment">//继续添加Elapsed间隔事件监听                         </span></span><br><span class="line">            timer.Start(); <span class="comment">//使得事件发生</span></span><br><span class="line">            Console.ReadLine();<span class="comment">//查看运行结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Boy</span> <span class="comment">//事件的响应者类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"><span class="built_in">object</span> sender, ElapsedEventArgs e</span>) <span class="comment">//由timer.Elapsed += boy.Action;自动生成</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Jump!&quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Girl</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"><span class="built_in">object</span> sender, ElapsedEventArgs e</span>)<span class="comment">//事件处理器1</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Sing!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一星：结构清晰，MVC等结构雏形</p></blockquote><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171032246.png" alt="image-20220317103234071"></p><p>示例：点击事件实现显示时间（输入ctor+两下tab,就可以输出构造函数）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Form form = <span class="keyword">new</span> Form(); <span class="comment">//事件的拥有者</span></span><br><span class="line">            <span class="comment">//创建事件的响应者，并实现订阅</span></span><br><span class="line">            Controller controller = <span class="keyword">new</span> Controller(form);</span><br><span class="line">            form.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Controller</span> <span class="comment">//事件响应者类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Form form;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Controller</span>(<span class="params">Form form</span>) <span class="comment">//输入ctor+两下tab,就可以输出构造函数</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (form != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.form = form;</span><br><span class="line">                <span class="comment">//从这里创建事件订阅，来直接自动创建事件处理器</span></span><br><span class="line">                <span class="keyword">this</span>.form.Click += <span class="keyword">this</span>.FormClicked;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//事件处理器</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FormClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>) </span></span><br><span class="line"><span class="function">     <span class="comment">//注意EventArgs和之前的ElapsedEventArgs不同，说明此处是存在事件参数的约定</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.form.Text = DateTime.Now.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二星：自己方法订阅自己事件，很常见</p></blockquote><p><img src="https://s2.loli.net/2022/03/26/NwJxDHOulmvkgXp.png" alt="image-20220317113456901"></p><p>示例：</p><p>这里仍然使用Form作为事件拥有者，但是发现采用这种结构，Form无法像之前那么创建事件处理器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Form form = <span class="keyword">new</span> Form(); <span class="comment">//事件的拥有者</span></span><br><span class="line"><span class="comment">//form.Click+= form.Action;这个无法使用，因为form这个类是编写好的类，无法进行更改</span></span><br><span class="line"><span class="comment">//如果自己创建Form类，虽然名字是Form，但是没有click等事件，个人无法编写</span></span><br></pre></td></tr></table></figure><p>那么如何在Form类原有基础上扩展新功能？使用派生/继承。通过继承，可以实现自己创建的MyForm归属于Form，进而实现事件的拥有者和事件响应者变成一体（其实是爸爸和儿子还是一家人，弱化了概念）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyForm form = <span class="keyword">new</span> MyForm();</span><br><span class="line">            form.Click += form.FormClicked;</span><br><span class="line">            form.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过继承，实现事件响应者属于原来的事件产生者</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyForm</span> : <span class="title">Form</span> <span class="comment">//MyForm派生自Form</span></span><br><span class="line">                        <span class="comment">//约定：名称带大写的i是接口，其他的是派生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">FormClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>) <span class="comment">//事件处理器</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Text = DateTime.Now.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>三星：使用最多，事件的拥有者是事件响应者的字段成员（Win默认的事件处理结构）</p></blockquote><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171033066.png" alt="image-20220317103348924"></p><p>示例：使用Form窗口文本框和按钮（），点击按钮后，文本框显示“Hello，World”</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyForm form = <span class="keyword">new</span> MyForm(); </span><br><span class="line">            form.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyForm</span> : <span class="title">Form</span> <span class="comment">//MyForm派生自Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> TextBox textBox; <span class="comment">//文本框成员</span></span><br><span class="line">        <span class="keyword">private</span> Button button;  <span class="comment">//按钮成员</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyForm</span>() <span class="comment">//实例构造函数</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//准备控件</span></span><br><span class="line">            <span class="keyword">this</span>.textBox = <span class="keyword">new</span> TextBox(); </span><br><span class="line">            <span class="keyword">this</span>.button = <span class="keyword">new</span> Button();</span><br><span class="line">            <span class="keyword">this</span>.button.Text = <span class="string">&quot;Say Hello&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.button.Top = <span class="number">100</span>;  <span class="comment">//非可视化创建两个控件</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(<span class="keyword">this</span>.button);</span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(<span class="keyword">this</span>.textBox); <span class="comment">//添加两个控件</span></span><br><span class="line">            <span class="keyword">this</span>.button.Click += <span class="keyword">this</span>.ButtonClicked; <span class="comment">//事件发生者button.Click,创建事件订阅</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ButtonClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>) <span class="comment">//事件处理器</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.textBox.Text = <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WinForm添加事件">WinForm添加事件</h3><h4 id="普通添加事件">普通添加事件</h4><p>上面的非可视化编程，会很麻烦这时候可以创建Winform项目（新建——Winform窗体应用）</p><p>先创建界面，将Form的名字改为Myfrom，把文本改为Hello，Form</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171303250.png" alt="image-20220317130300921"></p><p>拖拉所需控件，并更改配置</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171255051.png" alt="image-20220317125552788"></p><p>右键进入逻辑代码（或者F7）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171315263.png" alt="image-20220317131539086"></p><p>进行更改</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WinFormsApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MyForm</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyForm</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line"><span class="comment">//创建时，会自动按照数字取名，比如第一个button就是button1，属性窗口的Name就是这个名字</span></span><br><span class="line">            <span class="keyword">this</span>.button1.Click += Button1_Click; </span><br><span class="line"> <span class="comment">//输入this.button1.Click +=，然后输入两次Tab键，会自动取名并创建事件处理器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span>? sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.button1.Text = <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者可以再加入一些快捷操作，选择button进入它的属性面板，点击事件面板（带小闪电），找到Click事件，会自动帮你生成该事件（如果想修改名字可以在属性面板中Click事件的选项里修改）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171330919.png" alt="image-20220317133041716"></p><p>双击Click处，进入后台逻辑，完成事件处理器，能够实现，但是没找到事件订阅。这里我们右击click方法名，查找所有引用，找出微软隐藏的事件订阅在哪</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171331366.png" alt="image-20220317133120185"></p><p>发现有一处有委托，委托引用了Click方法</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171326881.png" alt="image-20220317132606705"></p><blockquote><p>挂接事件处理器的时候，可以使用委托示例，也可以直接使用方法名，这是个语法糖</p></blockquote><p>这里是早期的委托方法，我们可以进行更改，改为使用方法名<img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171333973.png" alt="image-20220317133306785"></p><p>发现仍可以使用</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171334266.png" alt="image-20220317133402094"></p><p>而看到最后这些代码，可以发现“可见即所得”的可视化设计器实际上是可视化地编辑这些后台程序</p><blockquote><p>事件处理器可以被重用</p></blockquote><p>以WinForm为例子：</p><p>创建多个按钮，为button1添加Click事件ButtonClick</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171347222.png" alt="image-20220317134711948"></p><p>完善事件处理器</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171352845.png" alt="image-20220317135222713"></p><p>这时候，编辑button2的Click事件时，会出现复选框，能够选择button1的事件处理器，实现对事件处理器的复用</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171351505.png" alt="image-20220317135108276"></p><p>最后点击button2，也能使TextBox1的文本为Hello，World！</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171353862.png" alt="image-20220317135323747"></p><blockquote><p>在一个事件处理器中，可以实现对多个事件的选择性执行</p></blockquote><p>（因为参数sender是事件的拥有者/发送者）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WinForms</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ButtonClick</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>) </span></span><br><span class="line"><span class="function">            <span class="comment">//sender是事件的拥有者/发送者</span></span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(sender == <span class="keyword">this</span>.button1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.textBox1.Text = <span class="string">&quot;Hello!&quot;</span>;<span class="comment">//点击按钮1时，显示Hello</span></span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(sender == <span class="keyword">this</span>.button2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.textBox1.Text = <span class="string">&quot;World&quot;</span>;<span class="comment">//点击按钮2时，显示World</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，成功！</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171400741.png" alt="image-20220317140011540"></p><p>再将button3通过委托挂载上事件处理器，仍可成功</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171404524.png" alt="image-20220317140443303"></p><h4 id="匿名函数添加事件">匿名函数添加事件</h4><blockquote><p>使用匿名函数实现事件处理器的挂载（已经过时）</p></blockquote><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171406064.png" alt="image-20220317140637889"></p><blockquote><p>使用Lambda表达式也能实现事件处理器的挂载</p></blockquote><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171408296.png" alt="image-20220317140814097"></p><h3 id="WPF添加事件">WPF添加事件</h3><p>还是以文本框和按钮为例，演示在WPF中添加事件</p><blockquote><p>WPF是通过Xaml（和HTML是一个家族）设计UI，C#设计后台逻辑，实现桌面程序开发的技术</p></blockquote><p>新建——WPF应用（基于Framework）——拖拽控件</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171504354.png" alt="image-20220317150452162"></p><p>在TextBox的Xaml代码处加入Name属性，为了后续引用（同理再加上Button）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171511780.png" alt="image-20220317151113579"></p><p>点击属性面板，选中Click事件，取名或者直接双击进入后台代码</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171508649.png" alt="image-20220317150810397"></p><p>填入事件处理器，并编写订阅，调试完成<img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171513114.png" alt="image-20220317151350946"></p><p>事件订阅处，我们改成委托方法是否能成功？</p><p>我们需要使用的是RouteEventHandler构造器，而不是Winform里的EventHandler构造器。因为WPF使用的是路由事件（WPF内容）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171515315.png" alt="image-20220317151556136"></p><blockquote><p>上述讲解了很多调用例子，都是同步调用，但是事件是可以使用异步调用的，这里我们不介绍</p></blockquote><h2 id="自定义事件的声明">自定义事件的声明</h2><p>当遇到一些无法使用Win自带的事件，则需要声明自定义事件。如果只知道简略声明，会把事件和委托字段（委托类型的字段与委托类型区分）混淆，所以先介绍完整声明方式。这里参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/classes#events">事件 C#编程规范</a></p><h3 id="事件的完整声明">事件的完整声明</h3><blockquote><p>格式：可选的<strong>特性</strong> + <strong>事件修饰符</strong> + <code>event</code> + <strong>数据类型</strong> + <strong>事件名</strong> + <strong>{事件处理器}</strong></p></blockquote><p>事件修饰符有new、public、protected、interal、private、static、virtual、sealed、override、abstract、extern和不安全的事件修饰符</p><p>事件声明器包括添加器和移除器，两个需要同时存在，顺序不限制。添加器的格式为<strong>特性＋add关键字+块语句</strong>，移除器的格式为<strong>特性＋remove关键字+块语句</strong>。</p><p>声明的一些规定（配合下面示例进行理解）：</p><ol><li><p><strong>事件消息类需要以EventArgs结尾,并且派生自EventArgs基类</strong>（声明order事件的事件消息，则声明class OrderEventArgs : EventArgs ）</p></li><li><p><strong>声明有关于事件的委托类型时，得以EventHandler结尾</strong>（声明Order事件的委托类型，则声明为 public delegate void OrderEventHandler(Customer customer,OrderEventArgs e);）</p></li><li><p><strong>类的访问级别需要相对应，因为几个相关类会配合使用，需要设置一样的访问级别</strong>（不设置会报错：访问性不一致）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171552789.png" alt="image-20220317155207619"></p></li></ol><h4 id="示例：完整版顾客点餐">示例：完整版顾客点餐</h4><p>顾客进入餐馆，会发生点餐（order）事件，服务员会对应处理该事件（自定义的点餐事件的声明）</p><blockquote><p>因为这里没有委托类型来声明我们的点餐事件，还得用声明委托类型来表示点餐动作</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Customer customer = <span class="keyword">new</span> Customer(); <span class="comment">//事件拥有者 顾客</span></span><br><span class="line">            Waiter waiter = <span class="keyword">new</span> Waiter(); <span class="comment">//事件响应者 服务员</span></span><br><span class="line">   <span class="comment">//使用Serve作为事件处理器方法的名字.开启Waiter对顾客的订阅（监听），等待顾客的动作</span></span><br><span class="line">            customer.Order += waiter.Serve; </span><br><span class="line">            customer.Action();<span class="comment">//顾客完成一系列动作</span></span><br><span class="line">            customer.PayTheBill();<span class="comment">//顾客结账</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要声明委托类型来表示我们的Order事件订阅，参数一为点餐人，参数二为点餐的参数/事件参数，菜的名字和大小份（所以赶紧在下面声明这两个字段）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OrderEventHandler</span>(<span class="params">Customer customer, OrderEventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改OrderEventArgs和Customer类访问级别为public，是为了和delegate三者配合使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> DishName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//菜名</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//菜的大小份</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用委托类型声明字段用于顾客的点餐事件的判断（不希望被访问，则使用private修饰符）</span></span><br><span class="line">        <span class="keyword">private</span> OrderEventHandler orderEventHandler; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> OrderEventHandler Order <span class="comment">//Order事件的完整声明</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">add</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.orderEventHandler += <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">remove</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.orderEventHandler -= <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Bill &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//需要付的款</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PayTheBill</span>() <span class="comment">//付款动作</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I will pay $&#123;0&#125;&quot;</span>, <span class="keyword">this</span>.Bill);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于触发事件，走路坐下点餐</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WalkIn</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Walk into the restaurant&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SitDown</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Sit Down!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Think</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Let me think...&quot;</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.orderEventHandler != <span class="literal">null</span>) <span class="comment">//如果订阅器不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                OrderEventArgs e = <span class="keyword">new</span> OrderEventArgs();</span><br><span class="line">                e.DishName = <span class="string">&quot;KongPao Chicken&quot;</span>;</span><br><span class="line">                e.Size = <span class="string">&quot;large&quot;</span>;</span><br><span class="line">                <span class="keyword">this</span>.orderEventHandler.Invoke(<span class="keyword">this</span>,e); </span><br><span class="line">                <span class="comment">//this即顾客点餐，e则交代菜名和大小份</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>() <span class="comment">//封装顾客的三个动作</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.ReadLine(); <span class="comment">//让程序等待我们按回车，顾客再进去</span></span><br><span class="line">            <span class="keyword">this</span>.WalkIn();</span><br><span class="line">            <span class="keyword">this</span>.SitDown();</span><br><span class="line">            <span class="keyword">this</span>.Think();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Waiter</span>  <span class="comment">//事件的响应者waiter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Serve</span>(<span class="params">Customer customer, OrderEventArgs e</span>) </span></span><br><span class="line"><span class="function">            <span class="comment">//自动生成的Serve方法需改为public访问性</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I will serve you the dish: &#123;0&#125;&quot;</span>,e.DishName);</span><br><span class="line">            <span class="built_in">double</span> price = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">switch</span> (e.Size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;small&quot;</span>:</span><br><span class="line">                    price *= <span class="number">0.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;large&quot;</span>:</span><br><span class="line">                    price *= <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            customer.Bill += price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件的简略声明">事件的简略声明</h3><p>可叫Field—like事件，就是简略声明的事件像字段一样使用（若要以这种方式使用，事件不得为 <code>abstract</code>或 <code>extern</code>，而且不能显式包含事件处理器）</p><blockquote><p>格式：可选的<strong>特性</strong> + <strong>事件修饰符</strong> + <code>event</code> + <strong>数据类型</strong> + <strong>变量名</strong>;</p></blockquote><h4 id="示例：简化版顾客点餐">示例：简化版顾客点餐</h4><p>重构部位：</p><ul><li>采用简化声明（也就比字段多个event关键字）</li></ul><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171651138.png" alt="image-20220317165103962"></p><ul><li>使用事件名取代之前的字段名位置（但是并不是事件已经变成字段）</li></ul><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171649143.png"/><p>代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Customer customer = <span class="keyword">new</span> Customer(); <span class="comment">//事件拥有者 顾客</span></span><br><span class="line">            Waiter waiter = <span class="keyword">new</span> Waiter(); <span class="comment">//事件响应者 服务员</span></span><br><span class="line">            customer.Order += waiter.Serve; </span><br><span class="line">    <span class="comment">//使用Serve作为事件处理器方法的名字.开启Waiter对顾客的订阅（监听），等待顾客的动作</span></span><br><span class="line">            customer.Action();<span class="comment">//顾客完成一系列动作</span></span><br><span class="line">            customer.PayTheBill();<span class="comment">//顾客结账</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要声明委托类型来表示我们的Order事件订阅，参数一为点餐人，参数二为点餐的参数/事件参数，菜的名字和大小份（所以赶紧在下面声明这两个字段）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OrderEventHandler</span>(<span class="params">Customer customer, OrderEventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改OrderEventArgs和Customer类访问级别为public，是为了和delegate三者配合使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> DishName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//菜名</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//菜的大小份</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> OrderEventHandler Order; <span class="comment">//Order事件的简略声明</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Bill &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//需要付的款</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PayTheBill</span>() <span class="comment">//付款动作</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I will pay $&#123;0&#125;&quot;</span>, <span class="keyword">this</span>.Bill);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于触发事件，走路坐下点餐</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WalkIn</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Walk into the restaurant&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SitDown</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Sit Down!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Think</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Let me think...&quot;</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.Order != <span class="literal">null</span>) <span class="comment">//如果订阅器不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                OrderEventArgs e = <span class="keyword">new</span> OrderEventArgs();</span><br><span class="line">                e.DishName = <span class="string">&quot;KongPao Chicken&quot;</span>;</span><br><span class="line">                e.Size = <span class="string">&quot;large&quot;</span>;</span><br><span class="line">                <span class="keyword">this</span>.Order.Invoke(<span class="keyword">this</span>, e); <span class="comment">//this即顾客点餐，e则交代菜名和大小份</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>() <span class="comment">//封装顾客的三个动作</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.ReadLine(); <span class="comment">//让程序等待我们按回车，顾客再进去</span></span><br><span class="line">            <span class="keyword">this</span>.WalkIn();</span><br><span class="line">            <span class="keyword">this</span>.SitDown();</span><br><span class="line">            <span class="keyword">this</span>.Think();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Waiter</span>  <span class="comment">//事件的响应者waiter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Serve</span>(<span class="params">Customer customer, OrderEventArgs e</span>) </span></span><br><span class="line"><span class="function">            <span class="comment">//自动生成的Serve方法需改为public访问性</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I will serve you the dish: &#123;0&#125;&quot;</span>, e.DishName);</span><br><span class="line">            <span class="built_in">double</span> price = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">switch</span> (e.Size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;small&quot;</span>:</span><br><span class="line">                    price *= <span class="number">0.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;large&quot;</span>:</span><br><span class="line">                    price *= <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            customer.Bill += price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么事件真的变成字段？我们反编译进行论证！这里去查看第22个视频的33分钟</p><h2 id="深入理解事件">深入理解事件</h2><blockquote><p>有了委托字段/属性，为什么还需要事件</p></blockquote><p>为了程序的逻辑更加“有道理”、更加安全，谨防“借刀杀人”</p><p>我们把上面的简略声明public event OrderEventHandler Order;中的event关键字删除，发现程序仍可以运行，并且结果一样</p><p>但是此时发现，在主函数内，即使我们不使用顾客亲自点餐，也能实现点餐</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171706076.png" alt="image-20220317170647859"></p><p>编译结果为</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171708284.png" alt="image-20220317170800111"></p><p>发现还是被badGay点餐成功</p><p>我们此时加上event，报错，发现事件很好地杜绝这个Bug</p><blockquote><p>事件的本质是委托类型字段的包装器</p></blockquote><p>从上面我们的增减event关键字，我们可以看出本质上事件是为了包装委托字段，没有event程序还是能运行，但是加上之后会更安全，能够防止Bug</p><ul><li>包装器对委托字段的访问起限制作用，本质是加装在委托字段上的一个“蒙板Mask”，是起隐蔽作用的包装器，用于阻挡非法操作</li><li>封装（encapsulation）重要功能就是隐藏</li><li>封装对外界隐藏委托实例的大部分功能，仅暴露添加/移除事件处理器的功能</li></ul><blockquote><p>用于声明事件的委托类型的命名约定（前面有提及）</p></blockquote><ol><li>用于声明Foo事件的委托，一般命名为FooEventHandler（除非是非常通用的事件约束）</li><li>FooEventHandler委托的参数一般有两个（由Win32 API演化而来，历史悠久）<ul><li>object类型，名字为sender，表示事件的拥有者、事件的source</li><li>EventArgs类的派生类，类名一般为FooEventArgs，参数名为e。即前面的事件参数</li><li>虽然没有官方说法，但我们可以把委托的参数列表当作是事件发生后发送给事件响应者的“事件消息”</li></ul></li><li>触发Foo事件的方法一般命名为OnFoo，即“因何引发”、“事出有因”<ul><li>访问级别为protected，不能为public，不然又会出现“借刀杀人”的bug</li></ul></li></ol><blockquote><p>事件的命名约定</p></blockquote><ul><li>带有时态的动词或者动词短语</li><li>事件拥有者“正在做”什么事情，用进行时；事件拥有者“做完了”什么事情，用完成时</li></ul><h2 id="关于事件的讨论">关于事件的讨论</h2><blockquote><p>事件是“以特殊方式声明的委托字段/实例”❌</p></blockquote><ul><li>只是看起来像（对比委托字段和事件的简略声明，只是像官方说的field-like），不过是语法糖</li><li>事件声明的时候使用的了委托类型，简化声明造成事件看上去像一个委托的字段（实例），而event关键字则更像是一个修饰符（错觉的来源之一）</li><li>订阅事件的时候+=操作符后面可以是一个委托实例，这与委托实例的赋值方法语法相同，这也让事件看起来像是委托字段（错觉的来源之二）</li></ul><blockquote><p>为什么要用委托类型来声明事件</p></blockquote><ul><li>站在source的角度来看，是为了表明source能对外传递哪些信息</li><li>站在subscriber的角度来看，它是一个约定，是为了约束能够使用什么样签名的方法来处理（响应）事件</li><li>委托类型的实例将用于存储（引用）事件处理器</li></ul><blockquote><p>对比事件与属性</p></blockquote><ul><li>属性不是字段（很多时候，属性是字段的包装器，用于保护字段不被滥用）</li><li>事件不是委托字段（它是委托字段的包装器，用于保护委托字段不被滥用）</li><li>包装器永远都不能是被包装的东西（那么会影响性能）</li></ul><hr><h1>第十二章 类</h1><h2 id="类是什么">类是什么</h2><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203171957878.png" alt="image-20220317195702040"></p><p>类是一种抽象的数据结构（data structure）</p><p>类是一种数据类型</p><p>类代表现实世界中的“种类”</p><h2 id="构造器与析构器">构造器与析构器</h2><p>看到C++代码，在声明类时，需要提前声明很多类的格式，有重载，还有默认构造器和回调函数。也就是我们这里说的</p><p>其中，必须得有一个默认构造器比如Student类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class Student&#123;</span><br><span class="line">    <span class="built_in">stduent</span>(<span class="type">int</span> a,string b);<span class="comment">//重载的一个构造器</span></span><br><span class="line">    <span class="built_in">student</span>();<span class="comment">//默认构造器</span></span><br><span class="line">    -<span class="built_in">student</span>();<span class="comment">//C++回调函数</span></span><br><span class="line">    <span class="comment">//字段</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器">构造器</h3><h4 id="实例构造器">实例构造器</h4><p>看到C++代码，在声明类时，需要提前声明很多类的格式，有重载，还有就是我们这里提到得</p><p>其中，必须得有一个默认构造器比如Student类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Student&#123;</span><br><span class="line">    <span class="built_in">stduent</span>(<span class="type">int</span> a,string b);<span class="comment">//重载的一个构造器</span></span><br><span class="line">    <span class="built_in">student</span>();<span class="comment">//默认构造器</span></span><br><span class="line">    -<span class="built_in">student</span>();<span class="comment">//C++回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C#里，当我们创建类的时候，如果没写构造器，那构造器是默认创建了</p><blockquote><p>当我们编写构造器后，则会使用我们创建的构造器，而不会创建默认构造器</p></blockquote><p>示例：构造器里使用this代表这个实例，<a href="http://xn--this-f96g315giy6ccjd.ID">比如这里this.ID</a>,表示实例的ID为构造时输入的id值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>) <span class="comment">//实例构造器</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实例在被构造时，可被赋的值</span></span><br><span class="line">    <span class="keyword">this</span>.ID = id;</span><br><span class="line">    <span class="keyword">this</span>.Name = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造时，所做的动作</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么实例只能用new操作符创建？可以使用反射</p></blockquote><h4 id="实例化-反射">实例化-反射</h4><p>使用上面例子，使用<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.activator?view=netframework-4.8#methods">Activator类</a>的CreateInstance方法实现</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*反射机制*/</span></span><br><span class="line">        Type t = <span class="keyword">typeof</span>(Student); <span class="comment">//将Student这个类型，存储在类型类（Type类）中</span></span><br><span class="line">        <span class="comment">//t stu = new t(); 这个是不行的</span></span><br><span class="line">        <span class="built_in">object</span> o = Activator.CreateInstance(t,<span class="number">1</span>,<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">        <span class="comment">//创建的类型都是object类型的</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(o.GetType().Name);</span><br><span class="line">        Console.WriteLine(o <span class="keyword">is</span> Student);</span><br><span class="line">        Student stu = (Student)o;</span><br><span class="line">        <span class="comment">//或者使用Student stu = o as Student;实现类型转换</span></span><br><span class="line">        stu.Report();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>) <span class="comment">//实例构造器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//实例在被构造时，可被赋的值</span></span><br><span class="line">        <span class="keyword">this</span>.ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造时，所做的动作</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Report</span>() <span class="comment">//Report方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I&#x27;m &#123;0&#125;.My ID is &#123;1&#125;&quot;</span>, ID, Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：dynamic编程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*dynamic编程*/</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Student); <span class="comment">//将Student这个类型，存储在类型类（Type类）中</span></span><br><span class="line"><span class="built_in">dynamic</span> stu = Activator.CreateInstance(t, <span class="number">1</span>, <span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">Console.WriteLine(stu.Name);</span><br></pre></td></tr></table></figure><h4 id="静态构造器">静态构造器</h4><blockquote><p>静态与实例对应，实例是指属于类中的某个对象，而静态对应的就是这个类整体</p></blockquote><p>示例：创建静态字段，表示班级同学的数量，并静态构造器中赋值0，表示构造Student类后，班级默认值就是0</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Student.Amount); <span class="comment">//输出当前班级人数</span></span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">&quot;LiHua&quot;</span>);</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">&quot;XiaoMing&quot;</span>); <span class="comment">//创建两名学生</span></span><br><span class="line">        Console.WriteLine(Student.Amount); <span class="comment">//输出当前学生数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Amount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Student</span>() <span class="comment">//静态构造器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Amount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>) <span class="comment">//实例构造器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        Amount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构器（析构函数）">析构器（析构函数）</h3><blockquote><p>析构器是不分实例和静态的</p></blockquote><p>类似于C++的回调函数，当对象的变量没被访问后，则垃圾回收机制会回收这块垃圾内存，收回过程中，想做些事则需要在析构器中。托管类编程语言都有这功能，而非托管类编程语言没有这个功能，则会发生内存泄漏（和栈溢出不同）</p><p>示例：垃圾回收期间，输出正在释放系统内存</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//输出当前班级人数</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;当前学生人数为: &#123;0&#125;&quot;</span>, Student.Amount); </span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">&quot;LiHua&quot;</span>);</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">&quot;XiaoMing&quot;</span>); <span class="comment">//创建两名学生</span></span><br><span class="line">        <span class="comment">//输出当前班级人数</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;当前学生人数为: &#123;0&#125;&quot;</span>, Student.Amount); </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;........学生开始自我介绍......&quot;</span>);</span><br><span class="line">        stu1.Report();</span><br><span class="line">        stu2.Report();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;.......学生开始下讲台.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Amount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Student</span>() <span class="comment">//静态构造器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Amount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>) <span class="comment">//实例构造器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        <span class="comment">//构造时，所做的动作</span></span><br><span class="line">        Amount++;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Add a new friend：&#123;0&#125;&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Student() <span class="comment">//析构器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//回收过程中所做的动作</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;某学生下讲台了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Report</span>() <span class="comment">//Report方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I&#x27;m &#123;0&#125;. My ID is &#123;1&#125;&quot;</span>, ID, Name);</span><br><span class="line">        <span class="comment">//或者填入this.ID/this.Name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203191723658.png" alt="image-20220319172309396"></p><p>表示在使用new操作符构造实例时，会运行实例构造器中块语句；然后在运行完调用的方法后，运行垃圾回收机制，此时使用析构器，执行析构器中块语句，并且每个实例都会执行一次，而不是按照类去执行。</p><p>具体可参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/basic-concepts#automatic-memory-management">自动内存管理</a></p><h2 id="类的声明（定义）">类的声明（定义）</h2><p>注意的是，在C#和Java内，声明即是定义；C++和C的声明和定义是不同概念，是分开的，有兴趣可以看刘的视频</p><h3 id="类声明的位置">类声明的位置</h3><blockquote><p>还是我们之前位置常用</p></blockquote><ul><li>名称空间namespace内（正常位置）</li><li>显式地放在名称空间并列的地方（实质上是声明在global名称空间中） 不推荐</li><li>类class内（即声明成员类，就是以类为成员）</li></ul><h3 id="类声明的方法">类声明的方法</h3><blockquote><p>格式：可选的<strong>特性</strong> + <strong>类修饰符</strong> + 可选的 <code>partial</code> + <code>class</code> + <strong>类的标识符</strong>（类名使用驼峰法） + 可选的<strong>类型参数</strong> + 可选的<strong>基类规范</strong> +  可选的类型参数约束集 + <strong>类体</strong> + 可选的 <code>;</code></p></blockquote><p>不能省略的就是类修饰符+class+类体，也是最普遍的使用方法（即使是MVC框架，这种形式也是主体）</p><p>类修饰符有new、public、protected、internal、private、abstract、sealed、static和不安全的类修饰符。类修饰符是可以分组的，每组可以挑出其中一个写入代码，而不是随便挑一个，而是各组可选择挑选一个</p><p>按继承关系：abstract、sealed</p><p>按类的访问级别：public、internal</p><p>按成员类的访问性：public、internal、private、protected</p><p>等等</p><blockquote><p>这里我们只讲解类的访问级别（public和internal）</p></blockquote><p>可以试着一个解决方案中创建两个项目，尝试更换关键字</p><p>如果需要引用其他文件夹内的名称空间中的类，需要在<strong>类前添加public</strong>才能使类暴露，可以在同一个解决方案中添加类库项目，然后<strong>添加引用</strong></p><blockquote><p>public代表别的项目可以看到/调用，internal是在该项目中能看到/调用的</p></blockquote><p>每个项目编译后都是一个装配集（assembly），可以生成后查看编译结果。如何去配置？进入属性Properties里</p><p>而private是在声明成员类的时候才有可能出现</p><p>类的成员前面的访问权限还得等学完基类</p><h2 id="类的三大特性：封装、类的继承（派生）、多态">类的三大特性：封装、类的继承（派生）、多态</h2><h3 id="类的继承">类的继承</h3><p>类继承是类在功能上的扩展（extend）</p><blockquote><p>注意名称的对比</p></blockquote><p>基类baseclass和派生类DerivedClass</p><p>父类parentclass和子类childclass/sonclass</p><h4 id="类继承语法">类继承语法</h4><p>实例：继承的表现（代码和程序两个方法验证）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//程序验证继承关系</span></span><br><span class="line">        Type t = <span class="keyword">typeof</span>(Car);</span><br><span class="line">        Type tb = t.BaseType; <span class="comment">//基类（(往上找父类)）</span></span><br><span class="line">        Console.WriteLine(tb.FullName); <span class="comment">//输出ConsoleApp.Vehicle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span> <span class="comment">//作为基类（父类）</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span>  <span class="comment">//作为派生类，Car继承自Vehicle（代码上的继承关系）</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所有类都是从基类Object显式或者隐式派生出来的</p></blockquote><p>示例：验证object是所有类的继承链顶端</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//程序验证继承关系</span></span><br><span class="line">        Type t = <span class="keyword">typeof</span>(Car);</span><br><span class="line">        Type tb = t.BaseType; <span class="comment">//基类</span></span><br><span class="line">        Type tTop = tb.BaseType;</span><br><span class="line">        Console.WriteLine(tTop.FullName); <span class="comment">//输出System.Object</span></span><br><span class="line">        Console.WriteLine(tTop.BaseType==<span class="literal">null</span>); <span class="comment">//输出True</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span> <span class="comment">//作为基类</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span>  <span class="comment">//作为派生类，Car继承自Vehicle（代码上的继承关系）</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“是一个 is a”概念，一个派生类的实例也是基类的实例。（抽象出来的布尔代数量，韦式图的感觉）比如某一辆汽车Car也是一种交通工具</p></blockquote><p>示例：is操作符来验证“是一个”概念</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        Console.WriteLine(car <span class="keyword">is</span> Vehicle); <span class="comment">//car是一个Vehicle嘛？True</span></span><br><span class="line">        Console.WriteLine(car <span class="keyword">is</span> Object); <span class="comment">//True</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span> </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据“是一个概念”，我们可以这样声明变量：用父类类型的变量来引用子类的实例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vehicle car = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure><h3 id="小知识点">小知识点</h3><ol><li>类前面加sealed关键字就是封闭类，无法从封闭类派生新类</li></ol><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203231101191.png" alt="image-20220323105659194"></p><ol start="2"><li>只能有一个基类，但可以实现多个其接口（接口后面讲）。在论述的时候，可以说，派生自某个基类，某类实现了某个基接口</li><li>子类的访问级别不能超过父类，可以一致但是不能超过</li></ol><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203231100928.png" alt="image-20220323110026673"></p><h3 id="继承的本质">继承的本质</h3><blockquote><p>派生类在基类已有的成员的基础上，对基类进行横向和纵向上的扩展</p></blockquote><p>如何理解？</p><p>派生类<strong>基于基类已有的成员</strong>：子类对父类的成员是全盘接受（继承）。但是注意一些特殊情况还是不被继承（比如后面讲的实例构造器）</p><p>派生的过程中，我们进行的是<strong>扩展</strong>，类成员只可能越来越多，添加成员是可以，但是无法减少成员。于是出现一个现象：一个类成员引入到继承链中，会被一直向下传递，无法被删除，所以得谨慎添加，防止被污染（静态语言，如C++，Java，C#等），一些动态语言（Python和JavaScript）则可以随时删减某个类成员的继承</p><p><strong>横向和纵向</strong>：横向指的是类成员在数量上的扩充（变胖了）；纵向指的是不增加类成员的个数，但是对某个类成员的版本进行扩充（即后面会讲的重写override）</p><p>示例：验证上述的理解</p><blockquote><p>在已有成员基础上的扩展</p></blockquote><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203231115965.png" alt="image-20220323111553797"></p><p>那么一定也继承了隐式基类object</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203231116093.png" alt="image-20220323111654923"></p><p>按F12进入object类的定义，按Ctrl加-号就能立马回去</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203231118147.png" alt="image-20220323111816976"></p><blockquote><p>横向和纵向上的扩展</p></blockquote><p>示例：使用断点，发现当我们创建实例时，是从基类构造器开始执行，再沿着继承链往下构造</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        Console.WriteLine(car.Owner); <span class="comment">//输出CarOwner</span></span><br><span class="line">        car.ShowOwner(); <span class="comment">//输出CarOwner</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Owner&#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Owner = <span class="string">&quot;N/A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Owner = <span class="string">&quot;CarOwner&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowOwner</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">base</span>.Owner);</span><br><span class="line">        <span class="comment">//访问上一层的父类对象（成员），实例的上一层对象就是Car,这里base=this</span></span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.Owner); <span class="comment">//这里三个都是可以的</span></span><br><span class="line">        Console.WriteLine(Owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当基类的实例构造器和派生类的构造器不匹配的时候，会报错（创建派生类Car的构造器时，它会调用基类的构造器，但是如果我们选择不创建默认构造器而是自己创建构造器，如果参数列表不对应就会报错）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203231132560.png" alt="image-20220323113205382"></p><p>如何解决？</p><p>方法一：调Vehicle构造器时候，传入参数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Owner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span>(<span class="params"><span class="built_in">string</span> owner</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>() : <span class="title">base</span>(<span class="params"><span class="string">&quot;N/A&quot;</span></span>) <span class="comment">//给基础的父类构造器赋值</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Owner = <span class="string">&quot;CarOwner&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：给Car类的构造器也添加参数（因为父类的实例构造器是无法被继承的）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car(<span class="string">&quot;Visen&quot;</span>);</span><br><span class="line">        Console.WriteLine(car.Owner); <span class="comment">//输出Visen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Owner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span>(<span class="params"><span class="built_in">string</span> owner</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> owner</span>) : <span class="title">base</span>(<span class="params">owner</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类成员的访问">类成员的访问</h3><p>继承对类成员的影响，参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/basic-concepts#member-access">成员访问</a></p><p>这里以实操为主。创建两个项目，主项目（console）和副项目（类库），主项目对副项目进行引用，为了使项目调用距离最大</p><blockquote><p>类成员的访问级别是以类的访问级别作为上限</p></blockquote><p>这个很容易验证，就不展示</p><blockquote><p>考虑访问级别的时候，范围可以设置为程序集（程序）、类、方法体</p></blockquote><blockquote><p>public指的是全开放，访问不受限制；internal是限制在同一个程序集（此程序）内；private是限制在类体内，这也是默认的访问级别（即使继承也仍然无法访问），这里推荐即使是默认仍然写上，保持整齐；</p></blockquote><p>示例：private私有字段只能在类体内（不能直接访问），但是可以通过属性对外暴露</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyLib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _rpm; <span class="comment">//私有字段加下划线开头，是C++、Java玩家涌入的结果</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>() <span class="comment">//车辆加速</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            _rpm += <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _rpm/<span class="number">100</span>; &#125; &#125; <span class="comment">//通过只读属性对外暴露数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Car car = <span class="keyword">new</span> Car();</span><br><span class="line">            car.Accelerate();</span><br><span class="line">            car.Accelerate();</span><br><span class="line">            Console.WriteLine(car.Speed);  <span class="comment">//输出20</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>protected（常用于方法的修饰）访问限制在此程序或派生类（非子类无法使用）</p><p>（访问权限就是暴露的范围，public是全开放，internal是此程序，private是此类体，protected是此程序或者派生类，就像你的心里秘密等级）</p></blockquote><p>示例：添加燃油过程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _rpm;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _fuel = <span class="number">100</span>; <span class="comment">//燃油</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Burn</span>(<span class="params"><span class="built_in">int</span> fuel</span>) <span class="comment">//烧油</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _fuel -=fuel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>() <span class="comment">//加速</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Burn(<span class="number">1</span>);</span><br><span class="line">        _rpm += <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _rpm/<span class="number">100</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于用户来说，用户是可以访问到燃油这个方法和属性的，虽然不调用就没事，但是留了这个漏洞，可能会被其他开发人员调用，引发Bug。这时候需要使用protected设定访问级别</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> _rpm; <span class="comment">//使用protected为了让下面的car类能够调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _fuel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Burn</span>(<span class="params"><span class="built_in">int</span> fuel</span>) <span class="comment">//使用protected为了让下面的car类能够调用</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _fuel -=fuel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>() <span class="comment">//普通加速</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Burn(<span class="number">1</span>);</span><br><span class="line">        _rpm += <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _rpm / <span class="number">100</span>; &#125; &#125; <span class="comment">//输出当前速度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurboAccelerate</span>() <span class="comment">//涡轮增压加速</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Burn(<span class="number">2</span>);</span><br><span class="line">        _rpm += <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Car类即使写在另外一个项目程序中，仍然可以成功</p><blockquote><p>注意，命名空间是隐式的public</p></blockquote><h3 id="面向对象的实现风格">面向对象的实现风格</h3><p>封装、继承、多态的实现是由两种实现风格的</p><p>Class-based基于类，如C++、Java（主流）</p><p>Prototype-based基于原型，如JavaScript</p><h2 id="重写与多态">重写与多态</h2><p>这一讲仍然是继承，上面讲的是父类的扩展，现在讲主要是讲成员版本的增加（纵向扩展），而这里的重写说的就是把某个成员写几个版本，每个版本都能够使用</p><p><strong>类的继承</strong></p><ul><li>类成员的横向扩展（增加成员）</li><li>类成员的纵向扩展（行为改变，版本提高）</li><li>类成员的隐藏（不常见）</li><li>重写与隐藏的发生条件：函数成员（<strong>属性</strong>、<strong>方法</strong>、事件、索引器等），可见（成员的访问级别，父类里成员为public、protected）、签名一致</li></ul><p>下面以方法成员为例</p><h3 id="重写（override）">重写（override）</h3><h4 id="隐藏Hide">隐藏Hide</h4><p>下面的写法是可以实现一定的，这里Car类其实是有两个Run方法的版本，一个是自己this的，一个是父类base的</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203231744093.png" alt="image-20220323174400920"></p><p>完整代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.Run(); <span class="comment">//输出I&#x27;m Running!</span></span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.Run(); <span class="comment">//输出Car is Running</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I&#x27;m Running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Car is Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们想要实现Car内只有一个版本，而没有继承自父类的版本，如何实现？</p><p>Java中是没有隐藏的，而是天然重写，按照上面的写法就能实现重写</p><h4 id="重写">重写</h4><blockquote><p>父类中方法加上<code>virtual</code>关键字[声明为虚（名存实亡）成员]，子类的重写方法加上 <code>override</code></p></blockquote><p>示例：在Car类中对Vehicle进行重写</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203231732518.png" alt="image-20220323173212330"></p><p>完整代码：只要变量中存储的是子类的实例，那么调用的就是子类的重写Run方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Car car = <span class="keyword">new</span> Car();</span><br><span class="line">    car.Run(); <span class="comment">//输出Car is Running</span></span><br><span class="line">    Vehicle v = <span class="keyword">new</span> Car(); <span class="comment">//实例仍然是Car的实例</span></span><br><span class="line">    v.Run(); <span class="comment">//输出Car is Running</span></span><br><span class="line">    Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">    vehicle.Run(); <span class="comment">//输出I&#x27;m Running!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()  <span class="comment">//声明为虚（名存实亡）成员</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I&#x27;m Running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Car is Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态（polymorphism）">多态（polymorphism）</h3><blockquote><p>多态是基于重写机制的（Virtual——&gt;override）</p></blockquote><h4 id="隐藏Hide会干扰调用的判断">隐藏Hide会干扰调用的判断</h4><blockquote><p>当我们调用某成员时，调用的是实例的最新版本（和实例类型对应）</p></blockquote><p>示例：隐藏Hide对示例的最新版本判断的干扰</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.Run(); <span class="comment">//输出I&#x27;m Running!</span></span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.Run(); <span class="comment">//输出Car is Running</span></span><br><span class="line">        Vehicle raceCar = <span class="keyword">new</span> RaceCar();</span><br><span class="line">        raceCar.Run(); <span class="comment">//输出Car is Running</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I&#x27;m Running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Car is Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">RaceCar</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在这里实际上是有了隐藏的Car的Run重写方法和下面的Run方法</span></span><br><span class="line">    <span class="comment">//比较后，程序优先选择了那个重写方法</span></span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;RaceCar is Running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之所以能够看到多态，是因为C#的变量和对象是有类型的，存在代差</p></blockquote><p>基类类型的变量可以引用子类类型的实例（“是一个”概念）</p><p>而对比Python，它的对象是有类型，但是变量是没有类型的，于是它的多态并不明显</p><hr><h1>第十三章 接口和SOLID设计原则</h1><p>参考<a href="https://zhuanlan.zhihu.com/p/128145128">23种设计模式</a>、<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/reflection-and-codedom/">动态编程</a></p><p>在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。</p><p>描述接口和抽象类的不同，是面试必考的，也是为了好测试和维护。两者都是**“软件工程产物”**</p><p>具体类——&gt;抽象类——&gt;接口是我们的过渡阶段，其概念越来越抽象，内部实现的东西越来越少，这里我们把接口和设计模式六大原则一起讲</p><h2 id="SOLID设计原则">SOLID设计原则</h2><p>SOLID（面向对象设计）是五个设计原则的缩写</p><p>S：The Single-Responsibility Principle (SRP)单一职责原则<br>O：The Open/Closed Principle (OCP)开放封闭原则<br>L：The Liskov Substitution Principle (LSP)里氏替换原则<br>I：The Interface Segregation Principle (ISP)接口隔离原则（ISP）<br>D：The Dependency-Inversion Principle (DIP)依赖倒置原则（DIP）</p><h2 id="为做基类而生的抽象类">为做基类而生的抽象类</h2><blockquote><p>抽象类是未完全实现逻辑的类</p></blockquote><p>示例：先声明抽象方法（没有方法体，没有逻辑实现），这时候因为包含有抽象成员，则该类需要用 <code>abstract</code>关键字修饰</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Run</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么可以有其他成员吗？</p><blockquote><p>至少有一个<code>abstract</code>修饰的函数成员，但是可以有字段和非public成员，用它们去实现“具体逻辑”</p></blockquote><p><strong>那么抽象类造成哪些现象？</strong></p><blockquote><p>抽象类的函数成员<strong>不能是private</strong>，但是可以是<strong>public、interal、protected</strong></p></blockquote><p>因为一般都是抽象类的子类去实现函数成员，而使用private则对子类无法可见</p><blockquote><p>抽象类为复用而生：专门作为基类来使用，也具有解耦功能(后续会讲)</p></blockquote><p><strong>抽象类含有逻辑未实现的成员，不允许实例化，但是可作为基类用于派生，使用时声明变量，引用子类（具体类concrete class）的实例</strong>。抽象类中有未被实现的函数成员，此时编译器无法判断则不允许实例化</p><p>扩展：抽象方法和virtual方法类似，又被称为”纯虚方法（C++）“</p><h2 id="开放-关闭原则OCP">开放/关闭原则OCP</h2><blockquote><p>封装确定的，开放不确定的，推迟到合适的子类中去实现</p></blockquote><p>示例：实现Vehicle基类下的Car类和Truck类，能够对应输出Run方法</p><p>如果使用的是老方法，把共同方法写在基类，然后通过参数进行选择，则违反了开闭原则（开放了基类的修改权限）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vehicle v1 = <span class="keyword">new</span> Car();</span><br><span class="line">        v1.Run(<span class="string">&quot;car&quot;</span>); <span class="comment">//输出car is running!</span></span><br><span class="line">        Vehicle v2 = <span class="keyword">new</span> Truck();</span><br><span class="line">        v2.Run(<span class="string">&quot;truck&quot;</span>); <span class="comment">//输出truck is running!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span> <span class="comment">//但是在这个类中操作时候，比如修bug和加代码，会打开这个类，更改基类需要是关闭的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Stopped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="built_in">string</span> vehicleType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vehicleType == <span class="string">&quot;car&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;car is running!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vehicleType ==<span class="string">&quot;truck&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;truck is running!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Truck</span> :<span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，需要使用抽象类来遵守开闭原则</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Vehicle v0 = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        v0.Run(); <span class="comment">//输出vehicle is running!</span></span><br><span class="line">        Vehicle v1 = <span class="keyword">new</span> Car();</span><br><span class="line">        v1.Run(); <span class="comment">//输出car is running!</span></span><br><span class="line">        Vehicle v2 = <span class="keyword">new</span> Truck();</span><br><span class="line">        v2.Run(); <span class="comment">//输出truck is running!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Stopped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;vehicle is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;car is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;truck is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是我们发现，上面的Vehicle类中的Run方法中的逻辑其实并不重要，虽可以执行，但是在程序中事实上为了安全（开闭原则）或者逻辑清晰（Vehicle太模糊）永远也不会去使用，所以我们一般删除Run方法的逻辑，即删除方法体，自然而然就变成了抽象类</p><p>改成：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意Vehicle这时候不能实例化</span></span><br><span class="line">        Vehicle v1 = <span class="keyword">new</span> Car();</span><br><span class="line">        v1.Run(); <span class="comment">//输出car is running!</span></span><br><span class="line">        Vehicle v2 = <span class="keyword">new</span> Truck();</span><br><span class="line">        v2.Run(); <span class="comment">//输出truck is running!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Vehicle</span> <span class="comment">//Vehicle改成抽象类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Stopped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Run</span>()</span>; <span class="comment">//Run方法改成抽象方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;car is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;truck is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再一次证明了抽象类的用途，就是为了复用而生，专门作为基类，供其他派生类调用</p><p>那么我们可以看到抽象类的用途还是蛮明确而且大的</p><p>那有没有一个抽象类所有成员都是抽象的？</p><p>当然有</p><p>示例：使用纯粹的抽象VehicleBase类作为Vehicle类的基类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vehicle v1 = <span class="keyword">new</span> Car();</span><br><span class="line">        v1.Run(); <span class="comment">//输出car is running!</span></span><br><span class="line">        Vehicle v2 = <span class="keyword">new</span> Truck();</span><br><span class="line">        v2.Run(); <span class="comment">//输出truck is running!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">VehicleBase</span> <span class="comment">//这个就是纯抽象（虚）类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Vehicle</span> : <span class="title">VehicleBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Stop</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Stopped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>() <span class="comment">//使用重写方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;car is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>() <span class="comment">//使用重写方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;truck is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种纯抽象类在C++、Java里是这样的，但是我们C#对他进行了更改，改名为接口</p><h2 id="接口">接口</h2><h3 id="接口概念">接口概念</h3><blockquote><p>接口是完全来实现逻辑的“类”，也就是C++的“纯虚类”；其中<strong>只有public</strong>函数成员</p></blockquote><p>对于上面的纯虚类，怎么改变成符合C#风格的接口？</p><p>示例：类实现接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vehicle v1 = <span class="keyword">new</span> Car();</span><br><span class="line">        v1.Run(); <span class="comment">//输出car is running!</span></span><br><span class="line">        Vehicle v2 = <span class="keyword">new</span> Truck();</span><br><span class="line">        v2.Run(); <span class="comment">//输出truck is running!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IVehicleBase</span> <span class="comment">//接口包含了纯虚类的含义，必须去掉之前的abstract</span></span><br><span class="line">                       <span class="comment">//接口名常常是以I开头</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Vehicle</span> : <span class="title">VehicleBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//接口有点像方法的声明，后续使用类实现我们的纯虚方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>()  <span class="comment">//既然是实现，则需要去掉override</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Stopped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span>; <span class="comment">//抽象类作为不完全的实现（未实现逻辑的成员）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;car is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;truck is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这一条思路下来，我们可以知道</p><blockquote><p>接口和抽象类其实是”软件工程的必然产物“，是对具体类这个工具的逐步改进</p></blockquote><h3 id="接口的理解">接口的理解</h3><blockquote><p>接口的本质是一个“协约”（甲乙双方合作对接的标准-业界标准），为了代码更加简洁、高效</p></blockquote><p>示例：计算不同类型的集合中数的总和以及平均值</p><p>如果按照以前的方法，使用重载(让编译器自己决策)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] nums1 =<span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">            ArrayList nums2 = <span class="keyword">new</span> ArrayList()&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">            Console.WriteLine(Sum(nums1)); <span class="comment">//输出15</span></span><br><span class="line">            Console.WriteLine(Avg(nums1)); <span class="comment">//输出3</span></span><br><span class="line">            Console.WriteLine(Sum(nums2)); <span class="comment">//输出21</span></span><br><span class="line">            Console.WriteLine(Avg(nums2)); <span class="comment">//输出3.5</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span>[] nums</span>) <span class="comment">//计算int[]类型总和</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> nums)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Avg</span>(<span class="params"><span class="built_in">int</span>[] nums</span>) <span class="comment">//计算int[]类型平均值</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">double</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> n <span class="keyword">in</span> nums)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += n;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum / count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params">ArrayList nums</span>) <span class="comment">//计算ArrayList类型总和</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> nums)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (<span class="built_in">int</span>)i;<span class="comment">//需要强制类型转换</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Avg</span>(<span class="params">ArrayList nums</span>) <span class="comment">//计算Array[]类型平均值</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">double</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> n <span class="keyword">in</span> nums)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (<span class="built_in">int</span>)n;<span class="comment">//需要强制类型转换</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum / count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们现在可以使用接口简化这个功能</p><p>首先需要对接口的供需双方进行界定：</p><ol><li>甲方：提供数据nums1和nums2（接纳要求，保证能迭代）</li><li>乙方：得到总和和平均值（提出要求：甲方的数据需要能够迭代，即实现IEnumerable接口）</li></ol><p>根据这个要求，我们可以利用”协议“——接口去实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] nums1 =<span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">            ArrayList nums2 = <span class="keyword">new</span> ArrayList()&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">            Console.WriteLine(Sum(nums1)); <span class="comment">//输出15</span></span><br><span class="line">            Console.WriteLine(Avg(nums1)); <span class="comment">//输出3</span></span><br><span class="line">            Console.WriteLine(Sum(nums2)); <span class="comment">//输出21</span></span><br><span class="line">            Console.WriteLine(Avg(nums2)); <span class="comment">//输出3.5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params">IEnumerable nums</span>) <span class="comment">//使用IEnumerable接口</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> nums)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (<span class="built_in">int</span>)i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Avg</span>(<span class="params">IEnumerable nums</span>) <span class="comment">//使用IEnumerable接口</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">double</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> n <span class="keyword">in</span> nums)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (<span class="built_in">int</span>)n;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum / count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用接口，我们的代码变得简洁以及高效</p><h3 id="为解耦而生的接口">为解耦而生的接口</h3><h4 id="依赖和耦合">依赖和耦合</h4><blockquote><p>A的正确性依赖于（取决于）B的正确性，那么就称为存在“耦合度”/“依赖关系”</p></blockquote><p>示例：使用汽车Car类，汽车中包含发动机Engine类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> engine = <span class="keyword">new</span> Engine();</span><br><span class="line">        <span class="keyword">var</span> car = <span class="keyword">new</span> Car(engine);</span><br><span class="line">        car.Run(<span class="number">3</span>);</span><br><span class="line">        Console.WriteLine(car.Speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Engine</span> <span class="comment">//发动机类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> RPM &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Work</span>(<span class="params"><span class="built_in">int</span> gas</span>) <span class="comment">//发动机工作，gas为油门大小</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.RPM = <span class="number">1000</span> * gas;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> <span class="comment">//汽车类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Engine _engine;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params">Engine engine</span>) <span class="comment">//汽车配备发动机</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="built_in">int</span> gas</span>) <span class="comment">//汽车移动</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _engine.Work(gas);</span><br><span class="line">        <span class="keyword">this</span>.Speed = _engine.RPM / <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是发现，这里Car类完全依赖在Engine类上的，存在”紧<strong>耦合</strong>“，即Car类的正确与否<strong>依赖于</strong>Engine类是否正确。对于大项目来说，如果存在这样的紧耦合，假如Engine类出现错误，则Car类则无法使用，开发人员的工作存在紧耦合，工作进度是由开发效率最慢的那个人决定的，这是低效的！</p><blockquote><p>接口就是为解耦而生：“高内聚（程序内各模块彼此结合紧密地负责一项任务，<strong>单一责任原则SRP</strong>），低耦合（程序之间尽可能不关联，各自实现各自的功能，<strong>开放封闭原则OCP</strong>）”，<strong>实现内紧而外松</strong></p></blockquote><p>参考<a href="https://www.cnblogs.com/corvoh/p/5747856.html">面向对象原则</a></p><p>示例：我们使用手机是不挑品牌的，是解耦的，下面用接口去反映</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> user1 = <span class="keyword">new</span> PhoneUser(<span class="keyword">new</span> NokiaPhone());<span class="comment">//用户使用诺基亚手机</span></span><br><span class="line">        user1.UsePhone();</span><br><span class="line">        <span class="comment">//这时候，诺基亚手机损坏，我们进行更换</span></span><br><span class="line">        <span class="keyword">var</span> user2 = <span class="keyword">new</span> PhoneUser(<span class="keyword">new</span> EricssonPhone());<span class="comment">//用户使用爱立信手机</span></span><br><span class="line">        user2.UsePhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">PhoneUser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Iphone _phone;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneUser</span>(<span class="params">Iphone myPhone</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _phone = myPhone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UsePhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _phone.Dail();</span><br><span class="line">        _phone.PickUp();</span><br><span class="line">        _phone.Send();</span><br><span class="line">        _phone.Receive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">Iphone</span> <span class="comment">//手机只要有这几个功能，就能满足我们的需求</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dail</span>()</span>; <span class="comment">//拨打</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PickUp</span>()</span>; <span class="comment">//接电话</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span>()</span>; <span class="comment">//发信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Receive</span>()</span>; <span class="comment">//收信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">NokiaPhone</span> : <span class="title">Iphone</span>  <span class="comment">//诺基亚是可以实现手机的那四个功能</span></span><br><span class="line">    <span class="comment">//通过快捷操作，选择实现接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dail</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Nokia is Calling...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PickUp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello!This is Tim!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Nokia Message ring...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello!...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">EricssonPhone</span> : <span class="title">Iphone</span> <span class="comment">//爱立信也是可以实现手机的那四个功能，虽然功能表现不一定一样</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dail</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Ericsson is Calling...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PickUp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello!This is Tim!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Ericsson Message ring...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Halo!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们引入接口Iphone后，PhoneUser使用哪个品牌手机都可以，只需要改下PhoneUser()方法的对应参数就可以了，实现了“松耦合”。此处利用反射可以实现不修改参数，这个后续再学</p><h2 id="依赖倒置原则-DIP-和单元测试">依赖倒置原则(DIP)和单元测试</h2><p>单元测试是依赖倒置原则在开发中的直接应用和直接受益者，所以这里放一起讲</p><blockquote><p>依赖倒置（反转）原则DIP：程序要依赖于抽象接口，不要依赖于具体实现</p></blockquote><p>目的：面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本；面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><p>当我们遇到大问题时候，我们会分解为中问题甚至是小问题</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203242121787.png" alt="image-20220324212101891"></p><p>这时候，我们是在自顶向下逐步解决问题，这也是我们自然的思考方式和套路。而依赖倒置的原则，则是为了平衡这个思考方式，使用自底向上的思考方式可能更适合解决在某情况下的一些问题</p><p>示例：下面优化的第一步就是反转箭头，实现了依赖倒置（反转），而点问号的终点就是设计模式（高级课程，可以看<a href="https://book.douban.com/subject/2243615/">Head First 设计模式（中文版）</a>、<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">菜鸟教程 设计模式</a>）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203242125916.png" alt="image-20220324212505612"></p><blockquote><p>接口的使用：自底向上（重构）、自顶向下（设计）</p></blockquote><p>下面以代码示例来讲解重构和设计：带有功率保护的电扇根据电源输入对应地改变转速，并且会显示工作状态</p><p>首先写个紧耦合（<strong>设计</strong>）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fan = <span class="keyword">new</span> DeskFan(<span class="keyword">new</span> PowerSupply());</span><br><span class="line">        Console.WriteLine(fan.Work());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">PowerSupply</span> <span class="comment">//电源</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetPower</span>() <span class="comment">//输出电源</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">DeskFan</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//紧耦合，电扇依赖电源</span></span><br><span class="line">    <span class="keyword">private</span> PowerSupply _powerSupply;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeskFan</span>(<span class="params">PowerSupply powerSupply</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _powerSupply = powerSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电扇工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Work</span>() <span class="comment">//返回工作状态</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> power =_powerSupply.GetPower();</span><br><span class="line">        <span class="keyword">if</span>(power &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Won&#x27;t work&quot;</span>; <span class="comment">//没电，无法工作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(power &lt;= <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Slow&quot;</span>; <span class="comment">//电量不足，低速工作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(power &lt;= <span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Work fine&quot;</span>; <span class="comment">//工作正常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Warning&quot;</span>; <span class="comment">//无法工作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是发现，我们如果需要测试电扇是否正常工作，需要更改电源的100为其他值</p><blockquote><p>接口是为解耦而生</p></blockquote><p>这时候我们使用接口松开耦合（<strong>重构</strong>）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fan = <span class="keyword">new</span> DeskFan(<span class="keyword">new</span> PowerSupply());</span><br><span class="line">        Console.WriteLine(fan.Work());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IPowerSupply</span> <span class="comment">//添加接口，“声明”GetPower()方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetPower</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">PowerSupply</span> : <span class="title">IPowerSupply</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetPower</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">DeskFan</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一般把下面的PowerSupply类改成接口IPowerSupply类，松开与PowerSupply的耦合</span></span><br><span class="line">    <span class="comment">//用接口（基类）来声明私有字段存放子类的实例</span></span><br><span class="line">    <span class="keyword">private</span> PowerSupply _powerSupply; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeskFan</span>(<span class="params">PowerSupply powerSupply</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _powerSupply = powerSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回工作状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Work</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> power =_powerSupply.GetPower();</span><br><span class="line">        <span class="keyword">if</span>(power &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Won&#x27;t work&quot;</span>; <span class="comment">//没电，无法工作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(power &lt;= <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Slow&quot;</span>; <span class="comment">//电量不足，低速工作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(power &lt;= <span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Work fine&quot;</span>; <span class="comment">//工作正常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Warning&quot;</span>; <span class="comment">//无法工作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给再进行单元测试，创建用来测试的类，专门设置一些边界值（在测试里）</p><ol><li><p>先把类加上public</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPowerSupply</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PowerSupply</span> : <span class="title">IPowerSupply</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeskFan</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>这时候，在解决方案中添加测试程序（xUnit测试项目），命名为待测试项目名.Tests，引用待测试项目并using，编写代码比较所需值和实际值是否吻合（这里实际上是将PowerSupply类里的GetPower()方法的每次修改写在了测试里，可以看到，运行测试程序时，该方法return的值是不影响的）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Xunit;</span><br><span class="line"><span class="keyword">using</span> ConsoleApp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp.Tests</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitTest1</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Fact</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PowerLowerThanZero_OK</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> fan =<span class="keyword">new</span> DeskFan(<span class="keyword">new</span> PowerSupplyLowerThanZero());</span><br><span class="line">            <span class="keyword">var</span> expected=<span class="string">&quot;Won&#x27;t work&quot;</span>; <span class="comment">//测试需要的值</span></span><br><span class="line">            <span class="keyword">var</span> actual = fan.Work();   <span class="comment">//实际所得的值</span></span><br><span class="line">            Assert.Equal(expected, actual); <span class="comment">//比较两个值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PowerSupplyLowerThanZero</span> : <span class="title">IPowerSupply</span> <span class="comment">//测试用的电源类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetPower</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//测试电源的设定值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>选择解决方案，右键选择运行测试，右击创建的测试项目，关联到实例，并点击运行。可以看到得出结果</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Xunit;</span><br><span class="line"><span class="keyword">using</span> ConsoleApp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp.Tests</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitTest1</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Fact</span>]  <span class="comment">//特性，我们后面讲</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PowerLowerThanZero_OK</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> fan =<span class="keyword">new</span> DeskFan(<span class="keyword">new</span> PowerSupplyLowerThanZero());</span><br><span class="line">            <span class="keyword">var</span> expected=<span class="string">&quot;Won&#x27;t work&quot;</span>; <span class="comment">//测试需要的值</span></span><br><span class="line">            <span class="keyword">var</span> actual = fan.Work();   <span class="comment">//实际所得的值</span></span><br><span class="line">            Assert.Equal(expected, actual); <span class="comment">//比较两个值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PowerSupplyLowerThanZero</span> : <span class="title">IPowerSupply</span> <span class="comment">//测试用的电源类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetPower</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//测试电源的设定值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>结果显示是正常工作的</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203251430723.png" alt="image-20220325143008405"></p><p>如果我们再添加其他测试项,输入仍然正确，测试该程序是合格的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Xunit;</span><br><span class="line"><span class="keyword">using</span> ConsoleApp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp.Tests</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitTest1</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Fact</span>]  <span class="comment">//特性，我们后面讲</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PowerLowerThanZero_OK</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> fan =<span class="keyword">new</span> DeskFan(<span class="keyword">new</span> PowerSupplyLowerThanZero());</span><br><span class="line">            <span class="keyword">var</span> expected=<span class="string">&quot;Won&#x27;t work&quot;</span>; <span class="comment">//测试需要的值</span></span><br><span class="line">            <span class="keyword">var</span> actual = fan.Work();   <span class="comment">//实际所得的值</span></span><br><span class="line">            Assert.Equal(expected, actual); <span class="comment">//比较两个值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Fact</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PowerHigherThan200_Warning</span>()<span class="comment">//200以上是否报告Warning</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> fan = <span class="keyword">new</span> DeskFan(<span class="keyword">new</span> PowerSupplyHigherThan200());</span><br><span class="line">            <span class="keyword">var</span> expected= <span class="string">&quot;Warning&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> actual = fan.Work();</span><br><span class="line">            Assert.Equal(expected , actual);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PowerSupplyLowerThanZero</span> : <span class="title">IPowerSupply</span> <span class="comment">//测试用的电源类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetPower</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//测试电源的设定值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PowerSupplyHigherThan200</span> : <span class="title">IPowerSupply</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetPower</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">201</span>; <span class="comment">//测试电源设定值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>但是发现这样是需要创建太多类，很麻烦，可以在测试项目中，通过nuget中搜索moq，安装并using。通过使用Moq.framework直接创建实现 IPowerSupply接口方法的实例，而越过创建类的步骤。</li></ol><p>代码修改为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Xunit;</span><br><span class="line"><span class="keyword">using</span> ConsoleApp;</span><br><span class="line"><span class="keyword">using</span> Moq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp.Tests</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitTest1</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Fact</span>]  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PowerLowerThanZero_OK</span>()<span class="comment">//0是否报告Warning</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> mock = <span class="keyword">new</span> Mock&lt;IPowerSupply&gt;();<span class="comment">//这里使用了泛型</span></span><br><span class="line">            mock.Setup(ps =&gt; ps.GetPower()).Returns(() =&gt; <span class="number">0</span>);<span class="comment">//这里使用了lambda表达式</span></span><br><span class="line">            <span class="keyword">var</span> fan =<span class="keyword">new</span> DeskFan(mock.Object);</span><br><span class="line">            <span class="keyword">var</span> expected=<span class="string">&quot;Won&#x27;t work&quot;</span>; <span class="comment">//测试需要的值</span></span><br><span class="line">            <span class="keyword">var</span> actual = fan.Work();   <span class="comment">//实际所得的值</span></span><br><span class="line">            Assert.Equal(expected, actual); <span class="comment">//比较两个值，应该是能通过的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Fact</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PowerHigherThan200_Warning</span>() <span class="comment">//200是否报告Warning</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> mock = <span class="keyword">new</span> Mock&lt;IPowerSupply&gt;();<span class="comment">//这里使用了泛型</span></span><br><span class="line">            mock.Setup(ps =&gt; ps.GetPower()).Returns(() =&gt; <span class="number">200</span>);<span class="comment">//这里使用了lambda表达式</span></span><br><span class="line">            <span class="keyword">var</span> fan =<span class="keyword">new</span> DeskFan(mock.Object);</span><br><span class="line">            <span class="keyword">var</span> expected= <span class="string">&quot;Warning&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> actual = fan.Work();</span><br><span class="line">            Assert.Equal(expected , actual); <span class="comment">//应该是不能通过的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是和预期一致的（200应该报告Work fine而不是Warning）</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203251551540.png" alt="image-20220325155114316"></p><p>遵守依赖倒置原则，配合接口的使用，极大地方便单元测试</p><h2 id="单一职责原则（SRP）">单一职责原则（SRP）</h2><p>就一个类而言，应该仅有一个引起它变化的原因，只有这一个职责。这样追求高内聚的目的，就是<strong>遵从单一职责原则</strong></p><blockquote><p>接口的存在就是解耦和增强内聚性，是符合单一职责原则（SRP）的，实现“高内聚，低耦合”</p></blockquote><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力</p><h2 id="接口、类的修饰符">接口、类的修饰符</h2><p>学了这么多方法，方法的修饰符应该如何去写呢？这里课程中提供下图</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203252137686.x-icon" alt="image-20220325155509058"></p><h2 id="接口隔离原则（ISP）">接口隔离原则（ISP）</h2><p>根据接口作为甲乙方协议的理论，此时要求乙方不会少给，甲方不能多要。乙方也就是实现接口的时候，都得实现完整的接口方法，这个是强制的；但是要保证甲方不能多要，是需要给程序员一些约束的，需要建立最小的接口，主要看<strong>传给调用者的函数成员有没有冗余的成员</strong>（有冗余就是胖接口）</p><blockquote><p>一个类对另外一个类的依赖性应当是建立在最小的接口上的，程序<strong>不应该依赖它不需要的接口</strong>方法（功能）</p></blockquote><p>应该把胖接口中的方法拆分，然后用多个接口替代它，每个接口服务于一个子模块，即使用多个专门的接口代替使用单个接口</p><h3 id="胖接口拆分">胖接口拆分</h3><p>示例：希望同一司机能开坦克或者开汽车在马路上，但是用不到开炮功能</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> driver =<span class="keyword">new</span> Driver(<span class="keyword">new</span> Car());</span><br><span class="line">        driver.Drive();</span><br><span class="line"><span class="comment">//var driver =new Driver(new HeavyTank());是无法实现的，得改写Driver类的成员</span></span><br><span class="line"><span class="comment">//即使实现了，也需要不断地来回修改代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Driver</span> <span class="comment">//司机</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IVehicle _vehicle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span>(<span class="params">IVehicle vehicle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _vehicle = vehicle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Drive</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _vehicle.Run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IVehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IVehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Car is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">IVehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Truck is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fire</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">LightTank</span> : <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boom!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ka ka ka&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MediumTank</span> : <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boom!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ka! ka! ka!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">HeavyTank</span> : <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boom!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ka!!! ka!!! ka!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，发现ITank是个胖接口，实质上只用到了Run。坦克的方法可以分为两个类型，一个是武器Fire，一个是车辆的特征Run，对ITank接口进行修改</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IWeapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fire</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITank</span> : <span class="title">IVehicle</span>, <span class="title">IWeapon</span> </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再次强调，可以实现多个基接口，但是只能有一个基类</p></blockquote><p>完整代码可以修改为</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此时只要把new后面的方法名更改就能更改方法</span></span><br><span class="line">            <span class="keyword">var</span> driver1= <span class="keyword">new</span> Driver(<span class="keyword">new</span> HeavyTank());</span><br><span class="line">            driver.Drive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Driver</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//这里使用IVehicle类型也是灵魂，因为这是调用时的共有的一个类，作为变量的类型是绝佳的</span></span><br><span class="line">        <span class="keyword">private</span> IVehicle _vehicle;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Driver</span>(<span class="params">IVehicle vehicle</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _vehicle = vehicle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Drive</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _vehicle.Run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IVehicle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IVehicle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Car is running!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">IVehicle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Truck is running!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IWeapon</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Fire</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">ITank</span> : <span class="title">IVehicle</span>, <span class="title">IWeapon</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">LightTank</span> : <span class="title">ITank</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Boom!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ka ka ka&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MediumTank</span> : <span class="title">ITank</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Boom!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ka! ka! ka!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">HeavyTank</span> : <span class="title">ITank</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Boom!!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ka!!! ka!!! ka!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到使用接口隔离原则的确是更优越，但是接口隔离原则和单一职责原则如果过度使用，会产生很细碎的只有一个方法的类/接口，使得类/接口的颗粒度太小。切记“过犹不及”。</p><h3 id="创建不存在的只读集合">创建不存在的只读集合</h3><p>示例：创建的集合只能被迭代，但是不能操作元素</p><p>Array和ArrayList实现了ICollection接口和IEnumerable，并且ICollection接口是实现了IEnumerable接口，这里使用ICollection接口修改之前的示例（这里蛮难的，可以看29个视频重温）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums1 =&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        ArrayList nums2 = <span class="keyword">new</span> ArrayList()&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> roc = <span class="keyword">new</span> ReadOnlyCollection(nums1); <span class="comment">//数组放入只读集合</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> n <span class="keyword">in</span> roc) <span class="comment">//输出只读集合的每个值</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(n);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(Sum(roc));<span class="comment">//输出15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params">IEnumerable nums</span>) </span></span><br><span class="line"><span class="function">        <span class="comment">//这里使用范围更大的IEnumerable是有一定考虑的</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> n <span class="keyword">in</span> nums)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (<span class="built_in">int</span>) n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ReadOnlyCollection</span> : <span class="title">IEnumerable</span> <span class="comment">//实现集合接口，创建只读集合</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] _array;  <span class="comment">//私有字段，数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadOnlyCollection</span>(<span class="params"><span class="built_in">int</span>[] array</span>) <span class="comment">//实例构造器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator(<span class="keyword">this</span>); <span class="comment">//返回下面写的Enumerator类的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enumerator</span> : <span class="title">IEnumerator</span> <span class="comment">//重新写了迭代器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> ReadOnlyCollection _collection; </span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _head;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Enumerator</span>(<span class="params">ReadOnlyCollection collection</span>) <span class="comment">//导入集合和迭代器序号</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            _collection = collection;</span><br><span class="line">            _head = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">object</span> o =_collection._array[_head]; <span class="comment">//装箱</span></span><br><span class="line">                <span class="keyword">return</span> o; <span class="comment">//返回当前元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>() <span class="comment">//元素下移</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(++_head &lt; _collection._array.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>() <span class="comment">//重置，迭代器序号变为-1</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            _head = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的显式实现">接口的显式实现</h3><p>C#的接口隔离做的更彻底，还能将隔离出来的接口隐藏，直到显式地使用这种接口类型的变量，去引用实现这个接口的具体类的实例，这个接口里的方法才能被看见和使用。参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/interfaces#explicit-interface-member-implementations">C#规范</a></p><blockquote><p>显式接口成员实现是指引用完全限定的接口成员名称的方法、属性、事件或索引器声明</p></blockquote><p>示例：杀手不太冷剧情，杀手有两个身份，明面上的暖男和隐藏的杀手</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> wk = <span class="keyword">new</span> WarmKiller();</span><br><span class="line">        wk.Kill();<span class="comment">//杀手怎么可以被发现？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title">IGentleman</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Love</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IKill</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Kill</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">WarmKiller</span> : <span class="title">IGentleman</span>, <span class="title">IKill</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Love</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I will love you forever...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Kill</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Let me kill the enemy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要IKill接口的Kill方法不想这么容易被调用时，我们应该怎么修改？采用显式实现</p><p>把WarmKiller的Kill方法改成</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IKill.Kill()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Let me kill the enemy...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，则无法轻易调用</p><p><img src="https://s2.loli.net/2022/03/25/G2qFdftsyVSC37k.png" alt="image-20220325213850859"></p><p>这时候，如果想要调用两种方法，如何使用？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IKill killer =<span class="keyword">new</span> WarmKiller();</span><br><span class="line">killer.Kill();</span><br><span class="line"><span class="keyword">var</span> wk = killer <span class="keyword">as</span> WarmKiller;</span><br><span class="line"><span class="comment">//或者var wk = (WarmKiller或者IGentleman)killer;</span></span><br><span class="line">wk.Love();</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IKill killer =<span class="keyword">new</span> WarmKiller();</span><br><span class="line">        killer.Kill();</span><br><span class="line">        <span class="keyword">var</span> wk = killer <span class="keyword">as</span> WarmKiller;</span><br><span class="line">        <span class="comment">//或者var wk = (WarmKiller或者IGentleman)killer;</span></span><br><span class="line">        wk.Love();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title">IGentleman</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Love</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IKill</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Kill</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">WarmKiller</span> : <span class="title">IGentleman</span>, <span class="title">IKill</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Love</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I will love you forever...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> IKill.Kill()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Let me kill the enemy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C#接口有隐式实现（派生类默认实现基类的接口）、显式实现（上面例子）、多接口实现（实现多个接口）</p></blockquote><h1>第十四章 反射(reflection)</h1><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/reflection">反射 C#文档</a></p><h2 id="反射的理解">反射的理解</h2><p>不是C#语言的功能，是dotnet框架的功能，也就是说有dotnet框架，使用什么语言都能使用这个框架实现的机能。</p><blockquote><p>使用反射能够动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型，然后调用其方法或访问器字段和属性</p></blockquote><p>使用new操作符必须加类型，但是使用反射创建对象时候，是不需要类型的，于是反射提供了更松的耦合</p><p>托管类型语言中反射算是托管类型对比原生的一大特色，单元测试、依赖注入、泛型编程都是基于反射机制，反射是属于底层的东西，是很重要的。虽然反射比较底层，但是平时使用没什么感觉，都是被包装好的反射，所以不需要担心难度。</p><p>程序逻辑有时候是用户已经在使用（动态期），因为在编写时（静态期），枚举用户所有操作会很臃肿，这时候需要反射，实现“以不变应万变”</p><p>在DotNet.Core环境实现，后续能直接代入Framework环境</p><p>示例：对胖接口拆分的例子修改，展示反射的直接用法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ITank tank =<span class="keyword">new</span> HeavyTank();</span><br><span class="line">        <span class="comment">/*分割线，下面不用静态类型*/</span></span><br><span class="line">        <span class="keyword">var</span> t = tank.GetType();</span><br><span class="line">        <span class="comment">//type是对静态类型的描述，这里的t是随tank的类型动态改变的</span></span><br><span class="line">        <span class="built_in">object</span> o = Activator.CreateInstance(t);</span><br><span class="line">        <span class="comment">//Activator激活器.CreateInstance能够使用默认构造函数去创建实例</span></span><br><span class="line">        MethodInfo fireMi = t.GetMethod(<span class="string">&quot;Fire&quot;</span>);</span><br><span class="line">        MethodInfo runMi = t.GetMethod(<span class="string">&quot;Run&quot;</span>);</span><br><span class="line">        fireMi.Invoke(o, <span class="literal">null</span>);</span><br><span class="line">        runMi.Invoke(o, <span class="literal">null</span>);<span class="comment">//没有参数就传入null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Driver</span> <span class="comment">//司机</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IVehicle _vehicle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span>(<span class="params">IVehicle vehicle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _vehicle = vehicle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Drive</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _vehicle.Run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IVehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IVehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Car is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">IVehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Truck is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fire</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">LightTank</span> : <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boom!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ka ka ka&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MediumTank</span> : <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boom!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ka! ka! ka!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">HeavyTank</span> : <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boom!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ka!!! ka!!! ka!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖注入（DI）">依赖注入（DI）</h2><p>依赖倒置DIP是原则概念，依赖注入DI是依赖倒置原则结合接口、反射的应用。参考<a href="https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection">依赖注入</a></p><p>nuget安装依赖注入框架，并using</p><p><img src="https://gitee.com/Visen_Cao/img/raw/master/Blog/202203261027077.png" alt="image-20220326100805933"></p><p>依赖注入主要有个容器，把我们各种类型和接口，需要实例的时候，可以使用容器，这里不展开如何使用。这里介绍依赖注入的使用</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> sc =<span class="keyword">new</span> ServiceCollection(); <span class="comment">//创建/注册ServiceCollection容器</span></span><br><span class="line">            <span class="comment">//往容器中装东西,后者的类实现前者的接口，使用Typeof是为了动态获取其类型</span></span><br><span class="line">            sc.AddScoped(<span class="keyword">typeof</span>(ITank),<span class="keyword">typeof</span>(HeavyTank));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建ServiceProvider，提供服务</span></span><br><span class="line"><span class="comment">/*只要在其他地方可见上面的注册ServiceProvider，其他地方也能调用而不用new操作符*/</span></span><br><span class="line">            <span class="keyword">var</span> sp = sc.BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//使用该类型</span></span><br><span class="line">            ITank tank = sp.GetService&lt;ITank&gt;(); <span class="comment">//获取服务</span></span><br><span class="line">            tank.Fire();</span><br><span class="line">            tank.Run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Driver</span> <span class="comment">//司机</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> IVehicle _vehicle;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Driver</span>(<span class="params">IVehicle vehicle</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _vehicle = vehicle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Drive</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _vehicle.Run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IVehicle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IVehicle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Car is running!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">IVehicle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Truck is running!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">ITank</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Fire</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">LightTank</span> : <span class="title">ITank</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Boom!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ka ka ka&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MediumTank</span> : <span class="title">ITank</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Boom!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ka! ka! ka!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">HeavyTank</span> : <span class="title">ITank</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Boom!!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ka!!! ka!!! ka!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>依赖注入的一大优势：程序升级时，能够实现类型的对应替换</p></blockquote><p>比如这里，如果程序升级，把HeavyTank修改为MediumTank，使用new操作符就得一个个修改，而使用依赖注入，只需要更改sc.AddScoped(typeof(ITank),typeof(MediumTank))</p><p>示例：依赖注入其他例子</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> sc =<span class="keyword">new</span> ServiceCollection(); </span><br><span class="line"></span><br><span class="line">        sc.AddScoped(<span class="keyword">typeof</span>(ITank),<span class="keyword">typeof</span>(HeavyTank));</span><br><span class="line">        sc.AddScoped(<span class="keyword">typeof</span>(IVehicle), <span class="keyword">typeof</span>(Car));</span><br><span class="line">        sc.AddScoped&lt;Driver&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sp = sc.BuildServiceProvider(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> driver = sp.GetService&lt;Driver&gt;();</span><br><span class="line">        <span class="comment">//Driver构造器需要IVehicle实例，这时候会调用在容器ServiceCollection里的car</span></span><br><span class="line">        driver.Drive();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Driver</span> <span class="comment">//司机</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IVehicle _vehicle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span>(<span class="params">IVehicle vehicle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _vehicle = vehicle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Drive</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _vehicle.Run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IVehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IVehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Car is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">IVehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Truck is running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fire</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">LightTank</span> : <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boom!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ka ka ka&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MediumTank</span> : <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boom!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ka! ka! ka!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">HeavyTank</span> : <span class="title">ITank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boom!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ka!!! ka!!! ka!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射追求“松耦合”">反射追求“松耦合”</h2><p>这种情况一般用在插件式编程，不与主体程序一起编译，但是能与主体一起工作，一般由第三方编写来获利。因为开发插件个数是不可预知的，不可能在写主体程序的时候枚举出插件个数，而是在主体程序给外界提供API，第三方使用SDK开发包，就能高效地开发插件，耦合基本可以忽略不计。</p><p>示例：</p><p>第一家厂商：生产婴儿车，小面板第一排是小动物头像，第二排是数字，按头像和数字，对应的动物就能叫几声，开放接口，可以让第三方增加小动物（主体程序）</p><p>第二家厂商：应用接口，去增加小动物</p><p>nuget安装System.Runtime.Loader（提供接口和类，使开发人员能够影响运行时加载行为）并using，查看运行的文件夹Console.WriteLine(Environment.CurrentDirectory);//目前运行的文件夹，在路径下创建Animal文件夹</p><p>（下面代码还未实现，无法使用引用的类）</p><p>主程序：BabyStroller</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Loader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BabyStroller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> folder = Path.Combine(Environment.CurrentDirectory,<span class="string">&quot;Animal&quot;</span>);<span class="comment">//得到Animal文件夹</span></span><br><span class="line">            <span class="keyword">var</span> files =Directory.GetFiles(folder); <span class="comment">//拿到文件夹中所有文件</span></span><br><span class="line">            <span class="keyword">var</span> animalTypes = <span class="keyword">new</span> List&lt;Type&gt;();</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> file <span class="keyword">in</span> files)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> assembly= AssemblyLoadContext.Default.LoadFromAssemblyPath(file); <span class="comment">//加载文件</span></span><br><span class="line">                <span class="keyword">var</span> types =assembly.GetTypes(); <span class="comment">//每个文件的类型名赋值给types</span></span><br><span class="line">                <span class="keyword">foreach</span>(<span class="keyword">var</span> t <span class="keyword">in</span> types)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(t.GetMethod(<span class="string">&quot;Voice&quot;</span>) != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        animalTypes.Add(t);<span class="comment">//如果类型中有Voice方法，把该动物类型加上</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; animalTypes.Count ; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>,<span class="subst">&#123;animalTypes[i].Name&#125;</span>&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;Please choose animal&quot;</span>);</span><br><span class="line">                    <span class="built_in">int</span> index =<span class="built_in">int</span>.Parse(Console.ReadLine()); <span class="comment">//交互，要求输入动物的序号</span></span><br><span class="line">                    <span class="keyword">if</span>(index &gt; animalTypes.Count || index &lt; <span class="number">1</span>) <span class="comment">//判断是否有这个动物</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;No such an animal.Try again!&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;How many times?&quot;</span>);</span><br><span class="line">                    <span class="built_in">int</span> times = <span class="built_in">int</span>.Parse(Console.ReadLine()); <span class="comment">//要求输入动物叫的次数</span></span><br><span class="line">                    <span class="keyword">var</span> t =animalTypes[index<span class="number">-1</span>]; <span class="comment">//用户选择1到x，编程写0到x-1</span></span><br><span class="line">                    <span class="keyword">var</span> m = t.GetMethod(<span class="string">&quot;Voice&quot;</span>);</span><br><span class="line">                    <span class="keyword">var</span> o = Activator.CreateInstance(t); <span class="comment">//创造t的实例</span></span><br><span class="line">                    m.Invoke(o, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; times &#125;); <span class="comment">//小动物叫</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三方：创建不同的小动物（视频中是两个项目，四个文件去摆放），Build生成两个DLL文件，都放到Animal文件夹中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Animals.Lib</span> </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Unfinished</span>] <span class="comment">//特性，代表还没做完</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">IAnimal</span> <span class="comment">//这里的接口是连接SDK</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Voice</span>(<span class="params"><span class="built_in">int</span> times</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; times ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Meow&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sheep</span>:<span class="title">IAnimal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Voice</span>(<span class="params"><span class="built_in">int</span> times</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; times ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Baa...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Animals.lib2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span>:<span class="title">IAnimal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Voice</span>(<span class="params"><span class="built_in">int</span> times</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; times ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cow</span>:<span class="title">IAnimal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Voice</span>(<span class="params"><span class="built_in">int</span> times</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; times ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Moo!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里使用的反射的直接用法，一般第一方会发布SDK，帮助第三方快速开发</p><p>SDK：build之后把DLL，放到公有的地方，让别人下载使用，并配上说明书</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BabyStroller.SDK</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAnimal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Voice</span>(<span class="params"><span class="built_in">int</span> times</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnifinshedAttribute</span> : <span class="title">Attribute</span> <span class="comment">//用于声明特性（这里不讲）</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一方可以直接项目引用，而第三方得找到SDK文件，然后每个都引用然后再将<strong>里面的每个类都写上接口</strong></p><p>而有了SDK就可以对主程序进行更改，因为<strong>Attribute能判断某个方法中有没有被某个Attribute修饰</strong>，比如下面可以判断是否包含IAnimal和不包含UnfinishedAttribute</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> t <span class="keyword">in</span> types)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t.GetInterfaces().Contains(<span class="keyword">typeof</span>(IAnimal))) <span class="comment">//选择所选的动物类并添加到列表中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> isUnfinished =t.CustomAttributes(<span class="literal">false</span>).Any(a =&gt;a.GetType()==<span class="keyword">typeof</span>(UnfinishedAttribute));</span><br><span class="line">        <span class="keyword">if</span>(isUnfinished)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        animalTypes.Add(t);<span class="comment">//如果类中接口包含IAnimal，CustomAttributes中不包含UnfinishedAttribute则加上该类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>第十四章 泛型</h1><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/generics/">.Net的泛型</a>、<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/generic-type-parameters">C#编程指南 泛型</a></p><p>泛型与接口相当的知识，很重要，这里只介绍最常用的部分</p><h2 id="泛型-generic">泛型(generic)</h2><h3 id="成员膨胀和类型膨胀">成员膨胀和类型膨胀</h3><p>示例：商店开始只卖苹果（带盒子包装）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Apple apple =<span class="keyword">new</span> Apple()&#123;Color = <span class="string">&quot;Red&quot;</span> &#125;;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box()&#123;Cargo = apple&#125;;</span><br><span class="line">        Console.WriteLine(box.Cargo.Color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Apple Cargo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来又兼职卖书，这时候准备两种盒子</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Apple apple =<span class="keyword">new</span> Apple()&#123;Color = <span class="string">&quot;Red&quot;</span> &#125;;</span><br><span class="line">        AppleBox box = <span class="keyword">new</span> AppleBox()&#123;Cargo = apple&#125;;</span><br><span class="line">        Console.WriteLine(box.Cargo.Color);</span><br><span class="line"></span><br><span class="line">        Book book = <span class="keyword">new</span> Book()&#123;Name = <span class="string">&quot;New Book&quot;</span>&#125;;</span><br><span class="line">        BookBox bookBox = <span class="keyword">new</span> BookBox()&#123;Book = book&#125;;</span><br><span class="line">        Console.WriteLine(bookBox.Book.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">AppleBox</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Apple Cargo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">BookBox</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Book Book &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然写出来，发现没啥问题，但是按照逻辑来说，难道商品数目增多，这个盒子也得创建更多的类，不方便维护，这个现象就叫做“<strong>类型膨胀</strong>”</p><p>那如果两个盒子写在一个Box类中呢？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Apple apple =<span class="keyword">new</span> Apple()&#123;Color = <span class="string">&quot;Red&quot;</span> &#125;;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box()&#123;Apple = apple&#125;;</span><br><span class="line">        Console.WriteLine(box.Apple.Color);</span><br><span class="line"></span><br><span class="line">        Book book = <span class="keyword">new</span> Book()&#123;Name = <span class="string">&quot;New Book&quot;</span>&#125;;</span><br><span class="line">        Box bookBox = <span class="keyword">new</span> Box()&#123;Book = book&#125;;</span><br><span class="line">        Console.WriteLine(bookBox.Book.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Apple Apple &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Book Book &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用Box类的时候，我们只使用了这其中一个属性，如果我们再多创建几个盒子属性，就会存在“100个属性选择一个使用”的现象，我们称为“<strong>成员膨胀</strong>”。而且这时候如果想添删，我们得不断修改Box类的属性，很不方便</p><p>那么如果我们申请Box属性不指明类型，而是用object基类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Apple apple =<span class="keyword">new</span> Apple()&#123;Color = <span class="string">&quot;Red&quot;</span> &#125;;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box()&#123;Cargo = apple&#125;;</span><br><span class="line"></span><br><span class="line">        Book book = <span class="keyword">new</span> Book()&#123;Name = <span class="string">&quot;New Book&quot;</span>&#125;;</span><br><span class="line">        Box bookBox = <span class="keyword">new</span> Box()&#123;Cargo = book&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面的访问是有问题的</span></span><br><span class="line">        <span class="comment">//Console.WriteLine(box.Cargo.Color);</span></span><br><span class="line">        <span class="comment">//Console.WriteLine(bookBox.Cargo.Name);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Cargo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现存在访问上的困难，因为Cargo是object类型，而Apple或者Book类赋值给object类型，则会失去失去原本的类型（毕竟没法反着继承），这时候就需要再次修改代码，使用强制类型转换</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Apple apple =<span class="keyword">new</span> Apple()&#123;Color = <span class="string">&quot;Red&quot;</span> &#125;;</span><br><span class="line">        Box appleBox = <span class="keyword">new</span> Box()&#123;Cargo = apple&#125;;</span><br><span class="line"></span><br><span class="line">        Book book = <span class="keyword">new</span> Book()&#123;Name = <span class="string">&quot;New Book&quot;</span>&#125;;</span><br><span class="line">        Box bookBox = <span class="keyword">new</span> Box()&#123;Cargo = book&#125;;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine((appleBox.Cargo <span class="keyword">as</span> Apple)?.Color);</span><br><span class="line">        Console.WriteLine((bookBox.Cargo <span class="keyword">as</span> Book)?.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Cargo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到访问上还是太麻烦，这时候可以选择使用泛型，类名后加&lt;类型参数&gt;</p><h3 id="泛型类">泛型类</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Apple apple =<span class="keyword">new</span> Apple()&#123;Color = <span class="string">&quot;Red&quot;</span> &#125;;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book()&#123;Name = <span class="string">&quot;New Book&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要先特化</span></span><br><span class="line">        Box&lt;Apple&gt; appleBox = <span class="keyword">new</span> Box&lt;Apple&gt;&#123;Cargo = apple&#125;;<span class="comment">//用Apple类型替换了下面Box类里的TCargo类型</span></span><br><span class="line">        Box&lt;Book&gt; bookBox = <span class="keyword">new</span> Box&lt;Book&gt;&#123;Cargo = book&#125;;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(appleBox.Cargo.Color);</span><br><span class="line">        Console.WriteLine(bookBox.Cargo.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">TCargo</span>&gt; <span class="comment">//类型参数取为TCargo，一般是T或者T开头</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TCargo Cargo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实泛型就是为了留个泛化的类型在那，可以后续填入参数，这个参数会代替块语句中的泛型的原先位置</p><h3 id="泛型的概念">泛型的概念</h3><blockquote><p>泛型，指的是泛化（与具体相反）的数据类型，是为所存储或使用的一个或多个类型具有占位符（类型形参）的类、结构、接口和方法。可避免上面的成员膨胀和类型膨胀，并简化代码</p></blockquote><p>可以从上面的代码示例看出，泛型极大地实现了可复用性，有效地避免了类型和成员的膨胀</p><blockquote><p>泛型只能实现上面的类型复用吗？泛型是具有正交性的，可根据要处理的精确数据类型定制方法、类、结构或接口</p></blockquote><p>泛型的正交性：泛型和我们所学的具体类（包括类成员）、结构、接口都有交叉点，比如上面是泛型和类的结合成了泛型类，泛型和接口的结合成了泛型接口</p><h3 id="泛型接口">泛型接口</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student&lt;<span class="built_in">int</span>&gt; stu = <span class="keyword">new</span> Student&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        stu.ID = <span class="number">101</span>;</span><br><span class="line">        stu.Name = <span class="string">&quot;Tim&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//泛型接口的参数可以灵活改变</span></span><br><span class="line">        Student&lt;<span class="built_in">ulong</span>&gt; student = <span class="keyword">new</span> Student&lt;<span class="built_in">ulong</span>&gt;(); </span><br><span class="line">        stu.ID = <span class="number">102</span>;</span><br><span class="line">        stu.Name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IUnique</span>&lt;<span class="title">TId</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    TId ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">TId</span>&gt; : <span class="title">IUnique</span>&lt;<span class="title">TId</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TId ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的ulong填入等价于</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">IUnique</span>&lt;<span class="title">ulong</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">ulong</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>泛型类最常见用法是用于链表、哈希表、堆栈、队列和树等集合</p></blockquote><p>示例：泛型的数据结构、基接口、基类都在System.Collections.Generic类中，using该类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CsharpStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            IList&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(); </span><br><span class="line">            <span class="comment">//List相当于Java的Array，但是List是可以动态改变的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                list.Add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看List<code>&lt;T&gt;</code>的定义，可以看到各种泛型的使用，下面继续展示Dictionary类</p><h3 id="泛型的类型参数">泛型的类型参数</h3><blockquote><p>泛型类型不一定只带一个类型参数</p></blockquote><p>示例：使用两个泛型参数的IDictionary泛型接口</p><p>可以跳转到Dictionary类的定义查看，该类实现了IDictionary泛型接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CsharpStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            IDictionary&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt;(); <span class="comment">//int类型的key，string类型的value</span></span><br><span class="line">            dict[<span class="number">1</span>] = <span class="string">&quot;Tim&quot;</span>;</span><br><span class="line">            dict[<span class="number">2</span>] = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Student #1 is <span class="subst">&#123;dict[<span class="number">1</span>]&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Student #2 is <span class="subst">&#123;dict[<span class="number">2</span>]&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法">泛型方法</h3><p>上面集合就是讲泛型和数据结构的结合，算法的表现就是函数，面向对象里称为方法，于是讲的就是泛型方法就是在对应讲泛型与算法的结合。泛型方法就是为了防止成员膨胀</p><p>示例：编写两类数组的处理方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span>[] a1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] a2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        <span class="built_in">double</span>[] a3 = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span> &#125;;</span><br><span class="line">        <span class="built_in">double</span>[] a4 = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> result = Zip(a3, a4);</span><br><span class="line">        Console.WriteLine(String.Join(<span class="string">&quot;,&quot;</span>, result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">Zip</span>(<span class="params"><span class="built_in">int</span>[] a, <span class="built_in">int</span>[] b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span>[] zipped = <span class="keyword">new</span> <span class="built_in">int</span>[a.Length + b.Length];</span><br><span class="line">        <span class="built_in">int</span> ai = <span class="number">0</span>, bi = <span class="number">0</span>, zi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(ai &lt; a.Length) &#123;</span><br><span class="line">                zipped[zi++] = a[ai++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bi &lt; b.Length) &#123;</span><br><span class="line">                zipped[zi++] = b[bi++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(ai &lt; a.Length || bi &lt; b.Length);</span><br><span class="line">        <span class="keyword">return</span> zipped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">double</span>[] <span class="title">Zip</span>(<span class="params"><span class="built_in">double</span>[] a, <span class="built_in">double</span>[] b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">double</span>[] zipped = <span class="keyword">new</span> <span class="built_in">double</span>[a.Length + b.Length];</span><br><span class="line">        <span class="built_in">int</span> ai = <span class="number">0</span>, bi = <span class="number">0</span>, zi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(ai &lt; a.Length) &#123;</span><br><span class="line">                zipped[zi++] = a[ai++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bi &lt; b.Length) &#123;</span><br><span class="line">                zipped[zi++] = b[bi++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(ai &lt; a.Length || bi &lt; b.Length);</span><br><span class="line">        <span class="keyword">return</span> zipped;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是发现这个代码存在成员膨胀。使用泛型进行更改，先把一些数据类型的int改成T（和函数类型相关的东西，也就是上面double方法对比int方法的不同处），并且在函数名后加上<code>&lt;T&gt;</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span>[] a1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] a2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        <span class="built_in">double</span>[] a3 = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span> &#125;;</span><br><span class="line">        <span class="built_in">double</span>[] a4 = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> result = Zip(a1, a2);<span class="comment">//改成a3和a4也能运行</span></span><br><span class="line">        Console.WriteLine(String.Join(<span class="string">&quot;,&quot;</span>, result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T[] <span class="title">Zip</span>&lt;<span class="title">T</span>&gt;(<span class="params">T[] a, T[] b</span>)</span> &#123;</span><br><span class="line">        T[] zipped = <span class="keyword">new</span> T[a.Length + b.Length];</span><br><span class="line">        <span class="built_in">int</span> ai = <span class="number">0</span>, bi = <span class="number">0</span>, zi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(ai &lt; a.Length) &#123;</span><br><span class="line">                zipped[zi++] = a[ai++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bi &lt; b.Length) &#123;</span><br><span class="line">                zipped[zi++] = b[bi++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(ai &lt; a.Length || bi &lt; b.Length);</span><br><span class="line">        <span class="keyword">return</span> zipped;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候，我们看到的Zip(a1,a2)其实是Zip<code>&lt;T&gt;</code>(a1,a2)，你也可以加上，比如a1和a2写Zip<code>&lt;int&gt;</code>(a1,a2)，a3和a4写Zip<code>&lt;double&gt;</code>(a3,a4)，但是我们这里是可以省略的</p><blockquote><p>个人理解：泛型的T其实就是一个方程的变量，代入数就可以得出方程的解，不同用法只是结合的格式不同，有点像<strong>重载决策</strong></p></blockquote><h3 id="泛型委托">泛型委托</h3><blockquote><p>Action泛型委托只能引用没有返回值的方法，使用方法为Action<code>&lt;T&gt;</code>，T代表填入的方法参数类型</p></blockquote><p>示例：Action泛型委托</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Action&lt;<span class="built_in">string</span>&gt; a1 = Say;</span><br><span class="line">        a1(<span class="string">&quot;Visen&quot;</span>);</span><br><span class="line">        Action&lt;<span class="built_in">int</span>&gt; a2 = Mul;</span><br><span class="line">        a2(<span class="number">1</span>);</span><br><span class="line">        Action&lt;<span class="built_in">double</span>&gt; a3 = Mul;</span><br><span class="line">        a3(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Say</span>(<span class="params"><span class="built_in">string</span> str</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Hello,<span class="subst">&#123;str&#125;</span>!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mul</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(x * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mul</span>(<span class="params"><span class="built_in">double</span> x</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(x * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Func泛型委托可引用具体返回值的方法，使用方法为Func&lt;T1,T2&gt;，T1代表若干个填入的方法参数类型，T2代表若干个输出的方法参数类型</p></blockquote><p>示例：Func泛型委托</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func1 = Add;</span><br><span class="line">        Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>&gt; func2 = Add;</span><br><span class="line">        <span class="keyword">var</span> res1 = func1(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="keyword">var</span> res2 = func2(<span class="number">100.2</span>, <span class="number">200.3</span>);</span><br><span class="line">        Console.WriteLine(res1);</span><br><span class="line">        Console.WriteLine(res2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型Lambda表达式">泛型Lambda表达式</h3><p>对于上面逻辑简单的Add方法，可以不去声明，使用Lambda表达式可以做到随调用随声明，而且是匿名的声明</p><p>因为声明方法后，方法名就一直存在上下文，对于简单逻辑的方法，使用Lambda表达式能避免这种程序污染。</p><p>示例：泛型委托和泛型Lambda表达式的组合（其实Lambda表达式的基础就是委托）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func = (<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    <span class="keyword">var</span> res = func(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    Console.WriteLine(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现泛型Lambda表达式和泛型委托一起使用，两者的参数类型是一一对应的，于是还是可以继续简化的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func = (a, b) =&gt; &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    <span class="keyword">var</span> res = func(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    Console.WriteLine(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>partial类</h1><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods">patial类</a>、<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/partial-type">部分类</a></p><blockquote><p>C#编译器允许把一个类代码分成若干部分编写，每个部分都能独立地版本更新，类的部分就叫部分类</p></blockquote><p>部分类主要好处是为了减少类的派生（派生类有时候太复杂），并且几个部分合起来还是原来的类名进而避免了派生类名申请过多</p><p>示例：使用EntityFramework操作数据库</p><p>需要提前安装SQL Server，并且创建一个数据库，使用视图-SqlServer对象资源管理器和<strong>服务器资源管理器</strong>（添加新表，先定义表，再显示数据）进行管理</p><p>nuget安装并using EntityFramework库，添加ADO数据库项（ADO.NET实体数据模型）,并引用该数据库，可以对照生成的.edmx文件中的.tt文件夹中的.cs文件，发现数据库数据变成了属性供调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dbContext = <span class="keyword">new</span> TestEntities();<span class="comment">//Test是数据库名字</span></span><br><span class="line">        <span class="keyword">var</span> books = dbContext.Tables;<span class="comment">//Table是数据库表名Table加上s</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)<span class="comment">//取出每行数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(book.Name);<span class="comment">//输出每行数据的Name属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：输出每行数据的所有信息，不是在主程序中设置，而是在Table类中添加Report方法用于返回输出的字符串</p><p>进入.edmx文件中的.tt文件夹中的表名.cs文件</p><p><img src="C:/Users/20295/AppData/Roaming/Typora/typora-user-images/image-20220418165108012.png" alt="image-20220418165108012"></p><p>但是当前的Table类中声明report方法，更新数据库后，我们的操作会被丢弃，这时候发现这里使用了Partial类，我们可以创建对应名称空间的Partial类（推荐全部复制到新类，再更改），这样在更新数据库后，我们创建的类会自动附加过去</p><p>这边创建一个名为TablePart类（内部的类选择之前的Table类）</p><p><img src="C:/Users/20295/AppData/Roaming/Typora/typora-user-images/image-20220418170024724.png" alt="image-20220418170024724"></p><p>对应更改主程序</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dbContext = <span class="keyword">new</span> TestEntities();<span class="comment">//Test是数据库名字</span></span><br><span class="line">        <span class="keyword">var</span> books = dbContext.Tables;<span class="comment">//Table是数据库表名Table加上s</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)<span class="comment">//取出每行数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(book.Report());<span class="comment">//调用Report方法，输出所有信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在数据库新添一列，也不会对结果有改变</p><p>比如：添加一行Author，并点击.edmx，在空白处右击选择从数据库更新数据，点击完确认后，再Ctrl+S保存，再进行一些确认，Table.cs等代码就会更新，但是TablePart文件仍然能使用。</p><p>很多时候不是直接使用，而是在各种框架中使用，比如WPF中的Xaml语言也是变成Csharp再被编译，就是使用partial类</p><h1>第十五章 枚举</h1><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/enums">枚举 C#规范</a>、<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum">枚举 C#参考</a></p><blockquote><p>枚举类型是声明一组命名常量 (值类型) 的非重复值类型，也就是人为限定参数选择范围</p></blockquote><p>示例：实现qq群里的等级</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.Level = <span class="string">&quot;群主&quot;</span>;<span class="comment">//但是可能会乱写级别，有人不认真就完蛋</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Level &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是发现这里的级别是靠人去写的，虽然这里灵活度高，还是得对程序员进行一些约束。我们想实现的是群昵称可以从冒泡、潜水一直升级等，这时候需要枚举类型，固定那些等级名</p><p>当然，得注意区分所获取的是值还是序号，注意值与序号的对应关系（默认从0开始，并依次增加1）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">        person1.Level = Level.冒泡;</span><br><span class="line"></span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">        person2.Level = Level.龙王;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(person1.Level &gt; person2.Level); <span class="comment">//比较成员对应的等级，实际是0是否大于202，输出false</span></span><br><span class="line">        Console.WriteLine(person1.Level); <span class="comment">//输出对应的值，冒泡</span></span><br><span class="line">        Console.WriteLine(Level.冒泡); <span class="comment">//输出对应的值，冒泡</span></span><br><span class="line">        Console.WriteLine((<span class="built_in">int</span>)Level.冒泡);<span class="comment">//输出默认对应的序号，0</span></span><br><span class="line">        Console.WriteLine((<span class="built_in">int</span>)Level.潜水); <span class="comment">//输出对应编写的序号，200</span></span><br><span class="line">        Console.WriteLine((<span class="built_in">int</span>)Level.龙王); <span class="comment">//输出自动添加的序号，201</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Level &#123;</span><br><span class="line">    冒泡,</span><br><span class="line">    潜水=<span class="number">200</span>,</span><br><span class="line">    龙王,</span><br><span class="line">    群主,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Level Level &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//修改为枚举类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如何使用枚举类型中的多个值？更换数据结构可以但太麻烦，这里可以使用按位运算</p></blockquote><p>示例：比特位式用法实现技多不压身（按位取或，实现相加）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.skill = Skill.Drive | Skill.Cook; <span class="comment">//既会开车又会做饭</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">enum</span> Skill &#123;</span><br><span class="line">        Drive,</span><br><span class="line">        Cook,</span><br><span class="line">        Program,</span><br><span class="line">        Teach,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Skill skill &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//修改为枚举类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编程时候会经常用到这个用法，比如我们读写文件时，需要多种方式尝试打开文件</p><h1>第十六章 结构体（struct）</h1><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/structs">结构体 C#规范</a></p><p>结构体和类很类似，不同点主要就是一个是值类型一个是引用类型。</p><h2 id="结构体VS类">结构体VS类</h2><blockquote><p>相同点：它们都表示可以包含数据成员和函数成员的数据结构</p></blockquote><blockquote><p>不同点1：与类不同的是，结构是最典型的值类型，不需要进行堆分配(可装/拆箱)</p></blockquote><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student() &#123; ID = <span class="number">101</span>, Name = <span class="string">&quot;Tim&quot;</span> &#125;; </span><br><span class="line">        <span class="comment">//到这一步和类没差</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">object</span> obj = student; <span class="comment">//装箱，把student实例丢到内存堆里，把obj引用这个实例</span></span><br><span class="line">        Student student1 = (Student)obj;<span class="comment">//拆箱,把obj类型取出,换成Student类型实例</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;student1.ID&#125;</span> Name : <span class="subst">&#123;student1.Name&#125;</span>&quot;</span>); </span><br><span class="line">        <span class="comment">//输出101 Name : Tim</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装箱是指该类型的值转换为类型object或由类实现的接口类型，拆箱是指将object类型或接口类型的值转换回该类型</p><blockquote><p>不同点2：结构类型的变量直接<strong>包含结构的数据</strong>，而类类型的变量(对象)包含对数据的引用；这也是值类型与引用类型的区别</p></blockquote><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student() &#123; ID = <span class="number">101</span>, Name = <span class="string">&quot;Tim&quot;</span> &#125;;</span><br><span class="line">        Student stu2 = stu1; <span class="comment">//赋值不是赋的引用，而是完整的拷贝过去</span></span><br><span class="line">        stu2.ID = <span class="number">1001</span>;</span><br><span class="line">        stu2.Name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;stu1.ID&#125;</span> Name : <span class="subst">&#123;stu1.Name&#125;</span>&quot;</span>); <span class="comment">//输出101 Name : Tim</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;stu2.ID&#125;</span> Name : <span class="subst">&#123;stu2.Name&#125;</span>&quot;</span>); <span class="comment">//输出1001 Name : Tom</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把struct改为class，程序仍运行，输出的是两行的1001 Name : Tom，就是两者变量赋值的不同</p><blockquote><p>不同点3：可实现接口，不能派生自类/结构体(冒号只能用于接口)</p></blockquote><p>示例：结构实现接口，不能派生这个不举例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student() &#123; ID = <span class="number">101</span>, Name = <span class="string">&quot;Tim&quot;</span> &#125;;</span><br><span class="line">        stu1.Speak(); <span class="comment">//输出I&#x27;m Tim,my ID is 101</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">ISpeak</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student : ISpeak &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;I&#x27;m <span class="subst">&#123;<span class="keyword">this</span>.Name&#125;</span>,my ID is <span class="subst">&#123;<span class="keyword">this</span>.ID&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不同点4：结构体不能有显式无参构造器，但是允许显式的有参构造器</p></blockquote><p>示例：结构体构造器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式的无参构造器，会报错</span></span><br><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显式的有参构造器，是允许的</span></span><br><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> id ,<span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>第十七章 LINQ串讲</h1><p>意义：使用LINQ访问数据库时，LINQ语法和Lambda表达式需要了解，而委托作为Lambda表达式基础，这次就为了lambda表达式讲，而上次是为了给事件讲解</p><h2 id="委托类型">委托类型</h2><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/delegates">委托</a></p><h3 id="委托定义">委托定义</h3><blockquote><p>委托是类类型的一种，是一种特殊的类（引用类型），在功能和声明比较特殊</p></blockquote><p><strong>功能</strong>：其他类是用来反映现实中的事物，而委托是为了包裹方法，是方法的封装（包装）器，然后通过调用委托间接地调用方法。一般情况下，委托类型的实例是包裹着方法。（对应着C++的函数指针）</p><p>示例：委托类型是一种类类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CsharpStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDele</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyDele&lt;<span class="built_in">int</span>&gt; deleAdd = <span class="keyword">new</span> MyDele&lt;<span class="built_in">int</span>&gt;(Add);</span><br><span class="line">            Console.WriteLine(deleAdd.GetType().IsClass);<span class="comment">//输出True，是一个类</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明</strong>：声明类需要使用Class关键字，而声明委托是使用delegate，而且要看上去像函数的声明，需要告诉外界委托的返回类型和输入类型</p><p>示例：委托的简单声明</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">MyDele</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span>;</span><br></pre></td></tr></table></figure><p>创建实例的时候，需要填入对应输入/出的方法</p><p><img src="C:/Users/20295/AppData/Roaming/Typora/typora-user-images/image-20220415162336348.png" alt="image-20220415162336348"></p><p>这里创建方法，并引用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CsharpStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">MyDele</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> a,<span class="built_in">double</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyDele dele1 = <span class="keyword">new</span> MyDele(Add);<span class="comment">//是将方法名填入而不是调用方法Add()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型委托-2">泛型委托</h3><p>示例：泛型的简单使用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CsharpStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> T <span class="title">MyDele</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a, T b</span>)</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyDele&lt;<span class="built_in">int</span>&gt; deleAdd = <span class="keyword">new</span> MyDele&lt;<span class="built_in">int</span>&gt;(Add);</span><br><span class="line">            <span class="built_in">int</span> res1 = deleAdd(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">            Console.WriteLine(res1);</span><br><span class="line"></span><br><span class="line">            MyDele&lt;<span class="built_in">double</span>&gt; deleMul = <span class="keyword">new</span> MyDele&lt;<span class="built_in">double</span>&gt;(Mul);</span><br><span class="line">            <span class="built_in">double</span> res2 = deleMul(<span class="number">10.2</span>,<span class="number">5.0</span>);</span><br><span class="line">            Console.WriteLine(res2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Mul</span>(<span class="params"><span class="built_in">double</span> x,<span class="built_in">double</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到泛型可以防止类膨胀和类成员膨胀，配合委托，很像我们使用的方法重载，泛型委托有类型参数推断一类的机制，有时候甚至可以删除一部分显式写出来的类型。</p><h3 id="被设计好的泛型委托：Action、Func委托">被设计好的泛型委托：Action、Func委托</h3><p>但是使用时，发现并不像这样声明泛型委托，是因为C# 4左右加入了预先声明好的泛型委托：无返回值（返回值的类型为Void）的Action委托和有返回值的Func委托</p><p>示例：使用声明好的Action和Func委托</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CsharpStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Action actionCallNum = <span class="keyword">new</span> Action(CallNum);</span><br><span class="line"></span><br><span class="line">            Action&lt;<span class="built_in">string</span>&gt; actionSayHello = <span class="keyword">new</span> Action&lt;<span class="built_in">string</span>&gt;(SayHello);</span><br><span class="line">            actionSayHello(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; funcAdd = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;(Add);</span><br><span class="line">            <span class="comment">//委托有返回值的方法，则需要使用Func</span></span><br><span class="line">            <span class="comment">//Func内尖括号前面两个数值为输入的类型，最后一个为输出类型</span></span><br><span class="line">            funcAdd(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallNum</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Num is Called&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Hello,<span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，上述的声明中，变量的声明都可以使用var，来精简代码</p><p>如Func&lt;int, int, int&gt; funcAdd = new Func&lt;int, int, int&gt;(Add);</p><p>可以写出var funcAdd = new Func&lt;int, int, int&gt;(Add);</p><h2 id="Lambda表达式">Lambda表达式</h2><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-expressions">Lambda表达式</a></p><h3 id="Lambda作用">Lambda作用</h3><blockquote><p>创建匿名方法/函数、Inline方法（一边声明一边调用）</p></blockquote><p>示例：用Lambda表达式代替“零碎”的函数Add</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;((<span class="built_in">int</span> a, <span class="built_in">int</span> b)=&gt;&#123; <span class="keyword">return</span> a + b; &#125;);</span><br><span class="line">    <span class="built_in">int</span> res = func(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    Console.WriteLine(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明Lambda">声明Lambda</h3><blockquote><p>格式：(输入参数：如果有的话)=&gt;表达式</p><pre><code>(输入参数)=&gt;&#123;语句块&#125;</code></pre></blockquote><p>那么Lambda表达式是什么类型呢或者说可以转换为什么类型？</p><p>Lambda表达式与方法类似，另外<strong>任何Lambda表达式都可以转换为委托类型</strong>和表达式树类型（省略）</p><h3 id="Lambda的使用">Lambda的使用</h3><h4 id="作为委托类型参数">作为委托类型参数</h4><p>比如上面Lambda代替Add函数的示例，而且还能进行简化，因为这里包含一些语法糖</p><p>示例：Lambda表达式的语法糖</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;((<span class="built_in">int</span> a, <span class="built_in">int</span> b)=&gt;&#123; <span class="keyword">return</span> a + b; &#125;);</span><br></pre></td></tr></table></figure><p>变成</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;((a, b)=&gt;&#123; <span class="keyword">return</span> a + b; &#125;);</span><br></pre></td></tr></table></figure><p>变成</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func = (a, b)=&gt;&#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure><h4 id="作为委托类型变量">作为委托类型变量</h4><p>任何Lambda表达式都可以转换为委托类型，于是可以使用委托类型的变量去承载它</p><p>示例：Lambda赋值给委托类型变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square = x =&gt; x * x;</span><br><span class="line">Console.WriteLine(square(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>示例：泛型与Lambda表达式结合，Lambda表达式填入泛型的输入参数列表</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DoSomeCalc&lt;<span class="built_in">int</span>&gt;((a, b) =&gt; &#123; <span class="keyword">return</span> a + b; &#125;, <span class="number">100</span>, <span class="number">200</span>);<span class="comment">//&lt;int&gt;可省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomeCalc</span>&lt;<span class="title">T</span>&gt;(<span class="params">Func&lt;T, T, T&gt; func, T x, T y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        T res = func(x, y);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LINQ">LINQ</h2><p>参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/">LINQ C#</a>及其建议的内容</p><blockquote><p><a href="http://xn--LINQ-8s8fo41in52a.Net">LINQ全称是.Net</a> Language Integrated Query，是一系列直接将查询功能集成到C#语言的技术统称（比如数据库操作时，可在某些情况下代替sql，但是还是得学sql）</p></blockquote><p>在 C# 中可为以下对象编写 LINQ 查询：SQL Server 数据库、XML 文档、<a href="http://ADO.NET">ADO.NET</a> 数据集以及支持 IEnumerable或泛型IEnumerable接口的任何对象集合。 此外，第三方也为许多 Web 服务和其他数据库实现提供了 LINQ 支持。</p><p>示例：<a href="http://xn--LINQADO-g46of50x.NET">LINQ查询ADO.NET</a> 数据集</p><p>这里不讲解像SQL语法的LINQ，因为后续还得学</p><p>LINQ中有Select方法<br>比如取出p中的FirstName：<code>某表元素.Select(p=&gt;p.FirstName).ToList();</code><br>取出p中的两个Name：<code>某表元素.Select(p=&gt;p.FirstName+&quot; &quot;+p.LastName).ToList();</code></p><p>示例：取出讲解Partial类那章时，我们采用的元素</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dbContext = <span class="keyword">new</span> TestEntities();<span class="comment">//Test是数据库名字</span></span><br><span class="line">        <span class="keyword">var</span> books = dbContext.Tables.Select(b =&gt; b.Id + <span class="string">&quot; &quot;</span>+b.Name).ToList();<span class="comment">//选出id和name</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LINQ中还有Where方法去筛选(Where方法需要填入布尔参数)<br>比如先筛选出某个符合参数，再选择性输出<br><code>某表元素.Where(p=&gt;p.FirstName==&quot;Tim&quot;).Select(p=&gt;p.FirstName+&quot; &quot;+p.LastName).ToList();</code></p><p><code>var yesOrNo = db.某表元素.All(p=&gt;p.FirstName==&quot;Tim&quot;);</code>//返回是否都是Tim的布尔值<br><code>var yesOrNo = db.某表元素.Any(p=&gt;p.FirstName==&quot;Tim&quot;);</code>//返回是否存在Tim的布尔值</p><p>示例：取出Books里id为1的书名</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dbContext = <span class="keyword">new</span> TestEntities();<span class="comment">//Test是数据库名字</span></span><br><span class="line">        <span class="keyword">var</span> books = dbContext.Tables.Where(p=&gt;p.Id==<span class="number">1</span>).Select(b =&gt; b.Id + <span class="string">&quot; &quot;</span>+b.Name).ToList();<span class="comment">//选出id和name</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多方法可以参考这里</p><p><img src="C:/Users/20295/AppData/Roaming/Typora/typora-user-images/image-20220417211232768.png" alt="image-20220417211232768"></p><hr><h1>第十六章 附加Net内容（高级内容）</h1><p>主要参考<a href="https://docs.microsoft.com/zh-cn/dotnet/fundamentals/">.NET 文档</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/runtime-libraries-overview">广泛的标准类库集</a>:</p><p><img src="C:/Users/20295/AppData/Roaming/Typora/typora-user-images/image-20220416210117436.png" alt="image-20220416210117436"></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/file-system/">文件系统和注册表</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/how-to/#working-with-strings">处理字符串</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/io/">文件和流 I/O</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection">依赖注入DI</a></p>]]></content>
      
      
      <categories>
          
          <category> Net开发 </category>
          
          <category> Csharp基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床配置</title>
      <link href="/2021/11/0.2%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2021/11/0.2%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子-center"><center>引子</center></h2><p>    👋这里是Visen.写博客当然要用图床啦，别人又无法访问你本地图片，只能放在网上的某个地方托管。上传为了方便一般都使用PicGo，当使用Vscode或者Typora写博客的时候，只需要粘贴图片就能自动上传。</p><p>这里推荐几个图床</p><ul><li>Gitee/Github图床：使用代码托管服务，自己搭建图床，还能自动管理，自由度高(Gitee加了防盗链，这里不推荐)</li><li>SM.MS图床：简单注册就能用，配置也简单，10G空间很够用！我把它当平时图床，作废可清理</li><li>阿里云图床：其他图床经常会失效给钱了还是有保证的。配置完没啥访问量，也就9块钱一个月</li></ul><p>这里更新配置Github图床的步骤，并使用<a href="https://www.jsdelivr.com/">Jsdelivr</a>。此教程参考<a href="https://picgo.github.io/PicGo-Doc/">PicGo官网</a></p><hr><h2 id="center-创建图床"><center>创建图床</h2><h3 id="Github图床">Github图床</h3><blockquote><p>主要介绍如何在创建仓库并导出私人令牌来连接Api</p></blockquote><ol><li>首先得有<a href="https://github.com/">Github</a>账号,点击官网创建</li><li>新建仓库（这里我选择仓库名为image）作为图片存储的地方（仓库需选择开源）</li></ol><p>New repositry新建仓库-&gt;填入repositry name仓库名，创建完成</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205120928904.png" alt="202205050919038"></p><ol start="3"><li>获取私人令牌</li></ol><p>注意：私人令牌是可以管理所有仓库的，能行使访问，修改等权限，需妥善保管</p><p><code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>Personal access tokens</code></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205120930219.png" alt="202205050932206"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205120931153.png" alt="202205050932545"></p><p>填写及勾选相关信息，然后点击 <code>Genetate token</code> 即可</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205120931851.png" alt="image-20220117205905512"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205260945775.png" alt="image-20220119151432557"></p><h3 id="阿里云图床">阿里云图床</h3><blockquote><p>主要介绍如何申请阿里云对象存储OSS，并配置后导出key值</p></blockquote><p>收费策略：阿里云是分为存储计费和流量计费，实际存储量越大存储包越费钱，访问量越大流量包越费钱，存储包是包年的，很便宜，流量包就是每小时计算费用。</p><p>（待更新）</p><hr><h2 id="配置PicGo">配置PicGo</h2><ol><li>下载并安装<a href="https://picgo.github.io/PicGo-Doc/zh/">PicGo</a>，参考<a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html">PicGo指南</a>进行配置</li><li>Picgo图床设置</li></ol><p>Github不用插件了，直接配置信息就可以</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205120932212.png" alt="202205050932828"></p><ol start="3"><li><p>因为图床不能有相同名字的图片，所以推荐在PicGo中设置按时间自动改名</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205120933311.png" alt="image-20220119171439577"></p></li></ol><p>如果想要管理相册，可以在PicGo的相册中勾选未使用的图片进行删除</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205120933630.png" alt="image-20220119173429023"></p><h2 id="配置Typora">配置Typora</h2><p>在Typora中设置粘贴图片后自动上传图片</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205120935542.png" alt="202205050932680"></p>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Picgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github和Hexo搭建属于自己的博客</title>
      <link href="/2021/11/0.1%E4%BD%BF%E7%94%A8github%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/11/0.1%E4%BD%BF%E7%94%A8github%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="center-引子"><center>引子</h2><p>    👋这里是Visen，取名原因除了名字谐音，也是因为vise是老虎钳的意思，虎年嘛，钳字又让我觉得能钳制住困难；有时候取名叫supervisen，是因为supervisor是老板的意思，不想当打工人了！最近发现自己能够作为内容输出者，想着搭建独一无二的个人博客。通过博客的形式来驱动自己学习，方便后续回顾，内化知识的同时也从分享中得到快乐。当然也不排斥CSDN、博客园之类，但是用何同学的话来总结就是“不够酷”，看着网上铺天盖地的教程，我知道自己有得忙活。在这里也想记录一下建站的整个过程。</p><p>目前搭建博客有几个常用方案</p><ul><li>静态网站生成：Git + Github Pages + Markdown + jekyll/hexo/hugo/手写前端/Gridea（免费）</li><li>第三方：CSDN、博客园、简书等（不够酷）</li><li>内容管理系统 CMS：虚拟主机（云服务器）+插件+Wordpress/Ghost/手写前后端（付费）</li></ul><p>架不住我没钱呀，于是选了第一个😂（哦，表情包可以配置或者直接粘贴：<a href="https://hasaik.com/posts/9b280ea3.html">表情包配置方法</a>/<a href="https://www.emojiall.com/zh-hans">表情包网站</a>)。</p><p>如果是计算机纯小白，也没有linux、git和前端基础不妨试着使用<a href="https://gridea.dev/?imyshare.com=friends">Gridea</a>，不用在本地搞太多东西，更单纯地写博客，里面还自带表情包，只是界面主题稍微少了一些，个性化也少一些。这里放个<a href="https://gridea.dev/gridea-start/">Gridea官方教程</a>。</p><p>这里只提供Window环境下安装指南。大家也可以通过国内的Gitee来建博客，但是需要手持身份证照片，有点尬，我拒绝了哈哈哈。</p><hr><h2 id="博客环境搭建">博客环境搭建</h2><h3 id="Git环境">Git环境</h3><p>Git （管理代码）是一个开源的分布式版本控制统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，无需服务器端软件（IIS、Apache、Nginx等）支持。</p><ol><li>下载对应系统的<a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/git-for-windows/git/">Git</a>（清华镜像），这里选择最新的64位exe安装包，点击安装，一直点next就可以（可更改安装路径）。</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112000811.gif" alt="202205050902279"></p><ol start="2"><li>安装完成后，右键就会出现git选项，可以在任何文件夹位置打开界面，命令行使用linux命令。</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112001715.png" alt="202205050903773"></p><ol start="3"><li>初始化git配置，配置个人的用户名称和电子邮件地址。使用 <strong>–global</strong> 选项，那么更改的是用户主目录配置文件，以后你所有的项目默认使用该用户信息。（Windows用户主目录：C盘/用户/你的用户名）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名比如visen&quot;</span> <span class="comment">#设置用户名为visen</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱&quot;</span> <span class="comment">#设置邮箱（一般选Github的登录邮箱）</span></span><br><span class="line">git config --list <span class="comment">#查看是否设置成功</span></span><br></pre></td></tr></table></figure><h3 id="Node环境">Node环境</h3><p>Node.js （hexo环境依赖）是一个开源和跨平台的 JavaScript 运行时环境。 具有独特的优势，数百万为浏览器编写 JavaScript 的前端开发者无需学习完全不同的语言，就可以编写除客户端代码之外的服务器端代码。（适用于前后端分离项目，可以代替Python/PHP这种P类等后端语言）</p><ol><li>下载<a href="https://mirrors.tuna.tsinghua.edu.cn/nodejs-release/">Node.js</a>（清华镜像），点击安装。这里推荐最新版就行，官方推荐是Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112013054.gif" alt="1"></p><ol start="2"><li>安装成功后，进入git bash，查看node和npm版本，搭建成功（tip：git中复制快捷键是Ctrl+Insert，粘贴是Shift+Insert）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v &amp;&amp; npm -v <span class="comment">#查看node和npm的版本version(&amp;&amp;表示and，自动等待前一条指令完成再去执行下一个)</span></span><br></pre></td></tr></table></figure><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205111944703.png" alt="image-20220511193701063"></p><h3 id="Hexo环境">Hexo环境</h3><p><a href="https://hexo.io/zh-cn/index.html">hexo</a>是一种基于Node.js的快速、简洁且高效的博客框架，依赖少易于使用，可生成静态网页托管在一些代码仓库github、gitee等。</p><ol><li>创建文件夹（博客本地位置，也是根目录）用来布置hexo，直接在文件夹中右键选择git中用npm安装，等待安装完成。（没反应的话，就重启一下电脑）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g <span class="comment">#安装hexo</span></span><br></pre></td></tr></table></figure><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112014061.gif" alt="202205050903441"></p><ol start="2"><li>一些显示并不是错误，没有其他问题就是成功了。</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112015192.png" alt="202205050903887"></p><ol start="3"><li>初始化hexo，并安装依赖。可以看到hexo已经在文件夹里布置好了。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hexo init &amp;&amp; npm install<span class="comment">#初始化（只能在空文件夹内使用），并安装依赖</span></span><br><span class="line">npm install hexo-deployer-git --save <span class="comment">#安装推送器（部署插件）保证推送到github</span></span><br><span class="line">npm un hexo-renderer-marked --save <span class="comment"># 如果有安装这个的话，卸载，该渲染器会自动把&amp;变成&amp;amp;</span></span><br><span class="line">npm install hexo-renderer-markdown-it --save <span class="comment">#安装这个渲染器是可行的</span></span><br><span class="line">npm install --save hexo-tag-aplayer <span class="comment">#全局吸底 Aplayer</span></span><br><span class="line">npm i hexo-filter-nofollow --save <span class="comment">#为网站使用到的所有外链添加rel=&quot;noopener external nofollow noreferrer&quot;, 可以有效地加强网站SEO和防止权重流失</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可选依赖：</span></span><br><span class="line">npm install hexo-generator-search --save<span class="comment">#算法搜索-实时本地搜索</span></span><br><span class="line"><span class="comment">#stylus渲染器</span></span><br><span class="line">npm install hexo-render-pug hexo-renderer-stylus --save</span><br><span class="line"><span class="comment">#KaTeX公式渲染 </span></span><br><span class="line">npm un hexo-renderer-kramed --save <span class="comment"># 如果安装了这个，卸载掉</span></span><br><span class="line">npm i hexo-renderer-markdown-it --save <span class="comment"># 需要安装这个渲染插件</span></span><br><span class="line">npm install @neilsustc/markdown-it-katex --save <span class="comment">#需要安装这个katex插件</span></span><br></pre></td></tr></table></figure><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112015645.png" alt="202205050924417"></p><ol start="4"><li>通过目前默认主题landscape来本地部署博客，可能会出现<a href="https://zhuanlan.zhihu.com/p/397813964">Accessing non-existent property</a>的问题，不用管，是stylus模块的问题（问过开发者）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s <span class="comment">#生成和启动服务。其中g可以写generate，s可以写server</span></span><br><span class="line"><span class="comment">#hexo server -p 80 可将端口号从默认4000改成80</span></span><br></pre></td></tr></table></figure><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112016848.png" alt="202205050925312"></p><ol start="5"><li>浏览器访问 <a href="http://localhost:4000">http://localhost:4000</a>，看到landscape的界面，本地部署完成，使用Ctrl+C可以关闭服务。</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112030643.png" alt="202205050925033"></p><ol start="6"><li>了解下hexo是怎么放文件的（文件结构），后续方便理解。</li></ol><ul><li><p>执行清理缓存命令，可以回到初始化后的节点，发现少了个public文件夹，该文件夹就是通过执行_config.landscape.yml产生的网页文件（注：此时任何文件夹存在的文件都最好不要删除，不然就等于框架缺了一角，会出现错误）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清理缓存</span></span><br></pre></td></tr></table></figure><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112031513.png" alt="202205050925411"></p></li><li><p>使用<strong>hexo g</strong>后，再次生成完整的文件夹。其文件结构如下：（使用<a href="https://vincentruan.github.io/2020/02/04/Mermaid-%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/">Mermaid</a>代码块实现）</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA(hexo根目录)--&gt;B1(node_modules&#x2F;&#x2F;依赖的模块)A(hexo根目录)--&gt;B2(public&#x2F;&#x2F;通过yml主题配置文件生成的页面)A(hexo根目录)--&gt;B3(source&#x2F;&#x2F;资源文件)B3--&gt;C1(_posts&#x2F;&#x2F;存放md文章,不能为空)A(hexo根目录)--&gt;B4(themes&#x2F;&#x2F;主题文件夹)A(hexo根目录)--&gt;B5(_config.yml&#x2F;&#x2F;hexo博客的设置)  </pre></div><p>但是Mermaid写法还是得根据自己主题设置，比如我选择的主题有语法改变</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112031627.png" alt="image-20211226131109893"></p><p>补充：_config.yml的理解可以参考<a href="https://hexo.io/zh-cn/docs/configuration">hexo官方文档</a></p></li></ul><h3 id="Github环境">Github环境</h3><p>GitHub是世界上最大的代码托管平台（代码仓库），可以把代码放上面开源，分享自己的代码，也可以随时下载到本地。</p><ol><li>注册<a href="https://github.com/">Github</a>，并登录。git bash输入ssh-keygen命令，在用户主目录的.ssh文件夹中会生成两个.ssh/id_rsa（私钥文件）和.ssh/id_rsa.pub（公钥文件）。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;github账号的登录邮箱&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112032449.png" alt="202205050910860"></p><ol start="2"><li><p>新建SSH Key，输入刚复制的公钥，绑定成功。</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112033347.png" alt="202205050910544"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112055711.png" alt="202205050910108"></p></li><li><p>测试下连接，显示连接成功！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112055287.png" alt="202205050910182"></p></li><li><p>进入github网站，点击your repositories—&gt;new来新建仓库。</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112055803.png" alt="202205050910181"></p></li><li><p>Github仓库名形如 <code>&lt;用户名&gt;.github.io</code>。开启 Pages 服务后可以直接通过 <code>http://&lt;用户名&gt;.github.io</code> 访问</p></li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112056979.png" alt="202205050910933"></p><ol start="6"><li>在设置中开通github pages服务，任意选择一个主题，点击提交更改。<br><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112056076.png" alt="202205050911169">`</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112057018.png" alt="202205050911559"></p><ol start="7"><li>在hexo根目录中的**_config.yml**（hexo的配置文件），将deploy部署项改成github以部署到github仓库。</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112126725.png" alt="202205050911968"></p><p>修改成</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">你的SSH地址</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">你的分支名</span></span><br></pre></td></tr></table></figure><p>地址名和分支名获取方法：</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112127812.png" alt="202205050911010"></p><p>这样设置后，下次部署的时候，就通过这个SSH地址，上传到这个仓库的这个分支（两个值不能填错）</p><ol start="8"><li>那如何去部署呢？输入命令上传到Github</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d <span class="comment">#部署到根目录的_config.yml设置的路径，其中d可以写deploy</span></span><br><span class="line"><span class="comment">#指令a&amp;&amp;指令b：当a出错，会自动运行到b，但可能会引发连续错误，注意别输错</span></span><br></pre></td></tr></table></figure><ol start="9"><li>进入Github，会发现已经多了一些文件，就是你上传的生成文件，会发现其实就是本地的public文件夹内容。找到Github分配的网址，点击进入，就能看到自己成果。</li></ol><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112128040.png" alt=""></p><ol start="11"><li>使用命令 <strong>hexo new “My New Post”</strong> 可以创建你的文章，会保存在 hexo\source_posts 目录，再使用命令<strong>hexo g &amp;&amp; hexo d</strong>就可以不断上传作品</li></ol><hr><h2 id="更换主题">更换主题</h2><p>虽然这时候已经可以写博客了，但是界面不够酷！那就开始更换主题吧！👀</p><h3 id="主题挑选">主题挑选</h3><p>官网里提供蛮多的<a href="https://hexo.io/themes/index.html">主题</a>，也可以参考知乎等平台找，修改的方法大相径庭。这里我使用的是<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a>。确定后，进入GitHub克隆代码到Hexo根目录/themes目录下。</p><p>根据主题下面的installation安装备注，可以获取很多信息，首先知道有两类安装方式</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112129202.png" alt="202205050911761"></p><ol><li><p>直接进入GitHub中下载zip文件，并解压到主题文件，并且改好名字</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112130167.png" alt=""></p><p>附上文件结构（注意：千万不能嵌套在其他文件夹下，主题在themes文件中）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112130682.png" alt="202205050911388"></p></li><li><p>使用<strong>git clone</strong>命令或<strong>npm</strong>命令。（必须在根目录下打开git bash，因为涉及文件夹创建和文件传输，路径不能错）</p></li></ol><h3 id="主题配置">主题配置</h3><p>这里参考<a href="https://butterfly.js.org/">butterfly开发者博客</a>，修改主题肯定还是官方文档好使！</p><ol><li><p>使用主题：在根目录下的_config.yml中把theme参数修改成自己的主题名（即使下载多个主题放themes文件夹也不会报错，但是配置文件中配置为theme：所选的主题）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112130686.png" alt="202205050911331"></p><p>把landscape修改成butterfly</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112132432.png" alt="202205050911794"></p><p>并把主题语言改成中文</p></li><li><p>设置主题的具体内容。从主题的GitHub仓库可以知道配置时候是更改<strong>butterfly文件夹里的</strong>_config.yml文件（可理解为脚本文件，通过这个脚本生成public网页文件）。这边推荐<a href="https://www.cnblogs.com/MoYu-zc/p/14395965.html">教程</a></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112133254.png" alt="202205050911605"></p></li><li><p>挑出其中一些设置去介绍。设置时候可以先在本地使用<strong>hexo g &amp;&amp;hexo s</strong>来检查是否有错误，有些时候会有莫名bug就撤销操作</p><ul><li>修改导航目录。这里推荐使用<a href="http://www.fontawesome.com.cn/icons-ui/">Font Awesome</a>，直接找到想要的图标就可以拿来用</li></ul><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112133055.png" alt="202205050911522"></p><ul><li><p>主题颜色。推荐<a href="http://zhongguose.com/">中国传统颜色</a>，传统的还是美的！我的主页采用景泰蓝</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112133613.png" alt="202205050911158"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112134732.png" alt="202205050911464"></p></li><li><p>鼠标点击效果</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112134320.png" alt="202205050911511"></p></li><li><p>主页的一言打字效果（推荐）</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112134898.png" alt="202205050911699"></p></li><li><p>修改侧边栏</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112134770.png" alt="202205050911722"></p></li><li><p>添加评论系统，可以选择<a href="https://console.leancloud.cn/apps">LearnCloud</a></p></li><li><p>设置好各类图片，这里推荐<a href="http://guozhivip.com/imgs.html">果汁导航的免费图片专栏</a>来挑选图片</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112135688.png" alt="202205050911564"></p></li><li><p>通过inject插入一些CSS和JS代码段来实现扩展（进阶）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;  </span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/iconfont/iconfont.css&quot;#阿里图标</span></span><br><span class="line">    <span class="comment">#横杠别忘了,这里我的图片懒得改了</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt; Js文件同理</span></span><br></pre></td></tr></table></figure><p>比如加入一些<a href="https://github.com/stevenjoezhang/live2d-widget">看板娘</a>）,更多内容可以参考<a href="https://www.cnblogs.com/yunmuq/p/14088220.html">自定义主题</a></p><p>这里实质上参考了《js高级程序设计》，将JS代码放在body的最后面。如果要修改看板娘形象，可以参考<a href="https://www.xiaoweigod.com/share/2068.html">某大佬血小板教程</a></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112135633.png" alt="202205050911111"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112135466.png" alt="202205050911907"></p></li></ul></li><li><p>修改结果的展示</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112136822.png" alt="202205050912259"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112136077.png" alt="202205050912653"></p></li><li><p>如果觉得还是不够，作者是通过pug文件自动添加span。如果需要更改其他的，在themes\butterfly\layout\includes\找到span=_p(“名字”)就可以修改。（不推荐，主题更新后可以添加自定义侧边栏)</p><p>比如这里我把公告更改了图标并改成了其他东西。</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112136559.png" alt="202205050912698"></p><p>更改后效果：</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112137475.png" alt=""></p><p>进阶：侧边栏的盒子模型更改（需基础CSS知识），通过本次修改学会导入外部的层叠样式表</p><p>因为侧边栏的位置有点偏，导致我的音乐盒其实是不对称的，修改后如上图</p><ul><li><p>css文件中添加要修改的盒子模型代码</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112137351.png" alt="202205050912035"></p></li><li><p>最后注意，插入的样式表可能权重不够，可能无法生效，所以在作者加权重的地方加上这个文件。butterfly是在css文件夹的index.styl文件中。</p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112138051.png" alt="202205050912678"></p><p><img src="https://supervisen-imgbed.oss-cn-hangzhou.aliyuncs.com/img/202205112138640.png" alt=""></p></li></ul></li></ol><hr><h2 id="center-总结"><center>总结</h2><p>    目前实现的是本地博客和GitHub Pages绑定，图片上传没有图床的话不够便利，推荐采用PicGo+GitHub做图床。采用使用Typora作为写作工具，操作简单（收费？<a href="https://www.123pan.com/s/nmk9-1k08H">破解版</a>或者使用<a href="https://gitee.com/mirrors/Mark-Text">Mark-Text</a>可以导出到公众号/知乎，并且支持图床和修改自定义CSS样式）；也可以采用Vscode代替Typora，再加上PicGo插件实现自动上传图片到Github图床。好了，大家可以不断通过<strong>hexo g &amp;&amp; hexo d</strong>上传代码，主题配置提交更改前必须先使用hexo clean。这里再放个<a href="https://markdown.com.cn/">Markdown教程</a>(有可能git会在上传时提示“warning: LF will be replaced by CRLF”，附上<a href="https://www.jianshu.com/p/450cd21b36a4">解决方法</a>)。</p>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
